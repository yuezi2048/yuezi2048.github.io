<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>yuezi</title><meta name="author" content="yuezi"><meta name="copyright" content="yuezi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="积微者速成">
<meta property="og:type" content="website">
<meta property="og:title" content="yuezi">
<meta property="og:url" content="https://yuezi2048.github.io/page/2/index.html">
<meta property="og:site_name" content="yuezi">
<meta property="og:description" content="积微者速成">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuezi2048.github.io/img/touxiang.jpg">
<meta property="article:author" content="yuezi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuezi2048.github.io/img/touxiang.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuezi2048.github.io/page/2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?bfb48b678d82bea9f9cc9d59227767e4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"FPH6F2TOJL","apiKey":"06d9ea26c803ba912b4d8e13404ed34d","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'yuezi',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'home'
}</script><link rel="stylesheet" href="/css/backgound.css"><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">785</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">91</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url(/img/backgroud.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yuezi</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="site-info"><h1 id="site-title">yuezi</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts nc" id="recent-posts"><div class="recent-post-items"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/25/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/25.@Async%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%A4%B1%E6%95%88/" title="25.@Async什么时候失效">25.@Async什么时候失效</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-25T14:26:39.000Z" title="发表于 2025-11-25 22:26:39">2025-11-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">注：和事务类似，基于动态代理的，所以绕过了动态代理也就失效了。 @Async 失效的主要原因包括内部调用绕过代理、方法非 public、未启用异步支持、返回值类型不匹配、异常处理不当、线程池配置错误以及对象未被 Spring 管理等。  AOP失效 内部调用：@Async 依赖于 AOP动态代理，内部调用会绕过代理对象，直接调用原始方法，解决： 异步方法提取到单独的Bean 注入自身Bean并通过其调用异步方法 使用 AopContext.currentProxy() 获取代理对象调用。   非公共方法：AOP只对public方法生效 异常处理不当：这样异常就不会传播到调用方，导致问题被忽略 可以使用 try-catch 捕获异常或者配置全局异常处理器   Spring上下文未加载：@Async依赖IOC容器管理bean，所以对象必须要被Spring管理，不要手动new   异步支持： 主类或者配置类启用 @EnableAsync 注解 返回值匹配：void、Future、CompletableFuture...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/25/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/24.%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90@Autowired/" title="24.为什么不推荐@Autowired">24.为什么不推荐@Autowired</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-25T14:26:29.000Z" title="发表于 2025-11-25 22:26:29">2025-11-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content"> Spring官方推荐构造器注入，而不是字段注入，原因：  可能有空指针异常  单元测试不友好  掩盖循环依赖问题    @Autowired 实际上 Spring 提供的，导致了业务代码和框架强绑定，如果更换给其他 IOC 框架则不适用了  @Resource 是 JSR-250 提供的，它是 Java 的标准，因此如果非要使用字段注入也应该使用 @Resource。    扩展知识字段注入的缺点需要注意空指针问题@Autowiredprivate MianshiyaService mianshiyaService;private String mianshiya;public Mianshiya() &#123;    this.mianshiya = mianshiyaService.getYa();&#125;  例如上述的代码，Spring 启动后会报空指针错误！因为构造方法的执行顺序高于 @Autowired 的顺序。所以在执行这个类的构造方法时，mianshiyaService 还未被注入，因此它的值还是 null，所以报错了。 与 IOC...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/25/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/23.SpringBoot%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%9C%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E6%89%A7%E8%A1%8C%E7%89%B9%E5%AE%9A%E4%BB%A3%E7%A0%81/" title="23.SpringBoot有哪些方式在启动时执行特定代码">23.SpringBoot有哪些方式在启动时执行特定代码</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-25T14:26:18.000Z" title="发表于 2025-11-25 22:26:18">2025-11-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">根据SpringBoot加载和Spring的初始化，中间加入相关的内容即可：  bean初始化执行方法的顺序整理：  BeanPostProcessor#postProcessBeforeInitialization 生命周期接口回调 @PostConstruct afterPropertiesqSet（实现 InitializingBean 接口）   initMethod BeanPostProcessor#postProcessAfterInitialization    常见一共有六种方式： SpringBoot启动完成后：  实现 CommandLineRunner 接口：CommandLineRunner 接口用于在 Spring Boot 应用启动完成后，执行特定的代码逻辑。可以有多个实现类，按照 @Order 注解的顺序执行。  @Component@Order(1)public class MyCommandLineRunner implements CommandLineRunner &#123;    @Override    public void...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/25/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/22.SpringBoot%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/" title="22.SpringBoot如何实现异步处理">22.SpringBoot如何实现异步处理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-25T14:25:59.000Z" title="发表于 2025-11-25 22:25:59">2025-11-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">主要有四种方式来实现异步处理：  使用 @Async 注解 使用 CompletableFuture 使用 @Scheduled 注解 使用线程池  @Async@Async 是 Spring 提供的注解，用于指定某个方法在另一个线程中异步执行。 只要在配置类上添加 @EnableAsync 注解，然后在需要异步执行的方法上添加 @Async 注解即可实现。 @Servicepublic class AsyncService &#123;    @Async    public void asyncMethod() &#123;        // 异步执行的代码        System.out.println(&quot;Executing method asynchronously. &quot; + Thread.currentThread().getName());    &#125;&#125;@Configuration@EnableAsyncpublic class AsyncConfig...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/25/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/21.SpringBoot%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/" title="21.SpringBoot如何实现多数据源配置">21.SpringBoot如何实现多数据源配置</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-25T14:25:49.000Z" title="发表于 2025-11-25 22:25:49">2025-11-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content"> 配置文件定义多数据源 对每隔数据源配置DataSource、SqlSessionFactory 和 TransactionManager 主数据源@Primary   为每个数据源配置独立的 Mapper 扫描路径 使用 @Transactional 指定事务管理器，保证每个数据源的事务管理独立，避免数据源之间的事务冲突。  扩展知识1. 在配置文件中定义多数据源首先，在 application.yml 或 application.properties 文件中为不同的数据源定义连接信息。 示例：application.yml spring:  datasource:    primary:      url: jdbc:mysql://localhost:3306/primary_db      username: root      password: root      driver-class-name: com.mysql.cj.jdbc.Driver    secondary:      url:...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/25/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/4.SpringBoot%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87main%E6%96%B9%E6%B3%95%E5%90%AF%E5%8A%A8web/" title="4.SpringBoot如何通过main方法启动web">4.SpringBoot如何通过main方法启动web</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-25T14:23:31.000Z" title="发表于 2025-11-25 22:23:31">2025-11-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">Spring Boot 应用的启动流程都封装在 SpringApplication.run 方法中，它的大部分逻辑都是复用 Spring 启动的流程，只不过在它的基础上做了大量的扩展。 在启动的过程中有一个刷新上下文的动作，这个方法内会触发 webServer 的创建，此时就会创建并启动内嵌的 web 服务，默认的 web 服务就是 tomcat。 Spring Boot 的启动过程几个核心步骤： SpringApplication.run()：这是启动的入口，它会创建 Spring 应用上下文，并执行自动配置。 创建应用上下文：为 Web 应用创建 AnnotationConfigServletWebServerApplicationContext 上下文。 启动内嵌 Web 服务器：在 refreshContext() 阶段启动内嵌的 Web 服务器（如 Tomcat）。 自动配置：通过 @EnableAutoConfiguration 自动配置各种组件，如 DispatcherServlet。 请求处理：内嵌的 DispatcherServlet 负责处理 HTTP...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/25/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/20.SpringBoot%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3/" title="20.SpringBoot事件机制了解">20.SpringBoot事件机制了解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-25T14:22:59.000Z" title="发表于 2025-11-25 22:22:59">2025-11-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">Spring Boot...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/25/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/18.SpringBoot2.x%E5%AF%B9%E6%AF%941.x/" title="18.SpringBoot2.x对比1.x">18.SpringBoot2.x对比1.x</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-25T14:22:38.000Z" title="发表于 2025-11-25 22:22:38">2025-11-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content"> SpringBoot2.x引入Spring5，其中一个重要特性是： 响应式编程（Reactive Programming）的支持 引入的嵌入式Web容器升级（可以带来更好的性能，以及对HTTP&#x2F;2等新标准支持） Tomcat：从 8.x 升级到 9.x。 Jetty：从 9.x 升级到 10.x。 Undertow：从 1.x 升级到 2.x。   SpringBoot2.x在底层组件（如 Tomcat、Hibernate 等）和框架本身有性能优化，启动更快，性能更高，适合云原生、大规模微服务架构 如数据库HikariCP连接池（优化原先的默认Tomcat JDBC）、以及JPA的改进，对Hibernate 5.x有更好支持   新的 Actuator 端点：2.x支持更多默认监控端点，重新设计安全性、暴露策略——默认情况下，大多数端点是关闭的，按需显式启用断点 自动配置增强：增加了更多常用技术栈的自动配置支持（如响应式编程、JPA 等），使得应用的自动配置更智能，减少了开发者的手动配置工作。  扩展知识Spring Boot 2.x...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/25/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/17.Spring_Actuator/" title="17.Spring_Actuator">17.Spring_Actuator</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-25T14:22:23.000Z" title="发表于 2025-11-25 22:22:23">2025-11-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">Spring Boot Actuator 是 Spring Boot 提供的一个监控和管理功能的工具。可以监控：健康情况health、指标metrics、跟踪请求，管理环境参数env等 Actuator 提供了丰富的端点（Endpoints），用于展示和操作应用的内部状态。这些端点可以通过HTTP、JMX等方式进行访问。具有简便性、可扩展性、安全性、易于集成（举例：集成Spring Security配置访问权限，保障一些敏感断点的安全性） 它的优势：  易于集成：开箱即用，简单配置即可使用，可以很容易地与外部监控系统集成，如 Prometheus、Grafana 等。 丰富的端点：提供了大量预定义的端点，如健康检查（&#x2F;health）、应用信息（&#x2F;info）、度量指标（&#x2F;metrics）等。 丰富的信息：提供了关于应用、系统、JVM、内存、线程等丰富的信息。 高度可扩展：可以自定义端点，扩展或修改现有的端点功能。 安全性：支持端点的安全访问控制，可以通过配置限制哪些端点可以公开访问。  扩展知识Spring Actuator...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/25/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/16.%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" title="16.如何实现定时任务">16.如何实现定时任务</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-25T14:22:15.000Z" title="发表于 2025-11-25 22:22:15">2025-11-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">通过@Scheduled 注解就可以开启定时任务  首先需要在启动类，配置类添加**@EnableScheduling** 注解，启用 Spring 的调度器来执行定时任务。  @SpringBootApplication@EnableSchedulingpublic class MyApplication &#123;   public static void main(String[] args) &#123;       SpringApplication.run(MyApplication.class, args);   &#125;&#125;   使用 @Scheduled 注解标记方法，定义该方法为一个定时任务。 支持多种方式定义任务的执行周期，包括 fixedRate、fixedDelay 和 cron 表达式。    示例： @Servicepublic class MyTaskService &#123;   // 每 5 秒执行一次任务   @Scheduled(fixedRate = 5000)   public void executeTask()...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/25/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/15.SpringBoot%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8/" title="15.SpringBoot如何使用拦截器">15.SpringBoot如何使用拦截器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-25T14:22:06.000Z" title="发表于 2025-11-25 22:22:06">2025-11-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">拦截器一般是对于Controller层面的前后拦截，我一般会用来进行权限校验、日志记录、异常处理等，具体的实现方式： 1）实现HandlerInterceptor接口，并实现接口中的方法：请求前，请求后，整个请求结束后（一般是资源清理） 2）实现WebMvcConfigurer的addInterceptors方法来添加自定义的拦截器。  拦截器与过滤器的区别总结：  拦截时机：拦截器是在MVC处理请求前后，过滤器是Servlet层面，拦截所有HTTP请求 应用：拦截器一般是Controller相关逻辑，如权限、日志等，过滤器更适合全局的HTTP请求操作，如字符编码，CORS处理等 优先级：过滤器优先级高，先于拦截器处理请求   具体代码如下：1）创建拦截器类： 需要实现 HandlerInterceptor 接口或继承 HandlerInterceptorAdapter（Spring 5.3...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/25/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/14.%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82CORS/" title="14.如何处理跨域请求CORS">14.如何处理跨域请求CORS</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-25T14:21:54.000Z" title="发表于 2025-11-25 22:21:54">2025-11-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">Spring Boot 处理跨域请求主要有以下几种方式：  局部配置 CORS，在 Controller 上使用 @CrossOrigin 注解。这种方式简单直接，适合对类进行跨域设置。  	  全局配置 CORS，可以通过实现 WebMvcConfigurer 接口并重写 addCorsMappings 方法，可以对整个应用程序进行统一的跨域配置。  	  还可以**添加 CorsFilter **来处理跨域请求。（或者可以自定义 Filter，但是没必要，因为本身已经提供了 CorsFilter）  	  addCorsMappings与CorsFilter 处理的区别  注：如果配置了addCorsMappings，项目里还用了Interceptor（部分接口需要iwt 权限验证），会出现问题 没有token...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/22/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/1.SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="1.SpringBoot启动流程">1.SpringBoot启动流程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-22T13:07:49.000Z" title="发表于 2025-11-22 21:07:49">2025-11-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">main方法为入口：SpringApplication.run() 引导应用启动  new SpringApplication()：创建SpringApplication对象，推断应用类型(根据类路径依赖判断servlet&#x2F;reative)——设置初始化器——设置启动监听器——确定主应用类 run方法： 准备环境ConfigurableEnvironment：，读取application.properties、系统变量 命令行参数等配置文件 创建并刷新应用上下文ApplicationContext：加载配置类、自动配置类，刷新则进行 注册bean，依赖注入等初始化操作 对于web应用，刷新应用上下文后，自动启动嵌入式web服务器   发布started事件：启动完成后发送应用启动事件 回调函数：调用实现了CommandLineRunner或者ApplicationRunner接口的bean，执行一些初始化逻辑 发布rready事件...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/22/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/13.%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3SpringBoot%E7%9A%84Starter/" title="12.如何理解SpringBoot的Starter">12.如何理解SpringBoot的Starter</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-22T13:07:14.000Z" title="发表于 2025-11-22 21:07:14">2025-11-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">在 Spring Boot 中，Starter定义的是一组依赖集合，简化配置的构建，通过Starter POMs提供多个功能模块的集成，开发者只需引入starter就能自动获得模块所有的依赖和配置，无需手动引入多个依赖库配置文件  类比：买电脑直接买整机，别人把所有零件打包好了，不需要一个个配件装。 注：SpringBoot3.x spring.factories废弃，使用的是imports后缀的文件，只需要放入实现类的全类名即可：com.example.starter.MyAutoConfiguration 追问：让你写一个starter，实现思路步骤？  一般先创建maven项目，添加SpringBoot和其他相关依赖  首先可以配置属性类，通过@ConfigurationProperties等注解，进行配置文件的前缀修改配置  编写业务逻辑  创建自动配置类，分析业务，通过@Configuration 和 @ConditionalOnxxx 注解来条件化的配置 Bean  src&#x2F;main&#x2F;resources&#x2F;META-INF 目录下创建...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/22/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/12.SpringBoot%E9%BB%98%E8%AE%A4%E5%A4%84%E7%90%86%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%E5%A4%9A%E5%B0%91/" title="11.SpringBoot默认处理最大连接数多少">11.SpringBoot默认处理最大连接数多少</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-22T13:07:00.000Z" title="发表于 2025-11-22 21:07:00">2025-11-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content"> tomcat能处理的最大连接数 &#x3D; 最大连接数 8192 +  等待数 100 tomcat能处理的最大请求线程数 &#x3D; 200，核心线程数10，队列长度无限（因为是IO密集型，线程池策略区别于默认JDK线程池的机制）  拿 Spring Boot 默认的容器 Tomcat 为例，从引入的 spring-boot-autoconfigure 依赖可以看出，Tomcat 默认的最大连接数是 8192 。  但这里要注意！Tomcat 还有一个默认等待数，加上这个才是 SpringBoot 默认的最大连接数。  所以 SpringBoot 默认同时可以处理的最大连接数 &#x3D; Tomcat 默认的最大连接数 + Tomcat 默认等待数 &#x3D; 8192 + 100 &#x3D; 8292。 这个 Tomcat 配置可以用过配置文件修改，以下是一个 yml 配置的例子： server:  tomcat:    max-connections: 6000 # 最大连接数    accept-count: 100 #...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/22/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/11.SpringBoot%E8%83%BD%E5%90%A6%E7%94%A8XML%E9%85%8D%E7%BD%AE/" title="10.SpringBoot能否用XML配置">10.SpringBoot能否用XML配置</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-22T13:06:52.000Z" title="发表于 2025-11-22 21:06:52">2025-11-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">虽然 Spring Boot 强调基于 Java 注解和属性文件的配置，但仍然支持传统的 XML 配置。 实现方式： @ImportResource 注解导入 XML 配置文件，让 Spring Boot 应用程序能够识别和使用这些 Bean。 场景：一般是公司在将 Spring 项目迁移到 Spring Boot 时，因为时间或工作量问题，才会在过渡期间混合使用两者。SpringBoot 项目不太会使用 XML 配置。 </div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/22/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/10.SpringBoot%E6%89%93%E5%8C%85%E7%9A%84jar%E5%92%8C%E6%99%AE%E9%80%9Ajar%E5%8C%BA%E5%88%AB/" title="9.SpringBoot打包的jar和普通jar区别">9.SpringBoot打包的jar和普通jar区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-22T13:06:42.000Z" title="发表于 2025-11-22 21:06:42">2025-11-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">Spring Boot 打成的 JAR 包：应用程序源代码class + 依赖库lib + 程序需要的配置&#x2F;脚本 + 服务依赖（内嵌服务器Tomcat、类加载器等） 普通JAR包：只有源代码 + 依赖，需要外部服务器 &#x2F; 容器运行 扩展知识Spring Boot jar 结构myapp.jar|-- META-INF/|   |-- MANIFEST.MF  # JAR 的清单文件，指向主类|-- BOOT-INF/|   |-- classes/     # 应用的 .class 文件和资源文件|   |-- lib/         # 应用的依赖库|-- org/springframework/boot/loader/  # Spring Boot 的自定义类加载器|   |-- JarLauncher.class|   |-- WarLauncher.class  BOOT-INF 目录，用于存放应用的类和资源。 lib 目录，用于存放所有依赖。 META-INF&#x2F;MANIFEST.MF 文件，指定了主类和启动类。 普通 jar...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/22/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/9.%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%85%88%E7%BA%A7/" title="8.配置文件加载优先级">8.配置文件加载优先级</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-22T13:06:31.000Z" title="发表于 2025-11-22 21:06:31">2025-11-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">优先级：  命令行参数  &lt;— JAR包外的 application-{profile}.properties &lt;—JAR包外的 application.properties  &lt;— JAR包内的 application-{profile}.properties  &lt;— JAR包内的 application.properties 注： application.properties 和 application.yml 同时存在，同样的参数，最终生效的是 application.properties 中的配置。 分布式中boostrap 由父 ApplicationContext 加载，比 applicaton 优先加载，且它里面的内容不会被覆盖！如配置中心配置  完整优先级参考如下的官方文档：  从上到下，优先级逐渐降低，即下面的配置，同样的参数会被上面的配置所覆盖。 扩展知识bootstrap 和 application 配置文件boostrap 由父 ApplicationContext 加载，比 applicaton...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/22/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/8.%E5%A6%82%E4%BD%95%E5%9C%A8SpringBoot%E5%AE%9A%E4%B9%89%E5%92%8C%E8%AF%BB%E5%8F%96%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE/" title="7.如何在SpringBoot定义和读取自定义配置">7.如何在SpringBoot定义和读取自定义配置</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-22T13:05:58.000Z" title="发表于 2025-11-22 21:05:58">2025-11-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">简单的可以分为三种: 1）使用 @Value 注解： @Value(&quot;$&#123;my.custom.property&#125;&quot;)private String myProperty;  2）使用 @ConfigurationProperties 注解： @Component@ConfigurationProperties(prefix = &quot;my.custom&quot;)public class MyCustomProperties &#123;    private String property;&#125;  3）使用 Environment 接口： @Autowiredprivate Environment env;public void someMethod() &#123;    String value = env.getProperty(&quot;my.custom.property&quot;);&#125;</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/22/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/7.application_properties_yml%E5%8C%BA%E5%88%AB/" title="6.application_properties_yml区别">6.application_properties_yml区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-22T13:05:41.000Z" title="发表于 2025-11-22 21:05:41">2025-11-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">它们两者的区别就在于书写格式，对配置而言效果是一样的，就是个人偏好问题。  application.properties 使用kv键值对配置，键和值之间用等号或冒号分隔 application.yml 使用 YAML （YAML Ain’t Markup Language）格式，具有层级结构，使用缩进表示嵌套关系。适合复杂配置，阅读性更佳。   加载的时候先加载application.properties，然后加载application.yml，如果有相同的配置，生效的是application.properties的。  扩展知识示例application.properties server.port=8080spring.datasource.url=jdbc:mysql://localhost:3306/dbspring.datasource.username=rootspring.datasource.password=secret  application.yml server:  port: 8080spring:  datasource:    url:...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/22/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/6.SpringBoot%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9BWeb%E5%AE%B9%E5%99%A8/" title="5.SpringBoot支持哪些Web容器">5.SpringBoot支持哪些Web容器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-22T13:05:30.000Z" title="发表于 2025-11-22 21:05:30">2025-11-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">Spring Boot 支持以下嵌入 web 容器：  Tomcat（servlet默认）：  Tomcat 是 Spring Boot 默认的嵌入式 Web 容器。Tomcat 是一种轻量级、广泛使用的 Servlet 容器，Spring Boot 会自动将 Tomcat 内嵌到应用程序中。   Jetty（嵌入式应用，资源敏感型应用）：  Jetty 是一个高效的 Web 服务器和 Servlet 容器，通常用于嵌入式系统或对资源占用较敏感的环境。它比 Tomcat 更轻量，并且适合长连接应用（如 WebSocket、Comet）。   Undertow（高并发，高性能服务器）：  Undertow 是一个轻量级的高性能 Web 服务器和 Servlet 容器，适合用于处理高并发的 HTTP 请求。它支持异步 IO 和 HTTP&#x2F;2，是一种灵活、性能出色的选择。   Netty（仅限 WebFlux响应式）：  对于使用 Spring WebFlux 的响应式 Web 应用，Spring Boot 支持 Netty 作为嵌入式 Web 容器。Netty...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/22/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/5.SpringBoot%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/" title="4.SpringBoot如何实现自动配置">4.SpringBoot如何实现自动配置</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-22T13:05:21.000Z" title="发表于 2025-11-22 21:05:21">2025-11-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">Spring Boot 的自动配置核心思想：基于@EnableAutoConfiguration注解，这个注解内部是@Import({AutoConfigurationImportSelector.class})，导入的类负责扫描classPath下所有的META_INF&#x2F;spring.factories的文件，根据文件指定的配置类加载对应的bean自动配置 而对于bean的加载时机，则通过 @ConditionalOnClass、@ConditionalOnMissingBean、@ConditionalOnProperty 等条件注解来控制自动配置的加载条件，比如仅在类路径中存在某个类时，才加载某些配置。  场景1：这个原理在我阅读我组长写的starter源码的时候就用到了这个方法来进行自动配置 场景2：@SpringBootApplication(exclude &#x3D; {DataSourceAutoConfiguration.class})，云图库项目中开发环境下不需要分表相关的模块增加难度，我就去掉了提高测试效率。  扩展知识Spring Boot...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/22/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/3.SpringBoot%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7/" title="3.SpringBoot核心特性">3.SpringBoot核心特性</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-22T13:05:12.000Z" title="发表于 2025-11-22 21:05:12">2025-11-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">核心特性一共五点：  自动配置：这是 Spring Boot 最核心的特性。它能根据项目里引入的依赖（比如引入了spring-boot-starter-web，就知道是Web项目），自动配置 Tomcat、Spring MVC 等组件。 底层是通过 @EnableAutoConfiguration + spring.factories 实现的条件装配机制，节省大量 XML 配置。   Starters 依赖启动器：把常用场景的依赖打包成 starters（web–spring-boot-starter-web、数据库–spring-boot-starter-data-jpa），项目里只需引入一个 starter，就能自动拉取该场景下所有需要的依赖，避免手动管理依赖版本冲突。 内嵌容器：内置 Tomcat、Jetty、Undertow 等 Web 容器，可打成 jar 包直接通过 java -jar 启动，不需额外部署 WAR 包，简化了部署流程。 外部化配置：支持多环境配置（如 application.yml &#x2F;...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/22/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/2.%E4%BB%80%E4%B9%88%E6%98%AFSpringBoot/" title="2.什么是SpringBoot">2.什么是SpringBoot</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-22T13:05:06.000Z" title="发表于 2025-11-22 21:05:06">2025-11-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/SpringBoot/">SpringBoot</a></span></div><div class="content">SpringBoot主要是用于简化Spring开发的框架，核心目标是为了减少Spring的配置和开发复杂性，更快构建、测试和部署 Spring 应用 思想：SpringBoot通过提供默认配置 + 自动化配置 + 嵌入式服务器等方式，简化传统Spring的配置过程，我们只需要引用就能开箱即用，实现快速开发  相关内容：starter、内置服务器有哪些、Spring Boot Actuator提供的断点  扩展知识Spring Boot 主要特点 简化配置：Spring Boot 通过自动配置（@EnableAutoConfiguration），根据项目中的类路径依赖、环境变量等自动为应用配置适当的 Spring 模块，避免了大量的 XML 配置。 内置服务器：Spring Boot 内置了 Tomcat、Jetty、Undertow 等服务器，应用程序可以直接通过 java -jar 方式启动，而不需要部署到外部的 Web 服务器中。 快速开发：Spring Boot...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/22/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/71.Spring%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8C%BA%E5%88%AB/" title="71.Spring的拦截器和过滤器区别">71.Spring的拦截器和过滤器区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-22T11:42:19.000Z" title="发表于 2025-11-22 19:42:19">2025-11-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">过滤器（Filter）和拦截器（Interceptor）都是用于对请求进行预处理或后处理的机制，但它们的应用场景和实现方式有点不一样。  拦截器是SpringMVC中的一个组件。 过滤器拦截所有的请求，包括静态资源的访问。  拦截器一般是拦截controller层的请求      实现机制 使用范围 配置方式 执行顺序 功能侧重    过滤器（Filter） Servlet 规范，独立于Spring框架存在。用于过滤请求和响应，可以对所有类型的请求进行处理。 可以过滤所有的请求，包括静态资源、JSP、HTML等，因为它是在Servlet容器层面生效。 需要实现 Filter 接口，并通过标准的 Servlet 配置方式进行注册，或者在 Spring Boot 中使用 @Component 注解自动注册。 先于拦截器执行。因为过滤器作用于 Servlet 容器层面，而拦截器则是在 Spring MVC 的处理器映射器找到控制器之前或之后执行。 更侧重于过滤请求和响应的内容，例如设置编码格式、安全控制等。   拦截器（Interceptor） 属于Spring 框架，基于 Java...</div></div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/#content-inner">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/#content-inner">32</a><a class="extend next" rel="next" href="/page/3/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yuezi</div><div class="author-info-description">积微者速成</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">785</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">91</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuezi2048"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">积微者速成</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/22/Excalidraw/Drawing%202024-11-01%2015.37.37.excalidraw/" title="Drawing 2024-11-01 15.37.37.excalidraw">Drawing 2024-11-01 15.37.37.excalidraw</a><time datetime="2026-02-22T05:56:41.839Z" title="发表于 2026-02-22 13:56:41">2026-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/22/2.Areas%F0%9F%8C%90/01.project/condefather/yupao/back-end/7.%E4%BC%98%E5%8C%96%E4%B8%BB%E9%A1%B5%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/" title="7.优化主页性能-优化批量导入数据">7.优化主页性能-优化批量导入数据</a><time datetime="2026-02-22T05:56:41.257Z" title="发表于 2026-02-22 13:56:41">2026-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/31/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/5.%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8/" title="5.工具调用">5.工具调用</a><time datetime="2026-01-31T03:54:22.000Z" title="发表于 2026-01-31 11:54:22">2026-01-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/30/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/4.RAG%E8%BF%9B%E9%98%B6/" title="4.RAG进阶">4.RAG进阶</a><time datetime="2026-01-30T13:23:42.000Z" title="发表于 2026-01-30 21:23:42">2026-01-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/3.RAG/" title="3.RAG">3.RAG</a><time datetime="2026-01-27T09:06:56.000Z" title="发表于 2026-01-27 17:06:56">2026-01-27</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
      <i class="fas fa-angle-right"></i></a>
          </div>
          <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/0-InBox%F0%9F%90%AD/"><span class="card-category-list-name">0.InBox🐭</span><span class="card-category-list-count">2</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/0-InBox%F0%9F%90%AD/md/"><span class="card-category-list-name">md</span><span class="card-category-list-count">2</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/"><span class="card-category-list-name">2.Areas🌐</span><span class="card-category-list-count">766</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/00-%E7%A7%8B%E6%8B%9B%E5%87%86%E5%A4%87%E6%96%B9%E5%90%91/"><span class="card-category-list-name">00.秋招准备方向</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/"><span class="card-category-list-name">01.project</span><span class="card-category-list-count">25</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/"><span class="card-category-list-name">condefather</span><span class="card-category-list-count">25</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/tuku/"><span class="card-category-list-name">tuku</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/user-center/"><span class="card-category-list-name">user-center</span><span class="card-category-list-count">9</span></a></li></ul></li></ul></li></ul></li>
          </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/3-JDBC/" style="font-size: 1.15em; color: #999b9e">3.JDBC</a> <a href="/tags/Github/" style="font-size: 1.13em; color: #999a9b">Github</a> <a href="/tags/front-end/" style="font-size: 1.1em; color: #999">front-end</a> <a href="/tags/%E8%AE%BA%E6%96%87%E6%A2%B3%E7%90%86/" style="font-size: 1.4em; color: #99a5b6">论文梳理</a> <a href="/tags/condefather/" style="font-size: 1.1em; color: #999">condefather</a> <a href="/tags/5-Maven%E4%B8%93%E9%A2%98/" style="font-size: 1.13em; color: #999a9b">5.Maven专题</a> <a href="/tags/7-SpringBoot/" style="font-size: 1.23em; color: #999ea5">7.SpringBoot</a> <a href="/tags/01/" style="font-size: 1.18em; color: #999ca0">01</a> <a href="/tags/%E5%B0%8F%E8%AE%BA%E6%96%87%E5%87%86%E5%A4%87/" style="font-size: 1.28em; color: #99a0aa">小论文准备</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/" style="font-size: 1.1em; color: #999">代码实现</a> <a href="/tags/Transformer%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" style="font-size: 1.32em; color: #99a2ae">Transformer前世今生</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 1.48em; color: #99a8bd">Java基础</a> <a href="/tags/md/" style="font-size: 1.13em; color: #999a9b">md</a> <a href="/tags/JUC/" style="font-size: 1.45em; color: #99a7ba">JUC</a> <a href="/tags/Spring/" style="font-size: 1.5em; color: #99a9bf">Spring</a> <a href="/tags/JVM/" style="font-size: 1.43em; color: #99a6b8">JVM</a> <a href="/tags/%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86/" style="font-size: 1.1em; color: #999">论文整理</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/" style="font-size: 1.38em; color: #99a4b3">基础篇——韩顺平</a> <a href="/tags/%E6%80%BB%E4%BD%93%E8%A7%84%E5%88%92/" style="font-size: 1.13em; color: #999a9b">总体规划</a> <a href="/tags/vue/" style="font-size: 1.13em; color: #999a9b">vue</a> <a href="/tags/%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0%E6%80%BB%E7%BB%93/" style="font-size: 1.13em; color: #999a9b">论文复现总结</a> <a href="/tags/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/" style="font-size: 1.18em; color: #999ca0">基本方法</a> <a href="/tags/SpringMVC/" style="font-size: 1.28em; color: #99a0aa">SpringMVC</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%AF%87/" style="font-size: 1.3em; color: #99a1ac">基础篇</a> <a href="/tags/back-end/" style="font-size: 1.35em; color: #99a3b1">back-end</a> <a href="/tags/%E8%AE%BA%E6%96%87/" style="font-size: 1.13em; color: #999a9b">论文</a> <a href="/tags/Excalidraw/" style="font-size: 1.1em; color: #999">Excalidraw</a> <a href="/tags/1-%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" style="font-size: 1.25em; color: #999fa7">1.监督学习</a> <a href="/tags/%E6%A8%A1%E5%9E%8B%E6%95%B4%E7%90%86/" style="font-size: 1.1em; color: #999">模型整理</a> <a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/" style="font-size: 1.23em; color: #999ea5">云服务器运行环境</a> <a href="/tags/docker/" style="font-size: 1.1em; color: #999">docker</a> <a href="/tags/%E5%AE%9E%E9%AA%8C/" style="font-size: 1.1em; color: #999">实验</a> <a href="/tags/pytorch%E5%9F%BA%E6%9C%AC%E5%8A%9F/" style="font-size: 1.15em; color: #999b9e">pytorch基本功</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" style="font-size: 1.3em; color: #99a1ac">代码随想录</a> <a href="/tags/communication/" style="font-size: 1.1em; color: #999">communication</a> <a href="/tags/Mybatis/" style="font-size: 1.18em; color: #999ca0">Mybatis</a> <a href="/tags/%E5%B0%8F%E8%AE%BA%E6%96%87%E6%95%85%E4%BA%8B%E7%BA%BF%E5%92%8C%E6%A8%A1%E5%9D%97%E8%AE%B0%E5%BD%95%E7%B4%A0%E6%9D%90/" style="font-size: 1.2em; color: #999da3">小论文故事线和模块记录素材</a> <a href="/tags/%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/" style="font-size: 1.1em; color: #999">基本问题</a> <a href="/tags/SSM%E6%95%B4%E5%90%88/" style="font-size: 1.1em; color: #999">SSM整合</a> <a href="/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/" style="font-size: 1.13em; color: #999a9b">算法基础课</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>归档</span>
      <a class="card-more-btn" href="/archives/"
            title="查看更多">
            <i class="fas fa-angle-right"></i>
          </a>
    </div>
  
    <ul class="card-archive-list">
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2026/02/">
            <span class="card-archive-list-date">
              二月 2026
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2026/01/">
            <span class="card-archive-list-date">
              一月 2026
            </span>
            <span class="card-archive-list-count">5</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/11/">
            <span class="card-archive-list-date">
              十一月 2025
            </span>
            <span class="card-archive-list-count">177</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/10/">
            <span class="card-archive-list-date">
              十月 2025
            </span>
            <span class="card-archive-list-count">199</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/09/">
            <span class="card-archive-list-date">
              九月 2025
            </span>
            <span class="card-archive-list-count">98</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/08/">
            <span class="card-archive-list-date">
              八月 2025
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/07/">
            <span class="card-archive-list-date">
              七月 2025
            </span>
            <span class="card-archive-list-count">39</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/06/">
            <span class="card-archive-list-date">
              六月 2025
            </span>
            <span class="card-archive-list-count">24</span>
          </a>
        </li>
      
    </ul>
  </div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">785</div></div><div class="webinfo-item"><div class="item-name">运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2025-04-05T00:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">1222.8k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总浏览量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2026-02-22T05:57:08.605Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/backgroud.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2026 By yuezi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>window.typedJSFn = {
  init: str => {
    window.typed = new Typed('#subtitle', Object.assign({
      strings: str,
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50,
    }, null))
  },
  run: subtitleType => {
    if (true) {
      if (typeof Typed === 'function') {
        subtitleType()
      } else {
        btf.getScript('https://cdn.jsdelivr.net/npm/typed.js/dist/typed.umd.min.js').then(subtitleType)
      }
    } else {
      subtitleType()
    }
  },
  processSubtitle: (content, extraContents = []) => {
    if (true) {
      const sub = [].slice()

      if (extraContents.length > 0) {
        sub.unshift(...extraContents)
      }

      if (typeof content === 'string') {
        sub.unshift(content)
      } else if (Array.isArray(content)) {
        sub.unshift(...content)
      }

      sub.length > 0 && typedJSFn.init(sub)
    } else {
      document.getElementById('subtitle').textContent = typeof content === 'string' ? content :
        (Array.isArray(content) && content.length > 0 ? content[0] : '')
    }
  }
}
btf.addGlobalFn('pjaxSendOnce', () => { typed.destroy() }, 'typedDestroy')
</script><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      const from = '出自 ' + data.from
      typedJSFn.processSubtitle(data.hitokoto, [from])
    })
    .catch(err => {
      console.error('Failed to get the Hitokoto API:', err)
      typedJSFn.processSubtitle([])
    })
}
typedJSFn.run(subtitleType)
</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>