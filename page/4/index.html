<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>yuezi</title><meta name="author" content="yuezi"><meta name="copyright" content="yuezi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="积微者速成">
<meta property="og:type" content="website">
<meta property="og:title" content="yuezi">
<meta property="og:url" content="https://yuezi2048.github.io/page/4/index.html">
<meta property="og:site_name" content="yuezi">
<meta property="og:description" content="积微者速成">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuezi2048.github.io/img/touxiang.jpg">
<meta property="article:author" content="yuezi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuezi2048.github.io/img/touxiang.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuezi2048.github.io/page/4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?bfb48b678d82bea9f9cc9d59227767e4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"FPH6F2TOJL","apiKey":"06d9ea26c803ba912b4d8e13404ed34d","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'yuezi',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'home'
}</script><link rel="stylesheet" href="/css/backgound.css"><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">785</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">91</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url(/img/backgroud.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yuezi</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="site-info"><h1 id="site-title">yuezi</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts nc" id="recent-posts"><div class="recent-post-items"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/18/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/45.@ModelAttribute/" title="45.@ModelAttribute">45.@ModelAttribute</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-18T02:54:25.000Z" title="发表于 2025-11-18 10:54:25">2025-11-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">@ModelAttribute 是 Spring MVC 中的一个注解，也是将请求的参数&#x2F;表单数据绑定到Controller方法参数 &#x2F; 添加到模型Model，便于在视图View展示，具体地有两种用法： 1）作用于方法参数——请求参数绑定对象：@ModelAttribute 注解可以用于控制器方法的参数上，表示将请求中的参数绑定到某个对象上，并将其添加到模型（Model）中，便于在视图层访问。 2）作用于方法级别——视图模型预处理：@ModelAttribute 注解也可以用在控制器方法上，表示在执行任何控制器方法之前，先运行带有该注解的方法，用来为视图模型添加预处理的数据。一般是模板引擎（ Thymeleaf、JSP 等）  那和@RequestBody区别？  @ModelAttribute 基于传统表单，URL参数对应的对象 @RequestBody 是用于处理 HTTP 请求体中的 JSON &#x2F;  XML 数据。   扩展知识@ModelAttribute 用于参数绑定当 @ModelAttribute...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/18/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/44.@PathVariable/" title="44.@PathVariable">44.@PathVariable</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-18T02:54:15.000Z" title="发表于 2025-11-18 10:54:15">2025-11-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">@PathVariable 是Spring MVC用于在URL模板中提取变量值的注解，是为了在处理HTTP请求时，从URL路径中获取变量，绑定到控制器的参数上 如http://example.com/users/123 后端 Java 可以按下面代码接收，适合RESTful风格的URL设计 @GetMapping(&quot;/users/&#123;userId&#125;&quot;)public ResponseEntity&lt;User&gt; getUserById(@PathVariable(&quot;userId&quot;) String userId) &#123;    User user = userService.getUserById(userId);    if (user != null) &#123;        return ResponseEntity.ok(user);    &#125; else &#123;        return ResponseEntity.notFound().build();   ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/18/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/43.@RequestBody%E5%92%8C@ResponseBody/" title="43.@RequestBody和@ResponseBody">43.@RequestBody和@ResponseBody</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-18T02:54:04.000Z" title="发表于 2025-11-18 10:54:04">2025-11-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">@RequestBody 和 @ResponseBody用于处理HTTP请求和响应的注解 1）@RequestBody：HTTP请求体绑定到方法参数上，将JSON &#x2F; XML等格式请求转换为java对象，传递给Conroller方法参数 2）@ResponseBody：控制器返回结果写入HTTP响应结果，一般是JSON &#x2F; XML，而不是视图页面  追问：工作原理是什么？ @RequestBody  请求体的JSON&#x2F;XML转换成Java对象核心是通过消息转换器（HttpMessageConverter），Spirng默认通过MappingJackson2HttpMessageConverter 来处理 JSON 数据 Spring通过拿到请求头的 Content-Type （客户端请求的类型） 选择合适的消息转换器。  @ResponseBody  和 @RequestBody 类似，也是通过消息转换器（HttpMessageConverter）将 Java 对象转换为 HTTP 响应体的 JSON &#x2F; XML...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/18/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/42.@PostConstruct%E5%92%8C@PreDestroy/" title="42.@PostConstruct和@PreDestroy">42.@PostConstruct和@PreDestroy</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-18T02:53:48.000Z" title="发表于 2025-11-18 10:53:48">2025-11-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">@PostConstruct 和 @PreDestroy 是Java标准的注解，Spring可通过它们管理Bean的生命周期  @PostConstruct：标记方法，当依赖注入完成后，在 Bean 初始化完成后调用，这个方法会自动被调用。常用于进行初始化逻辑。 如依赖注入后连接外部系统，或者需要验证关键属性是否配置   @PreDestroy：标记方法，在 Bean 即将被销毁时调用。常用于进行资源的释放、清理工作。 资源清理（数据库连接、文件句柄、线程池等），会话管理等，一般随着Spring容器关闭执行   注意原型bean不受生命周期影响，不会执行方法  扩展知识@PostConstruct 的使用场景与示例@PostConstruct 注解用于标识某个方法是 Bean 初始化后的回调方法。当 Spring 完成对 Bean 的依赖注入之后，它会自动调用带有 @PostConstruct 注解的方法。这个方法通常用于执行一些初始化逻辑，例如设置默认值、检查依赖等。 使用场景： 依赖注入后做额外的初始化工作：例如，某个服务需要在依赖注入后连接外部系统。 进行状态检查：在...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/18/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/41.@Profile/" title="41.@Profile">41.@Profile</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-18T02:53:36.000Z" title="发表于 2025-11-18 10:53:36">2025-11-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">@Profile 用于定义Bean的配置文件所属环境，如dev是开发环境，prod是生产环境 扩展知识实际应用举例@Configuration@Profile(&quot;dev&quot;) // 这个配置类只在 &quot;dev&quot; profile激活时加载public class DevConfig &#123;    @Bean    public DataSource dataSource() &#123;        // 返回开发环境的DataSource        return new EmbeddedDatabaseDataSource();    &#125;&#125;@Configuration@Profile(&quot;prod&quot;) // 这个配置类只在 &quot;prod&quot; profile激活时加载public class ProdConfig &#123;    @Bean    public DataSource dataSource() &#123;        // 返回生产环境的DataSource...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/18/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/39.@Primary%E6%B3%A8%E8%A7%A3%E4%BD%9C%E7%94%A8/" title="39.@Primary注解作用">39.@Primary注解作用</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-18T02:53:06.000Z" title="发表于 2025-11-18 10:53:06">2025-11-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">在 Spring 框架中，@Primary 注解用于标记当存在多个候选 Bean 时，应该优先注入哪一个。 它的主要作用是解决 Bean 注入时的歧义问题，当一个接口或父类有多个实现时，Spring 无法确定该注入哪个具体的 Bean，此时可以使用 @Primary 来指明首选的 Bean。 扩展知识使用场景1）多实现类：当一个接口有多个实现类，并且在注入时未明确指定要注入哪个实现类时，Spring 会报错。这时可以使用 @Primary 注解来指定一个首选的实现类。 2）注入优先级：在某些情况下，虽然存在多个候选 Bean，但我们希望某个特定的 Bean 在没有明确指定时被优先注入，这时可以使用 @Primary 注解。 代码举例import org.springframework.context.annotation.Primary;import org.springframework.stereotype.Component;public interface MyService &#123;    void...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/18/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/38.%E5%8D%95%E4%BE%8BBean%E6%98%AF%E5%90%A6%E6%9C%89%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/" title="38.单例Bean是否有并发问题">38.单例Bean是否有并发问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-18T02:52:05.000Z" title="发表于 2025-11-18 10:52:05">2025-11-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">有并发问题，因为bean在spring容器中默认是作为单例（singleton）管理，同一个bean实例在应用中被多个线程共享。 在多线程下，bean如果包含全局可变状态（实例变量 &#x2F; 非线程安全资源），就可能有线程安全问题 解决方案1）避免在单例 Bean 中使用可变状态：确保单例 Bean 是无状态的或仅使用线程安全的数据结构。 2）使用 @Scope(&quot;prototype&quot;)：对于有状态的 Bean，Spring 提供了原型作用域（prototype），每次请求都会创建一个新的 Bean 实例，从而避免共享同一个实例带来的并发问题。 3）加锁：如果需要在单例 Bean 中管理共享资源，可以通过 synchronized 关键字或其他线程同步机制（使用线程安全的数据结构）来确保线程安全。 4）使用 ThreadLocal 保存变量。 扩展知识解决方案详细分析无状态 Bean确保单例 Bean 是无状态的，即不包含可变的实例变量。如果所有的状态都是局部变量或方法内部的参数，这样的 Bean...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/18/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/37.Spring%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" title="37.Spring启动过程">37.Spring启动过程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-18T02:50:06.000Z" title="发表于 2025-11-18 10:50:06">2025-11-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">IOC加载、解析bean  加载配置文件，初始化容器：Spring 启动时首先会读取配置文件（如 XML 配置文件、Java Config 类等），包括配置数据库连接、事务管理、AOP 配置等。 实例化容器：Spring 根据配置文件中的信息创建容器 ApplicationContext，在容器启动阶段实例化 BeanFactory，并加载容器中的 BeanDefinitions。 解析 BeanDefinitions：Spring 容器会解析配置文件中的 BeanDefinitions，即声明的 Bean 元数据，包括 Bean 的作用域、依赖关系等信息。  bean的加载  实例化 Bean：Spring 根据 BeanDefinitions 实例化 Bean 对象，将其放入容器管理。  注入依赖：Spring 进行依赖注入，将 Bean 之间的依赖关系进行注入，包括构造函数注入、属性注入等。  处理 Bean 生命周期初始化方法：  Spring 调用 Bean 初始化方法（如果有定义的话），对 Bean 进行初始化。  如果 Bean 实现了...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/18/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/36.Spring%E4%BA%8B%E5%8A%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88/" title="36.Spring事务什么时候会失效">36.Spring事务什么时候会失效</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-18T02:48:06.000Z" title="发表于 2025-11-18 10:48:06">2025-11-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">一般而言失效的情况都是用了声明式事务即 @Transactional 注解，如果使用了这个注解那么在以下几个情况下会导致事务失效：   异常抛出错误，导致无法回滚   @Transactional(rollbackFor = xx)中rollbackFor定义的Exception（默认没有）没有捕获到方法执行的异常（如IOException） 虽然catch到了异常，但是只打了log，没有throw出去，导致事务无法抓取到错误   2.动态代理失效  同类的方法调用，不会走代理方法，事务失效 @Transactional 修饰非 public 修饰的方法上（事务管理器判断非公共方法是不应用事务的） @Transactional 应用在 final 和 static 方法上，AOP在SpringBoot2.x默认是cglib代理，无法对final方法子类化，静态方法属于类，无法被实例化，也就无法代理      3.事务上下文不一致  propagation 传播机制配置错误，例如以下的代码（忽略同一个类中的方法调用影响代理的情况）配置...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/18/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/34.@Bean%E5%92%8C@Component%E5%8C%BA%E5%88%AB/" title="34.@Bean和@Component区别">34.@Bean和@Component区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-18T02:39:46.000Z" title="发表于 2025-11-18 10:39:46">2025-11-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">@Bean 和 @Component都是定义bean的注解，但它们的使用场景和方式有所不同：  @Bean 注解通常用于 Java 配置类的方法上，以声明一个 Bean 并将其添加到 Spring 容器中，用于显示声明。 @Component 注解用于类级别，将该类标记为 Spring 容器中的一个组件，自动检测并注册为 Bean（需要扫对应的包），用于自动扫描和注入。     特性 @Bean @Component    使用位置 方法级别（在 @Configuration 类中） 类级别   扫描机制 不支持自动扫描，需手动注册 支持自动扫描，通过 @ComponentScan 自动发现   主要用途 用于配置第三方库或复杂对象 用于自动发现并注册自定义类   常见场景 手动配置复杂对象、第三方库类 自定义服务、DAO 层、控制器等类的自动注册   灵活性 更灵活，适合复杂初始化 自动化更强，适合类的简单注册   扩展知识@Bean 的使用场景@Bean 注解用于显式声明 Spring 容器管理的...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/18/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/33.@Qualifer/" title="33.@Qualifer">33.@Qualifer</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-18T02:39:09.000Z" title="发表于 2025-11-18 10:39:09">2025-11-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">@Qualifier 用于依赖注入时消除歧义。 当一个类型存在多个实现，@Qualifier 注解可以指定需要注入哪一个具体的 Bean。 举例：当 Service 有多个实现类的时候，可以通过 @Qualifier 指定名称选择对应的实现 Bean @Componentpublic class Client &#123;    private final Service service;    @Autowired    public Client(@Qualifier(&quot;serviceImpl1&quot;) Service service) &#123;        this.service = service;    &#125;    public void doSomething() &#123;        service.serve();    &#125;&#125;  扩展知识扩展 @Primary@Primary 注解用于指定当有多个候选 Bean 时默认注入哪个 Bean，也就是指定了第一顺位。 当结合 @Qualifier...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/18/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/30.IOC%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/" title="30.IOC容器初始化过程">30.IOC容器初始化过程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-18T02:38:10.000Z" title="发表于 2025-11-18 10:38:10">2025-11-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">首先说明大的四个过程：启动、Bean 定义注册、实例化和依赖注入、初始化，接下来停下来看面试官反应如果要继续的话，再细化讲解每个阶段的细节。 第一个大阶段：IOC容器启动和bean注册：  加载配置：从XML &#x2F; Java配置类 &#x2F; 注解配置加载（AnnotatedBeanDefinitionReader ）  创建容器：创建IOC容器（BeanFactory、ApplicationContext），准备进行加载 &#x2F; 管理bean  ClassPathXmlApplicationContext、AnnotationConfigApplicationContext的refresh方法启动   解析 + 注册bean：BeanDefinitionReader读取解析配置的Bean定义，注册到容器中，形成BeanDefinition对象   第二个大阶段：bean的加载过程  实例化：根据 BeanDefinition 创建 Bean 的实例。  InstantiationStrategy 接口是实例化，实现包括cglib（...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/18/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/40.@Value%E6%B3%A8%E8%A7%A3%E4%BD%9C%E7%94%A8/" title="40.@Value注解作用">40.@Value注解作用</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-18T02:29:14.000Z" title="发表于 2025-11-18 10:29:14">2025-11-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">在 Spring 框架中，@Value 注解用于注入外部化的配置值到 Spring 管理的 Bean 中。通过 @Value 注解，可以将属性文件、环境变量、系统属性等外部资源中的值注入到 Spring Bean 的字段、方法参数或构造函数参数中。 扩展知识使用场景1）配置文件注入：将属性文件中的值注入到 Bean 中。 2）系统属性和环境变量：将系统属性或环境变量的值注入到 Bean 中。 3）默认值设置：在属性不可用时，提供默认值。 举例说明Properties 文件 app.name=MyAppapp.version=1.0.0  @Value 注解注入属性 import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class AppConfig &#123;    @Value(&quot;$&#123;app.name&#125;&quot;)    private String...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/18/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/35.@Component_Controller_Repository_Service%E5%8C%BA%E5%88%AB/" title="35.@Component_Controller_Repository_Service区别">35.@Component_Controller_Repository_Service区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-18T02:28:26.000Z" title="发表于 2025-11-18 10:28:26">2025-11-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">它们本质上都是@Component，即其它三个都是 @Component 的衍生注解，之所以做了这些划分主要是为了更好地组织和管理应用的各个层次，提高代码的可读性和可维护性。 1）@Component：这是一个通用的注解，用于将任意类注册为 Spring 容器中的 Bean。它没有特定的语义，适用于任何需要 Spring 管理的类。 2）@Controller：这是一个专门用于 Spring MVC 中的控制器（Controller）层的注解。用于处理 HTTP 请求，并将结果返回给客户端。 3）@Service：用于标识业务逻辑层的类。它具有明确的语义，表明该类承担业务操作，主要用于编写服务类。 4）@Repository：用于数据访问层（DAO）的类，与数据库交互。 区别总结：  @Component：通用注解，用于将任何类标记为 Spring Bean。 @Controller：特定于 Spring MVC，处理 Web...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/17/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/25.%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/" title="25.有哪些事务传播行为">25.有哪些事务传播行为</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-17T14:28:58.000Z" title="发表于 2025-11-17 22:28:58">2025-11-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">从源码来看，一共有 7 种事务传播行为： 	 融入事务的策略。融入策略不同：  PROPAGATION_REQUIRED（默认 没有事务新建事务） 如果当前存在事务，则用当前事务 如果没有事务则新起一个事务   PROPAGATION_SUPPORTS 支持当前事务（但没有事务以非事务） 如果不存在，则以非事务方式执行   PROPAGATION_MANDATORY 支持当前事务（没有事务直接抛异常） 如果不存在，则抛出异常    挂起事务策略  PROPAGATION_REQUIRES_NEW创建一个新事务（挂起当前事务，调用的方法新建事务） 如果存在当前事务，则挂起当前事务 不存在，则同REQUIRES，新建    嵌套事务策略  PROPAGATION_NESTED （内部依赖外部事务，但内部失败不影响外层） 如果当前事务存在，则在嵌套事务中执行，内层事务依赖外层事务，如果外层失败，则会回滚内层，内层失败不影响外层。    事务禁止  PROPAGATION_NOT_SUPPORTED...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/17/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/32.Spring%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E6%96%B9%E5%BC%8F/" title="32.Spring自动装配的方式">32.Spring自动装配的方式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-17T13:58:15.000Z" title="发表于 2025-11-17 21:58:15">2025-11-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">自动装配指的是 Spring 可以根据一些特定的规则比如注解或者配置，自动在各个组件之间建立关联，完成依赖注入。主要有以下四类： 1）no（默认）：不自动装配，需要显式地定义依赖。  2）byName：通过 Bean 名称进行自动装配。  对应注解：@AutoWired + @Qualifer(&quot;userServiceImpl&quot;)  &#x2F; @Resource   3）byType：通过 Bean 类型进行自动装配。  对应注解：@AutoWired   4）constructor：通过构造函数进行自动装配。 扩展知识示例官网显示有以下四种：  1）no 自动装配 默认方式，不进行自动装配。依赖关系必须显式定义，适用于需要完全控制依赖注入过程的情况。 &lt;bean id=&quot;myBean&quot; class=&quot;com.example.MyBean&quot;&gt;    &lt;property name=&quot;myDependency&quot;...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/17/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/31.Bean%E6%B3%A8%E5%86%8C%E5%88%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E5%BC%8F/" title="31.Bean注册到容器的方式">31.Bean注册到容器的方式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-17T13:54:14.000Z" title="发表于 2025-11-17 21:54:14">2025-11-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">Spring Bean 注册到容器的方式主要包括以下几种： 1）基于 XML 的配置 使用 XML 文件配置 Bean，并定义 Bean 的依赖关系。 2）基于 @Component 注解及其衍生注解 使用注解如 @Component、@Service 、@Controller、@Repository 等进行配置。 3）基于 @Configuration 和 @Bean 注解 使用 @Configuration 注解声明配置类，并使用 @Bean 注解定义 Bean。 4）基于 @Import 注解 @Import 可以将普通类导入到 Spring 容器中，这些类会自动被注册为 Bean。 扩展知识简单代码示例1）XML配置方式 &lt;beans 省略....&gt;    &lt;bean id=&quot;myService&quot; class=&quot;com.example.MyService&quot;/&gt;&lt;/beans&gt;  2）基于 @Component 注解及其衍生注解 通过 @Component 注解将类声明为 Spring 管理的...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/17/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/29.%E9%80%9A%E7%9F%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B/" title="29.通知有哪些类型">29.通知有哪些类型</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-17T13:49:49.000Z" title="发表于 2025-11-17 21:49:49">2025-11-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">1）前置通知（Before advice）：在目标方法执行之前执行的通知。它不会影响目标方法的执行流程，但可以在方法执行前执行一些逻辑，例如验证参数。 2）后置通知（After returning advice）：在目标方法成功执行并返回结果后执行的通知。它可以访问目标方法的返回值，但无法修改返回值。可以用于记录日志或清理资源等操作。 3）后置异常通知（After throwing advice）：在目标方法抛出异常后执行的通知。它可以访问目标方法抛出的异常，并且可以根据异常类型进行相应的处理，例如记录异常信息或执行异常处理逻辑。 4）后置最终通知（After (finally) advice）：无论目标方法如何结束（正常返回或抛出异常），都会执行的通知。它类似于Java中的finally块，在方法结束时执行一些清理工作，例如释放资源或关闭连接。 5）环绕通知（Around...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/17/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/28.AOP%E7%9A%84%E6%9C%AF%E8%AF%AD/" title="28.AOP的术语">28.AOP的术语</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-17T13:36:38.000Z" title="发表于 2025-11-17 21:36:38">2025-11-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">1）切面（Aspect）：其实就是定义了一个 java 类，里面包含了通知（advice）和切点（pointcut），定义了在何处以及何时执行通知，将切面的一些东西模块化了，即定义横切关注点的模块，封装了不同模块共享的功能。 2）通知（Advice）：切面中的实际逻辑，即在连接点上执行的操作。通知可以在方法执行前、执行后或抛出异常时运行。  前置通知（Before advice）：在目标方法执行前执行。 后置通知（After returning advice）：在目标方法成功执行后执行。 后置异常通知（After throwing advice）：在目标方法抛出异常后执行。 后置最终通知（After (finally) advice）：无论目标方法如何结束（正常返回或抛出异常），都会执行。 环绕通知（Around...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/17/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/27.Spring%E7%9A%84%E4%BC%98%E7%82%B9/" title="27.Spring的优点">27.Spring的优点</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-17T13:36:29.000Z" title="发表于 2025-11-17 21:36:29">2025-11-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">主要有以下几点（答到 ioc、aop、生态和社区就差不多了）： 1）轻量级和非侵入性，不需要引入大量的依赖和配置。 2）面向切面编程（AOP），Spring 提供了强大的面向切面编程的支持，允许用户定义横切关注点，并将其与核心业务逻辑分离，提高了灵活性。 3）依赖注入（DI）和控制反转（IoC）容器，Spring 的核心是 IoC 容器，它实现了依赖注入模式，通过配置文件或注解来管理对象之间的依赖关系,降低了耦合度，提高了代码的可维护性和可测试性。 4）拥有大量的生态，几乎集成市面所有 Java 技术栈的一切框架和类库。 5）Spring 拥有非常活跃的社区，官方文档丰富，网上大把教学资源，遇到问题比较容易找到对应的解决方案。 </div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/17/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/26.%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E7%9A%84%E4%BD%9C%E7%94%A8/" title="26.事务传播行为的作用">26.事务传播行为的作用</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-17T13:36:07.000Z" title="发表于 2025-11-17 21:36:07">2025-11-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">作用：定义和管理事务边界，特别是对于一个事务方法调用另外一个事务方法时如何进行传播事务的问题。他说明了多个事务嵌套执行时，是否需要开启新事物、复用现有事务、还是挂起事务等情况 总结用途 控制事务的传播和嵌套：根据具体业务需求，可以指定是否使用现有事务或开启新的事务，解决事务的传播问题。 举例：REQUIERD对比SUPPORTED，REQUIRES_NEW等策略，是需要融入，还是需要挂起，没有事务的时候是新建，还是以非事务方式运行，甚至是报错的严格控制MANDATORY   确保独立操作的事务隔离：某些操作（如日志记录、发送通知）应当独立于主事务执行，即使主事务失败，这些操作也可以成功完成。 举例：PROPAGATION_NOT_SUPPORTED...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/17/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/24.%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/" title="24.事务的隔离级别">24.事务的隔离级别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-17T13:24:31.000Z" title="发表于 2025-11-17 21:24:31">2025-11-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">Spring 提供了五种事务隔离级别：  DEFAULT（默认）：使用底层数据库的默认隔离级别。如果数据库没有特定的设置，通常默认为 READ_COMMITTED。 READ_UNCOMMITTED（读未提交）：最低的隔离级别，允许事务读取尚未提交的数据，可能会导致脏读、不可重复读和幻读。 READ_COMMITTED（读已提交）：仅允许读取已经提交的数据，避免了脏读，但可能会出现不可重复读和幻读问题。 REPEATABLE_READ（可重复读）：确保在同一个事务内的多次读取结果一致，避免脏读和不可重复读，但可能会有幻读问题。 SERIALIZABLE（可串行化）：最高的隔离级别，通过强制事务按顺序执行，完全避免脏读、不可重复读和幻读，代价是性能显著下降。  	 扩展知识隔离级别与脏读、不可重复读、幻读表格汇总   隔离级别 脏读 不可重复读 幻读    READ_UNCOMMITTED 是 是 是   READ_COMMITTED 否 是 是   REPEATABLE_READ 否 否 是   SERIALIZABLE 否 否 否    脏读（Dirty...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/17/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/23.Spring%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="23.Spring用到了哪些设计模式">23.Spring用到了哪些设计模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-17T13:23:37.000Z" title="发表于 2025-11-17 21:23:37">2025-11-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">1、工厂模式（Factory Pattern）： IOC容器本身是一个工厂，实现了封装bean的创建过程，以及延迟创建bean（后两种）  在 Spring 中，ApplicationContext 与 BeanFactory 的 getBean 方法可以视为工厂方法，它隐藏了 Bean 的创建过程和具体实现。 org.springframework.beans.factory.FactoryBean @Bean 注解的静态方法及实例方法 ObjectFactory 和 ObjectProvider  2、单例模式（Singleton Pattern）： Bean默认是单例的，但是和设计模式的单例略有不同，只能保证容器中相同ID是单例的 3、代理模式（Proxy Pattern）： Spring AOP（面向切面编程）模块利用了JDK动态代理或者CGLIB字节码生成技术来创建目标对象的代理。代理对象封装了目标对象的行为，并且可以在目标方法执行前后添加额外的功能。 4、模板模式（Template Pattern）：...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/17/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/22.MVC%E7%9A%84%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8/" title="22.MVC的父子容器">22.MVC的父子容器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-17T13:16:46.000Z" title="发表于 2025-11-17 21:16:46">2025-11-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">父容器：父容器是Spring的跟容器，由 Spring 应用上下文（ApplicationContext）加载，具体的实现包括ContextLoaderListener ContextLoaderServlet 等，主要是管理应用全局Bean，服务层Service、数据访问层DAO等。 子容器：是说Web容器，对应每个 DispatcherServlet 实例都会创建一个子容器，用于管理 Web 层（如控制器和拦截器）中的 Bean。 父子容器的关系：  子容器可以访问父容器的 Bean：如果一个 Bean 在父容器中定义，子容器也可以直接访问它。这种机制有助于 Web 层（子容器）使用服务层或 DAO 层（父容器）中的 Bean。 父容器不能访问子容器的 Bean：父容器无法访问子容器中的 Bean，这是 Spring MVC 的设计之一。父容器中的 Bean 和子容器中的 Bean 被分开管理，避免了不必要的耦合。  	 这样的好处就是：将web层与服务层分离出来，能分离业务逻辑、避免Bean重复定义、并且管理分模块。 扩展知识Spring 父子容器的初始化过程在...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/17/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/21.MVC%E5%8E%9F%E7%90%86/" title="21.MVC原理">21.MVC原理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-17T13:13:06.000Z" title="发表于 2025-11-17 21:13:06">2025-11-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="content">1）客户端请求：客户端发送HTTP请求，所有请求被DispatcherServlet接收  2）请求映射：DispatcherServlet根据配置的处理器映射器HandlerMapping查找请求URL对应的控制器Controller  3）调用控制器方法：找到控制器后，DispatcherServlet将请求转发给对应的控制器方法处理，控制器方法处理完业务逻辑后，通常返回ModelAndView，包含数据模型和视图名称  4）视图解析：DispatcherServlet 根据控制器返回的视图名称，使用视图解析器（ViewResolver）将逻辑视图名称解析为实际的视图（如 JSP、Thymeleaf 等）。  5）视图渲染返回：视图渲染引擎根据数据模型渲染视图，并将生成的 HTML 响应返回给客户端  Spring MVC 还支持返回 JSON 数据响应，用于构建 RESTful Web 服务，因此上述视图解析部分， 如果是 JSON 响应，则 Spring MVC 会将对象序列化为...</div></div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/3/#content-inner"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/#content-inner">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/#content-inner">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/#content-inner">32</a><a class="extend next" rel="next" href="/page/5/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yuezi</div><div class="author-info-description">积微者速成</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">785</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">91</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuezi2048"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">积微者速成</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/22/Excalidraw/Drawing%202024-11-01%2015.37.37.excalidraw/" title="Drawing 2024-11-01 15.37.37.excalidraw">Drawing 2024-11-01 15.37.37.excalidraw</a><time datetime="2026-02-22T05:56:41.839Z" title="发表于 2026-02-22 13:56:41">2026-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/22/2.Areas%F0%9F%8C%90/01.project/condefather/yupao/back-end/7.%E4%BC%98%E5%8C%96%E4%B8%BB%E9%A1%B5%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/" title="7.优化主页性能-优化批量导入数据">7.优化主页性能-优化批量导入数据</a><time datetime="2026-02-22T05:56:41.257Z" title="发表于 2026-02-22 13:56:41">2026-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/31/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/5.%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8/" title="5.工具调用">5.工具调用</a><time datetime="2026-01-31T03:54:22.000Z" title="发表于 2026-01-31 11:54:22">2026-01-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/30/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/4.RAG%E8%BF%9B%E9%98%B6/" title="4.RAG进阶">4.RAG进阶</a><time datetime="2026-01-30T13:23:42.000Z" title="发表于 2026-01-30 21:23:42">2026-01-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/3.RAG/" title="3.RAG">3.RAG</a><time datetime="2026-01-27T09:06:56.000Z" title="发表于 2026-01-27 17:06:56">2026-01-27</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
      <i class="fas fa-angle-right"></i></a>
          </div>
          <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/0-InBox%F0%9F%90%AD/"><span class="card-category-list-name">0.InBox🐭</span><span class="card-category-list-count">2</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/0-InBox%F0%9F%90%AD/md/"><span class="card-category-list-name">md</span><span class="card-category-list-count">2</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/"><span class="card-category-list-name">2.Areas🌐</span><span class="card-category-list-count">766</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/00-%E7%A7%8B%E6%8B%9B%E5%87%86%E5%A4%87%E6%96%B9%E5%90%91/"><span class="card-category-list-name">00.秋招准备方向</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/"><span class="card-category-list-name">01.project</span><span class="card-category-list-count">25</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/"><span class="card-category-list-name">condefather</span><span class="card-category-list-count">25</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/tuku/"><span class="card-category-list-name">tuku</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/user-center/"><span class="card-category-list-name">user-center</span><span class="card-category-list-count">9</span></a></li></ul></li></ul></li></ul></li>
          </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/3-JDBC/" style="font-size: 1.15em; color: #999b9e">3.JDBC</a> <a href="/tags/Github/" style="font-size: 1.13em; color: #999a9b">Github</a> <a href="/tags/front-end/" style="font-size: 1.1em; color: #999">front-end</a> <a href="/tags/%E8%AE%BA%E6%96%87%E6%A2%B3%E7%90%86/" style="font-size: 1.4em; color: #99a5b6">论文梳理</a> <a href="/tags/condefather/" style="font-size: 1.1em; color: #999">condefather</a> <a href="/tags/5-Maven%E4%B8%93%E9%A2%98/" style="font-size: 1.13em; color: #999a9b">5.Maven专题</a> <a href="/tags/7-SpringBoot/" style="font-size: 1.23em; color: #999ea5">7.SpringBoot</a> <a href="/tags/01/" style="font-size: 1.18em; color: #999ca0">01</a> <a href="/tags/%E5%B0%8F%E8%AE%BA%E6%96%87%E5%87%86%E5%A4%87/" style="font-size: 1.28em; color: #99a0aa">小论文准备</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/" style="font-size: 1.1em; color: #999">代码实现</a> <a href="/tags/Transformer%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" style="font-size: 1.32em; color: #99a2ae">Transformer前世今生</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 1.48em; color: #99a8bd">Java基础</a> <a href="/tags/md/" style="font-size: 1.13em; color: #999a9b">md</a> <a href="/tags/JUC/" style="font-size: 1.45em; color: #99a7ba">JUC</a> <a href="/tags/Spring/" style="font-size: 1.5em; color: #99a9bf">Spring</a> <a href="/tags/JVM/" style="font-size: 1.43em; color: #99a6b8">JVM</a> <a href="/tags/%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86/" style="font-size: 1.1em; color: #999">论文整理</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/" style="font-size: 1.38em; color: #99a4b3">基础篇——韩顺平</a> <a href="/tags/%E6%80%BB%E4%BD%93%E8%A7%84%E5%88%92/" style="font-size: 1.13em; color: #999a9b">总体规划</a> <a href="/tags/vue/" style="font-size: 1.13em; color: #999a9b">vue</a> <a href="/tags/%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0%E6%80%BB%E7%BB%93/" style="font-size: 1.13em; color: #999a9b">论文复现总结</a> <a href="/tags/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/" style="font-size: 1.18em; color: #999ca0">基本方法</a> <a href="/tags/SpringMVC/" style="font-size: 1.28em; color: #99a0aa">SpringMVC</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%AF%87/" style="font-size: 1.3em; color: #99a1ac">基础篇</a> <a href="/tags/back-end/" style="font-size: 1.35em; color: #99a3b1">back-end</a> <a href="/tags/%E8%AE%BA%E6%96%87/" style="font-size: 1.13em; color: #999a9b">论文</a> <a href="/tags/Excalidraw/" style="font-size: 1.1em; color: #999">Excalidraw</a> <a href="/tags/1-%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" style="font-size: 1.25em; color: #999fa7">1.监督学习</a> <a href="/tags/%E6%A8%A1%E5%9E%8B%E6%95%B4%E7%90%86/" style="font-size: 1.1em; color: #999">模型整理</a> <a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/" style="font-size: 1.23em; color: #999ea5">云服务器运行环境</a> <a href="/tags/docker/" style="font-size: 1.1em; color: #999">docker</a> <a href="/tags/%E5%AE%9E%E9%AA%8C/" style="font-size: 1.1em; color: #999">实验</a> <a href="/tags/pytorch%E5%9F%BA%E6%9C%AC%E5%8A%9F/" style="font-size: 1.15em; color: #999b9e">pytorch基本功</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" style="font-size: 1.3em; color: #99a1ac">代码随想录</a> <a href="/tags/communication/" style="font-size: 1.1em; color: #999">communication</a> <a href="/tags/Mybatis/" style="font-size: 1.18em; color: #999ca0">Mybatis</a> <a href="/tags/%E5%B0%8F%E8%AE%BA%E6%96%87%E6%95%85%E4%BA%8B%E7%BA%BF%E5%92%8C%E6%A8%A1%E5%9D%97%E8%AE%B0%E5%BD%95%E7%B4%A0%E6%9D%90/" style="font-size: 1.2em; color: #999da3">小论文故事线和模块记录素材</a> <a href="/tags/%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/" style="font-size: 1.1em; color: #999">基本问题</a> <a href="/tags/SSM%E6%95%B4%E5%90%88/" style="font-size: 1.1em; color: #999">SSM整合</a> <a href="/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/" style="font-size: 1.13em; color: #999a9b">算法基础课</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>归档</span>
      <a class="card-more-btn" href="/archives/"
            title="查看更多">
            <i class="fas fa-angle-right"></i>
          </a>
    </div>
  
    <ul class="card-archive-list">
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2026/02/">
            <span class="card-archive-list-date">
              二月 2026
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2026/01/">
            <span class="card-archive-list-date">
              一月 2026
            </span>
            <span class="card-archive-list-count">5</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/11/">
            <span class="card-archive-list-date">
              十一月 2025
            </span>
            <span class="card-archive-list-count">177</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/10/">
            <span class="card-archive-list-date">
              十月 2025
            </span>
            <span class="card-archive-list-count">199</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/09/">
            <span class="card-archive-list-date">
              九月 2025
            </span>
            <span class="card-archive-list-count">98</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/08/">
            <span class="card-archive-list-date">
              八月 2025
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/07/">
            <span class="card-archive-list-date">
              七月 2025
            </span>
            <span class="card-archive-list-count">39</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/06/">
            <span class="card-archive-list-date">
              六月 2025
            </span>
            <span class="card-archive-list-count">24</span>
          </a>
        </li>
      
    </ul>
  </div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">785</div></div><div class="webinfo-item"><div class="item-name">运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2025-04-05T00:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">1222.8k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总浏览量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2026-02-22T05:57:08.605Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/backgroud.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2026 By yuezi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>window.typedJSFn = {
  init: str => {
    window.typed = new Typed('#subtitle', Object.assign({
      strings: str,
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50,
    }, null))
  },
  run: subtitleType => {
    if (true) {
      if (typeof Typed === 'function') {
        subtitleType()
      } else {
        btf.getScript('https://cdn.jsdelivr.net/npm/typed.js/dist/typed.umd.min.js').then(subtitleType)
      }
    } else {
      subtitleType()
    }
  },
  processSubtitle: (content, extraContents = []) => {
    if (true) {
      const sub = [].slice()

      if (extraContents.length > 0) {
        sub.unshift(...extraContents)
      }

      if (typeof content === 'string') {
        sub.unshift(content)
      } else if (Array.isArray(content)) {
        sub.unshift(...content)
      }

      sub.length > 0 && typedJSFn.init(sub)
    } else {
      document.getElementById('subtitle').textContent = typeof content === 'string' ? content :
        (Array.isArray(content) && content.length > 0 ? content[0] : '')
    }
  }
}
btf.addGlobalFn('pjaxSendOnce', () => { typed.destroy() }, 'typedDestroy')
</script><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      const from = '出自 ' + data.from
      typedJSFn.processSubtitle(data.hitokoto, [from])
    })
    .catch(err => {
      console.error('Failed to get the Hitokoto API:', err)
      typedJSFn.processSubtitle([])
    })
}
typedJSFn.run(subtitleType)
</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>