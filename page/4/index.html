<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>yuezi</title><meta name="author" content="yuezi"><meta name="copyright" content="yuezi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="积微者速成">
<meta property="og:type" content="website">
<meta property="og:title" content="yuezi">
<meta property="og:url" content="https://yuezi2048.github.io/page/4/index.html">
<meta property="og:site_name" content="yuezi">
<meta property="og:description" content="积微者速成">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuezi2048.github.io/img/touxiang.jpg">
<meta property="article:author" content="yuezi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuezi2048.github.io/img/touxiang.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuezi2048.github.io/page/4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?bfb48b678d82bea9f9cc9d59227767e4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"FPH6F2TOJL","apiKey":"06d9ea26c803ba912b4d8e13404ed34d","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'yuezi',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'home'
}</script><link rel="stylesheet" href="/css/backgound.css"><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">603</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url(/img/backgroud.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yuezi</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="site-info"><h1 id="site-title">yuezi</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts nc" id="recent-posts"><div class="recent-post-items"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/38.%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%B8%B8%E8%A7%81%E6%8B%93%E6%89%91/" title="38.主从复制常见拓扑">38.主从复制常见拓扑</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:32:01.000Z" title="发表于 2025-10-27 18:32:01">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">Redis 主从的几种常见拓扑结构如下（忽略哨兵）：  主从（主写从读），一主多从（减少主节点复制到从节点压力），多主多从（默认不支持，多读多写分散压力）  1）一主多从： 这是最基本的拓扑结构，包含一个主节点和多个从节点。所有写操作都在主节点上执行，而读操作可以在从节点上进行，以提高读取速度和负载均衡。 	 2）树状主从结构（级联）： 从节点也可以作为其他从节点的主节点。这样形成了一个层次结构，主节点负责写操作，而从节点负责读操作，并将数据再次复制到更下一级的从节点。 	 因为主从复制对主节点有压力，所以这样的结构可以减轻主节点的压力。 3）主主结构（双主或多主）： 在这种拓扑中，有两个或多个主节点，它们之间相互复制数据。这种结构提高了系统的写能力和容错性。 	 但需要处理多主节点之间的数据同步和冲突解决，管理复杂度高，Redis 默认不支持主主复制。 扩展知识 651. Redis 主从复制的实现原理是什么？ 650. Redis 的哨兵机制是什么？ 652. Redis 集群的实现原理是什么？  </div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/37.%E5%8E%9F%E7%94%9F%E6%89%B9%E5%A4%84%E7%90%86MSETMGET%E5%AF%B9%E6%AF%94PipLine/" title="37.原生批处理MSETMGET对比PipLine">37.原生批处理MSETMGET对比PipLine</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:31:23.000Z" title="发表于 2025-10-27 18:31:23">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">原生批处理命令（MSET、MGET） 和 Pipeline都是一次处理多个命令，但是在实现和应用场景上不同：  实现 MSET&#x2F;MGET是批量设置和获取 多个kv，是作为单个命令执行的，网络传输是一次RTT PipeLine是允许用户一次性发送多个命令，Redis批量处理命令，将结果依次返回，不是单一的Redis命令，不满足原子性   场景 MSET&#x2F;MGET是多个kv的原子性读写操作 PipeLine是客户端的机制，用于任意类型的Redis操作    扩展知识性能对比 在执行批量操作时，MSET &#x2F; MGET 的执行速度可能比 Pipeline 更快，因为它们是原生支持的批处理命令，并且对于特定任务（批量读写键值）进行了优化。 Pipeline 的优势在于减少客户端和 Redis 之间的网络延迟，在需要执行多种操作（不仅仅是 MSET &#x2F; MGET）时，Pipeline 可以提供更高的灵活性和更好的吞吐量。  使用示例MSET &#x2F; MGET： MSET key1 value1 key2 value2 key3...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/36.EMBSTR%E5%AF%B9%E8%B1%A1%E9%98%88%E5%80%BC%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF44%EF%BC%88%E5%8E%86%E5%8F%B2%E8%B0%83%E6%95%B4%EF%BC%89/" title="36.EMBSTR对象阈值为什么是44（历史调整）">36.EMBSTR对象阈值为什么是44（历史调整）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:27:13.000Z" title="发表于 2025-10-27 18:27:13">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content"> Redis的内存是通过jemalloc进行内存分配，以64字节位阈值来区分字符串raw和EMBSTR RedisObject占用16字节，sdshdr占用4字节（len alloc flags  \0），最终剩余44字节   历史调整：3.2调整了sdshdr的结构，之前的sdshdr5版本是39个字节，之后的版本EMBSTR使用的是sdshdr8的结构，总容量和已使用容量字段少了6个字节，但增加了一个flag字节，所以最后是少了5个字节  为什么 EMBSTR 的阈值大小是 44 个字节？1）Redis 使用的是jemalloc作为内存分配器。 2）jemalloc 是以 64 字节作为内存单位进行内存分配的，如果超过了 64 字节，即超过了一个内存单元，使用的就是 raw 编码，反之使用的就是 EMBSTR 编码。 3）核心就是这个 64 字节，围绕 64 字节这个关键点来分析。Redis 的字符串对象是 redisObject 和 sdshdr 这两个部分组成的，redisObject 大小为 4 + 4 + 24 + 32 + 64 = 128bits = 16...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/35.%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96/" title="35.性能瓶颈怎么优化">35.性能瓶颈怎么优化</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:20:56.000Z" title="发表于 2025-10-27 18:20:56">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content"> 内存扩容：增加Redis配置，容纳更多的内存 如果单机配置不够，可以上Redis主从，从服务分担读数据压力，哨兵进行故障转移   集群：通过Reids Cluster进行数据分片 多级缓存  扩展知识redis 主从复制和读写分离通过配置 Redis 主从复制，可以实现读写分离，将写操作交给主节点进行处理，而读操作可以交给从节点，从而减轻主节点的压力。 主从架构的优势在于可以横向扩展读取能力，但是存在主从同步延迟的问题，如果从节点落后较多，可能会出现读取旧数据的情况。  651. Redis 主从复制的实现原理是什么？ 650. Redis 的哨兵机制是什么？  redis 集群 652. Redis 集群的实现原理是什么？  </div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/34.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%9C%80%E5%A4%A7%E5%80%BC/" title="34.字符串类型最大值">34.字符串类型最大值</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:18:44.000Z" title="发表于 2025-10-27 18:18:44">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">512MB 	 无论是网络传输、内存分配还是字符串操作，大字符串都会增加 Redis 服务器的负载。 且过大的字符串在 GET、SET、APPEND、STRLEN 等操作都会导致性能瓶颈。 所以官方给字符串的大小做了限制，防止单个键值对占用过多的内存，影响整体性能和稳定性。  注：不建议存储大于2MB的在字符串,因为大于2MB的字符串属于big Key   661. Redis String 类型的底层实现是什么？  </div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/33.%E9%A1%B9%E7%9B%AE%E7%9A%84Redis%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%94%A8%E4%BB%80%E4%B9%88/" title="33.项目的Redis客户端用什么">33.项目的Redis客户端用什么</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:14:02.000Z" title="发表于 2025-10-27 18:14:02">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">常见在项目中使用的客户端有以下三种：  Jedis ：简单的同步 &#x2F; 单线程 环境 Lettuce ：高性能 &#x2F; 高并发 &#x2F; 多线程，特别是异步 &#x2F; 响应式编程的场景 Redisson：复杂的分布式系统，提供丰富的分布式对象和服务，简化开发。  JedisJedis 是一款比较经典的 Java 客户端了，里面提供了比较全面的 Redis 命令，也是使用最为广泛的 Redis 客户端。 Jedis 是一个用 Java 实现的 Redis 客户端库，它具有以下优点：  简单易用：提供了直观的 API，使得开发者能够方便地与 Redis 进行交互。 使用广泛：在 Java 社区中被广泛采用，有丰富的文档和示例可供参考。 性能良好：在大多数情况下能够提供高效的 Redis 操作。 功能丰富：支持常见的 Redis 操作，如字符串、列表、哈希、集合等数据结构的操作。  然而，Jedis 也存在一些缺点：  线程安全问题：线程不安全，每个线程需独立使用 Jedis 实例。 不支持自动重连：在网络异常或 Redis...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/32.GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="32.GEO数据结构">32.GEO数据结构</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:10:08.000Z" title="发表于 2025-10-27 18:10:08">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content"> Geo（Geolocation 地理坐标）数据结构是地理位置信息的存储（GEOSEARCH），方便进行地理位置的存储、检索，同时可以计算地理距离等，底层使用Sorted Set，并结合GeoHash算法对地理位置进行处理  它是 Redis 2.2 版本后新增的数据类型  扩展知识Geo 常用命令GEOADD key longitude latitude member：  将地理坐标信息添加到 Redis 中。例如：GEOADD locations 13.361389 38.115556 “mianshiya”。  GEODIST key member1 member2 [unit]：  计算两个地理位置之间的距离，单位可以是 m（米）、km（公里）、mi（英里）等。例如：GEODIST locations “mianshiya” “mianshiya1” km。  GEORADIUS key longitude latitude radius unit：  查找指定位置附近指定范围内的所有点。例如：GEORADIUS locations 15 37 200 km...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/31.%E7%BB%9F%E8%AE%A1%E5%A4%A7%E9%87%8F%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E9%87%8FUV/" title="31.统计大量用户访问量UV">31.统计大量用户访问量UV</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:07:45.000Z" title="发表于 2025-10-27 18:07:45">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">通过HyperLogLog实现——网页UV&#x2F;PV场景，是基于基数估计算法的概率数据结构，用极少的内存统计海量用户唯一访问量的近似值。  注：Set也可以实现，且更精细，但当用户量访问大时，内存开销较大  扩展知识HyperLogLog 使用介绍HyperLogLog 具有极小的内存占用（每个 HyperLogLog 结构约 12 KB），而允许一定的误差（通常在 0.81% 以内）。即使统计数百万用户，内存开销依然是恒定的（约 12 KB），非常适合海量数据场景。 HyperLogLog 的基本操作：  PFADD key element [element ...]：将一个或多个元素添加到 HyperLogLog 数据结构中。 PFCOUNT key [key ...]：返回 HyperLogLog 结构中不重复元素的近似数量。 PFMERGE destkey sourcekey [sourcekey ...]：将多个 HyperLogLog 合并为一个。  以下是一个示例代码，展示在 Java 中如何使用 Redis 的 HyperLogLog 实现页面 UV...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/30.%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" title="30.快速实现布隆过滤器">30.快速实现布隆过滤器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:05:47.000Z" title="发表于 2025-10-27 18:05:47">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content"> 布隆过滤器是一种高效的概率数据结构，用于判断元素是否存在于一个集合中，可以减少数据库的查询次数，避免缓存穿透等问题  具体实现方式：  位图（Bitmap）  SETBIT &#x2F; GETBIT操作实现布隆过滤器，本质上是在比特数组上标识元素是否存在 给定数据，通过多个哈希函数计算索引，对应位图的位置设置为1，表示元素存在   RedisBloom  Redis官方提供的模块，封装了哈希函数、位图大小等操作，可以直接创建和管理布隆过滤器  具体通过BF.ADD向布隆过滤器添加元素，BF.EXISTS检查某个元素是否存在    扩展知识布隆过滤器原理布隆过滤器组成：位数组 + 多个哈希函数  添加位置：...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/29.%E5%AE%9E%E7%8E%B0%E6%8E%92%E8%A1%8C%E6%A6%9C/" title="29.实现排行榜">29.实现排行榜</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T09:53:05.000Z" title="发表于 2025-10-27 17:53:05">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">通过**Sorted Set（有序集合）**实现，进行存储、更新和获取排名信息  存储分数和成员：ZADD命令。ZADD leaderboard 1000 user1 获取排名：ZRANK命令，ZRAND leaderboard user1，返回user1的排名（从0开始） 获取TopN：ZREVRANGE得到分数最高的前N名，ZREVRANGE leaderboard 0 9 WITHSCORES，得到前10名的用户和分数 更新分数：ZINCRBY命令对分数加减，ZINCRBY leaderboard 500 user1，对user1的分数增加500  扩展知识Sorted Set 的特点 内部基于**跳表（Skip List）**实现，每个成员有唯一的score，按照分数进行排序 Sorted Set的插入、更新和删除时间复杂度是O(log N)，支持快速查询制定区间的数据 Sorted Set保证成员的唯一性，如果插入相同的成员，ZADD会更新分数而不是重复插入  Sorted Set 相关 Redis...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/23/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/28.String%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%88SDS%EF%BC%89/" title="28.String的底层实现">28.String的底层实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-23T14:58:56.000Z" title="发表于 2025-10-23 22:58:56">2025-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">Redis 的 String 类型底层是基于 SDS（Simple Dynamic String 简单动态字符串）结构，并结合 int、embstr、raw 等不同的编码方式进行优化存储。 扩展 相比于C语言标准字符串，SDS做的优化：simple dynamic（操作简单 + 动态扩展）  加入了自定义结构 + 长度 + 分配空间元信息，去除了C语言固有的\0结尾，并且长度不需要遍历得到 动态拓展内存，预留额外空间的预分配内存策略 C语言字符串操作函数不高效且不安全，比如缓冲区溢出，其可能导致程序异常终止   引入了 int、embstr、raw 更多自定义结构   名称入手，simple操作的结构 + dynamic内存 + 类型的优化     特性 SDS（Redis 动态字符串） C语言原生字符串    结构 自定义结构，包含长度、分配空间等元信息 以 \0 结尾的字符数组   长度记录 独立记录字符串长度，获取长度为 O(1) 通过遍历计算字符串长度，获取长度为 O(n)   二进制安全 支持任意二进制数据，包括 \0 不支持，遇到 \0...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/23/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/27.%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4/" title="27.如何保证缓存和数据库数据一致">27.如何保证缓存和数据库数据一致</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-23T14:45:57.000Z" title="发表于 2025-10-23 22:45:57">2025-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">方案（不推荐）：  更新缓存，再更新数据库 更新数据库，再更新缓存 先删除缓存，再更新数据库，后续查询数据库回种缓存  方案（根据实际业务选择）：  缓存双删策略：先删除缓存，更新数据库，再延迟删除缓存 先写数据库，再删除缓存，后续查询数据库回种缓存（允许一定时间的不一致，但保证最终一致性）   缓存更新策略上来说，称为Cache...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/23/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/26.%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF_%E7%A9%BF%E9%80%8F_%E9%9B%AA%E5%B4%A9/" title="26.缓存击穿_穿透_雪崩">26.缓存击穿_穿透_雪崩</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-23T14:06:33.000Z" title="发表于 2025-10-23 22:06:33">2025-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/23/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/25.%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98/" title="25.实现分布式锁要考虑的问题">25.实现分布式锁要考虑的问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-23T13:53:14.000Z" title="发表于 2025-10-23 21:53:14">2025-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">思考方向：死锁 &#x2F;  并发冲突——&gt;数据不一致   业务互斥操作（锁的互斥性） 锁到期释放，但业务未执行完：Ridisson 看门狗续约 误释放锁问题：lua【id判断+释放】 可重入性问题：线程ID计数器（避免死锁）   脑裂 网络分区问题：参数优化   单点故障 单点故障问题：主从 + 哨兵 主从问题不同步：红锁 时钟漂移问题：NTP同步       问题 描述 解决方案    锁到期问题 锁的超时时间到期，但业务尚未执行完成，导致锁提前释放，其他线程可能错误地获取锁，导致并发问题。 使用 Watchdog 机制动态续期锁，确保锁在持有者未主动释放时不会提前失效。避免手动设置过长的超时时间以防降低并发度。   单点故障问题 使用单节点 Redis 时，若 Redis 宕机或不可用，分布式锁将无法正常工作，影响业务的正常执行。 使用 Redis 哨兵模式或集群模式，提升 Redis 的高可用性；或使用 RedLock...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/23/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/24.Red_Lock/" title="24.Red_Lock">24.Red_Lock</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-23T13:40:42.000Z" title="发表于 2025-10-23 21:40:42">2025-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">红锁Red Lock是分布式锁的一种实现方案，用来解决分布式锁的安全问题。 我们一般在生产环境会使用主从+哨兵方式来部署 Redis 但是会存在问题：主从切换过程中，从节点不一定同步主节点的锁信息  此时新的主节点没有锁的信息，会允许另一个业务拿锁执行业务逻辑 那么就会导致两个业务同时操作临界资源，进而发生数据不一致的问题  Redis官方引出红锁来避免该情况发生，及时部分节点发送故障也不影响锁的使用和数据问题的发生。 拓展 要实现红锁，官方推荐至少要5个实例（不需要部署从库和哨兵，只需主库），这5个实例没有任何关系（区别于cluster），他们之间没有任何信息交互。 客户端会依次对5个实例加锁，如果申请成功数量超过一半（&gt;&#x3D;3），那么申请成功，否则失败。  此时如果一台实例宕机了，不会有任何影响，因为理论上能申请成功的数量有4个，超过了半数。 也因为没有主从机制，不会有同步丢失锁的问题。  具体加锁流程如下：  客户端获取当前时间...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/23/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/23.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%9C%A8%E6%9C%AA%E5%AE%8C%E6%88%90%E5%89%8D%E5%B0%B1%E8%BF%87%E6%9C%9F%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/" title="23.分布式锁在未完成前就过期了怎么办">23.分布式锁在未完成前就过期了怎么办</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-23T12:57:34.000Z" title="发表于 2025-10-23 20:57:34">2025-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">未完成就过期，会导致数据不一致。此时另一个客户端会争抢到锁，这样会导致两个客户端同时业务操作，相当于锁失效。 解决方案：定时续期锁（如看门狗机制），保证在处理过程中锁不能过期 	    拓展 看门狗可以实现定时续期的功能：  抢到锁后，后台会新建定时的锁续期任务 锁过期时间是30s，那么10s（1&#x2F;3）后会重新设定为30s   当任务执行完后，移除定时任务   在鱼泡项目的debug过程中，看门狗也不会生效  	    redissonredisson 封装了很多 redis 操作，便于我们使用。  redisson分布式锁引入了看门狗机制，具体原理也是基于 Netty 的时间轮实现的定时任务，。 redisson 支持可重入锁，即同一个线程可以多次获取同一个分布式锁，且不会导致死锁。实现方法如下： 获取锁时，检查当前锁唯一标识是否是当前线程 如果是，则增加重入计数器   释放锁后，减少重入计数器，只有当计数器为0时才认为是真正释放了锁。  拓展：  《时间轮》  </div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/23/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/22.%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="22.实现分布式锁">22.实现分布式锁</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-23T12:47:29.000Z" title="发表于 2025-10-23 20:47:29">2025-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">实现思路：set nx + lua脚本，保证：  多个客户端不会获得同一个资源锁（nx）  安全解锁（过期）  意外情况下锁的自动释放（通过lua原子实现：判断唯一key  + 释放）   拓展 具体来看：  加锁：SET lock_key uniqueValue EX expire_time NX   过期时间EX：避免客户端拿锁后宕机，导致其他客户端拿不到锁（PX是毫秒） 2.6.12后支持setnx+ex原子操作   uniqueValue：避免锁被其他客户端释放，这里需要用到lua脚本来原子执行判断+删除逻辑 客户端1拿到锁后，但是执行时间超过过期时间，锁释放后被客户端2拿到，客户端2执行业务逻辑的过程中，客户端1执行完释放掉锁 导致：客户端2的锁被客户端1释放     解锁：lua 脚本实现——通过 get 获取 key 的 value 判断锁是否是自己加的，如果是则 del。   if redis.call(&quot;GET&quot;,KEYS[1]) == ARGV[1]then    return...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/23/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/21.%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E5%8A%9F%E8%83%BD/" title="21.订阅发布功能">21.订阅发布功能</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-23T12:30:53.000Z" title="发表于 2025-10-23 20:30:53">2025-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">**订阅发布功能（ Pub&#x2F;Sub）**是一种消息通信机制，实现不同客户端之间消息的实时传递 &#x2F; 广播。 在pub&#x2F;sub模型下，客户端可订阅一个&#x2F;多个频道，当其他客户端向这些频道推送信息时，所有订阅该频道的客户端会立即收到消息，具体来说：  发布（Publish）：客户端向指定频道发布消息。 订阅（Subscribe）：一个或多个客户端订阅指定的频道，并在频道接收到消息时立刻获取该消息。  拓展 pub&#x2F;sub是消息队列的一种通信模型，生产者pub发送消息，订阅者sub接收消息。  发布者向一个或者多个频道发布消息，订阅者可以订阅一个或者多个频道所发布的消息。  	 使用： publish channel message  订阅频道后，就可以实时消费发布者的消息了：  1表示订阅成功，message就是后续的消息，之后的channel表示订阅频道  subscribe channel   	    支持消费者阻塞式拉取消息，另外还提供了匹配订阅，消费者可以根据一定的规则，订阅多个队列。 例如subscribe...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/23/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/20.%E9%9B%86%E7%BE%A4%E7%9A%84%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98/" title="20.集群的脑裂问题">20.集群的脑裂问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-23T12:17:07.000Z" title="发表于 2025-10-23 20:17:07">2025-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">脑裂问题：一个集群会出现多个主节点（尤其是网络分区的情况下），造成数据不一致 拓展 分布式系统中，由于网络分区等问题导致多个节点误认为自己是唯一的主节点，这样会导致多个主节点同时提供写入服务，导致数据不一致  就像一个团队在干活，如果发生了脑裂，就好比这个团队突然因为某些原因，比如通信出了问题，分成了几个小团体。每个小团体都以为自己是整个团队，都在按自己的方式工作，各自为政，对同一件事有不同的决策和做法，就像有的说要这么干，有的说要那么干。 这样一来，整个系统就乱套了，数据也可能变得不一致，服务也变得不正常了，这就是分布式系统中的脑裂  网络分区是造成脑裂核心原因，此时右区域误认为主节点不在了，就会自发地进行选举主节点。 	  这样就同时出现了两个主节点，同时提供写入，就会造成数据不一致。 	  解决脑裂问题不能完全解决，但可以通过参数优化  min-slaves-to-write：设置主节点在至少有指定数量的从节点确认写操作的情况下才执行写操作 min-slaves-max-lag：设置从节点的最大延迟（以秒为单位），如果从节点的延迟超过这个值，则该从节点不会被计入...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/23/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/19.%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/" title="19.哨兵机制">19.哨兵机制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-23T12:07:24.000Z" title="发表于 2025-10-23 20:07:24">2025-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">Redis 的哨兵机制（Sentinel） 是主从复制中高可用性的解决方案，自动完成主从切换 （主从故障自动恢复和通知），具体的功能：  监控：监控主从节点运行状态（定期发送PING请求检查） 自动故障转移：主节点发生故障后，哨兵们会选举一个节点为新主节点，并通知客户端更新主节点地址，实现高可用 通知：哨兵可向 管理员 &#x2F; 其他服务发送通知，从而快速追踪Redis实例变化  扩展 问题：主从架构中，主节点宕机后，如果没有新的主节点替上来，就会出现很长一段时间写请求没有响应的问题。 引出哨兵：  监控主从节点，主节点g了，就切换主节点，并通知客户端+其他从节点，最大限度减少停机 +...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/21/2.Areas%F0%9F%8C%90/01.project/condefather/yupao/back-end/11.%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/" title="11.代码优化">11.代码优化</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-21T14:49:20.000Z" title="发表于 2025-10-21 22:49:20">2025-10-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/01-project/">01.project</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/">condefather</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/yupao/">yupao</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/yupao/back-end/">back-end</a></span></div><div class="content">注：代码过程中想到的点要及时记录下来，以便做完后的改进。  </div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/21/2.Areas%F0%9F%8C%90/01.project/condefather/yupao/back-end/12.%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF/" title="12.部署上线">12.部署上线</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-21T14:49:07.000Z" title="发表于 2025-10-21 22:49:07">2025-10-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/01-project/">01.project</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/">condefather</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/yupao/">yupao</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/yupao/back-end/">back-end</a></span></div><div class="content">前端：vite build后，本地serve测试  配置线上环境，区分多环境 通过vercel --prod发布（云托管） https://vervel.com/  后端：微信云托管（部署容器平台，付费，但是按量付费可以按需使用）  mysql  redis等服务  （免备案） </div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/21/2.Areas%F0%9F%8C%90/01.project/condefather/yupao/back-end/10.%E9%9A%8F%E6%9C%BA%E5%8C%B9%E9%85%8D%E5%8A%9F%E8%83%BD/" title="10.随机匹配功能">10.随机匹配功能</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-21T14:49:03.000Z" title="发表于 2025-10-21 22:49:03">2025-10-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/01-project/">01.project</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/">condefather</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/yupao/">yupao</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/yupao/back-end/">back-end</a></span></div><div class="content">随机匹配 更快发现和自己兴趣相投的朋友  匹配一个还是匹配多个？怎么匹配？（根据什么匹配？）  匹配多个，并且按照匹配的相似度从高到低排序，根据tags，或者（拓展：用户加入的队伍，推荐队伍）  本质：找到有相似标签的用户 用户A: [Java, 大一,男] 用户B:[Java, 大二, 男] 用户C:[Python, 大二, 女] 用户D: [Java，大一, 女]  找到共同标签最多的用户（共同标签越多，分数越高，越在前面，TopN，） 如果没有匹配到用户，随机推荐几个（降级方案）   标签优先级？  思路：编辑距离算法，动态规划（最小编辑距离的意思是字符串1最少通过多少次增删改可以变成字符串2） 余弦相似度匹配（如果需要带权重，如学方向最重要）   怎么对所有用户进行匹配？取TOP  直接取出所有用户，依次和当前用户计算分数，取TopN（160s）  优化：  在数据量大的时候取消日志，优化后，90s Map存了所有的分数信息，占用内存：维护固定长度集合，按照分数降序，只保留分数最高的用户（细节：要剔除自己） 但 Map...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/20/2.Areas%F0%9F%8C%90/01.project/condefather/yupao/back-end/%E8%AE%B0%E4%B8%80%E6%AC%A1idea_cpu%E5%8D%A0%E7%94%A8%E7%8E%87%E9%AB%98%E7%9A%84%E9%97%AE%E9%A2%98/" title="记一次idea_cpu占用率高的问题">记一次idea_cpu占用率高的问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-20T12:46:51.000Z" title="发表于 2025-10-20 20:46:51">2025-10-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/01-project/">01.project</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/">condefather</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/yupao/">yupao</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/yupao/back-end/">back-end</a></span></div><div class="content">https://blog.csdn.net/csdn_life18/article/details/124185006 https://www.cnblogs.com/kuro-liang/articles/16139586.html 每次输入内容的时候，CPU就给我爆满，导致输入卡顿搞得很难受，一度怀疑自己CPU不行，后来通过分析工具发现主要是JIT的锅。。  通过配置jvm参数解决 	  #堆栈设置-Xms4096m-Xmx4096m-Xmn3072m-XX:MetaspaceSize=1024m-XX:MaxMetaspaceSize=1024m-XX:+AlwaysPreTouch-XX:InitialCodeCacheSize=1200m-XX:ReservedCodeCacheSize=1200m-XX:+UseCompressedOops-Dfile.encoding=UTF-8# 采用何种垃圾回收参数-XX:+UseConcMarkSweepGC-XX:ParallelGCThreads=4-XX:SoftRefLRUPolicyMSPerMB=50-ea#...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/20/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JVM/39.%E8%AE%B2%E8%AE%B2ZGC/" title="39.讲讲ZGC">39.讲讲ZGC</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-20T10:27:43.000Z" title="发表于 2025-10-20 18:27:43">2025-10-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JVM/">JVM</a></span></div><div class="content">ZGC（Z Garbage Collector）是Java11引入的低延迟垃圾回收器，支持大内存（4TB 理论16TB）的应用程序，并保持低GC延迟。 特点：  并发收集：ZGC收集过程大部分和应用程序同时进行 指针压缩：减少内存占用 毫秒级停顿：停顿主要是在GC roots上，受堆大小影响小，且有一系列优化机制（如果重新标记超过1ms会再次进入并发标记阶段）   注：  ZGC超过G1很重要的一点在于并发转移 到那时要注意内存分配过快导致的线程阻塞（设置 ParallelGCThreads 并行线程和 ConcGCThreads和并发线程加快回收速度，不能设置过多） ZGC的STW和GC Roots有关，在多线程、动态加载ClassLoader频繁的场景下也会增加ZGC停顿时间   机制：  分代收集：分代年轻代和老年代（JDK21后支持） 记录和重标记：记忆集跟踪对象引用关系，在GC过程中快速识别活动对象。   染色指针和读屏障是 ZGC 能实现并发转移的关键所在  拓展 ZGC概览ZGC的核心目标是低延迟，不管堆有多大 &#x2F;...</div></div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/3/#content-inner"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/#content-inner">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/#content-inner">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/#content-inner">25</a><a class="extend next" rel="next" href="/page/5/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yuezi</div><div class="author-info-description">积微者速成</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">603</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuezi2048"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">积微者速成</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/Excalidraw/Drawing%202024-11-01%2015.37.37.excalidraw/" title="Drawing 2024-11-01 15.37.37.excalidraw">Drawing 2024-11-01 15.37.37.excalidraw</a><time datetime="2025-10-31T04:19:26.621Z" title="发表于 2025-10-31 12:19:26">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/01.project/condefather/yupao/back-end/7.%E4%BC%98%E5%8C%96%E4%B8%BB%E9%A1%B5%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/" title="7.优化主页性能-优化批量导入数据">7.优化主页性能-优化批量导入数据</a><time datetime="2025-10-31T04:19:26.102Z" title="发表于 2025-10-31 12:19:26">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/81.%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B8%E6%A0%87Cursor%E5%88%86%E9%A1%B5_%E5%AF%B9%E6%AF%94%E4%BC%A0%E7%BB%9FLIMIT_OFFSET%E5%88%86%E9%A1%B5%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88/" title="81.什么是游标Cursor分页_对比传统LIMIT_OFFSET分页的优势是什么">81.什么是游标Cursor分页_对比传统LIMIT_OFFSET分页的优势是什么</a><time datetime="2025-10-31T04:14:27.000Z" title="发表于 2025-10-31 12:14:27">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/80.%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E5%90%84%E8%87%AA%E4%BC%98%E7%BC%BA%E7%82%B9/" title="80.全量同步和增量同步各自优缺点">80.全量同步和增量同步各自优缺点</a><time datetime="2025-10-31T04:13:32.000Z" title="发表于 2025-10-31 12:13:32">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/79.%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93_%E7%9B%B8%E6%AF%94%E5%8D%95%E6%9D%A1%E6%8F%92%E5%85%A5%E4%BC%98%E5%8A%BF/" title="79.什么是批量数据入库_相比单条插入优势">79.什么是批量数据入库_相比单条插入优势</a><time datetime="2025-10-31T04:03:26.000Z" title="发表于 2025-10-31 12:03:26">2025-10-31</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
      <i class="fas fa-angle-right"></i></a>
          </div>
          <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/0-InBox%F0%9F%90%AD/"><span class="card-category-list-name">0.InBox🐭</span><span class="card-category-list-count">2</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/0-InBox%F0%9F%90%AD/md/"><span class="card-category-list-name">md</span><span class="card-category-list-count">2</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/"><span class="card-category-list-name">2.Areas🌐</span><span class="card-category-list-count">584</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/00-%E7%A7%8B%E6%8B%9B%E5%87%86%E5%A4%87%E6%96%B9%E5%90%91/"><span class="card-category-list-name">00.秋招准备方向</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/"><span class="card-category-list-name">01.project</span><span class="card-category-list-count">24</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/"><span class="card-category-list-name">condefather</span><span class="card-category-list-count">24</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/user-center/"><span class="card-category-list-name">user-center</span><span class="card-category-list-count">9</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/user-center/back-end/"><span class="card-category-list-name">back-end</span><span class="card-category-list-count">8</span></a></li></ul></li></ul></li></ul></li></ul></li>
          </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/6-Excalidraw%F0%9F%8E%A8/" style="font-size: 1.1em; color: #999">6.Excalidraw🎨</a> <a href="/tags/back-end/" style="font-size: 1.37em; color: #99a4b2">back-end</a> <a href="/tags/md/" style="font-size: 1.12em; color: #999a9b">md</a> <a href="/tags/GNN/" style="font-size: 1.1em; color: #999">GNN</a> <a href="/tags/pytorch%E5%9F%BA%E6%9C%AC%E5%8A%9F/" style="font-size: 1.14em; color: #999b9d">pytorch基本功</a> <a href="/tags/Java%E9%9B%86%E5%90%88/" style="font-size: 1.41em; color: #99a5b7">Java集合</a> <a href="/tags/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/" style="font-size: 1.19em; color: #999da1">基本方法</a> <a href="/tags/%E6%80%BB%E4%BD%93%E8%A7%84%E5%88%92/" style="font-size: 1.12em; color: #999a9b">总体规划</a> <a href="/tags/docker/" style="font-size: 1.1em; color: #999">docker</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 1.5em; color: #99a9bf">Java基础</a> <a href="/tags/4-JavaWeb/" style="font-size: 1.28em; color: #99a0aa">4.JavaWeb</a> <a href="/tags/%E8%AE%BA%E6%96%87%E6%A2%B3%E7%90%86/" style="font-size: 1.43em; color: #99a6b9">论文梳理</a> <a href="/tags/yupao/" style="font-size: 1.1em; color: #999">yupao</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" style="font-size: 1.34em; color: #99a3b0">代码随想录</a> <a href="/tags/default/" style="font-size: 1.1em; color: #999">default</a> <a href="/tags/%E5%B0%8F%E8%AE%BA%E6%96%87%E6%95%85%E4%BA%8B%E7%BA%BF%E5%92%8C%E6%A8%A1%E5%9D%97%E8%AE%B0%E5%BD%95%E7%B4%A0%E6%9D%90/" style="font-size: 1.21em; color: #999da4">小论文故事线和模块记录素材</a> <a href="/tags/front-end/" style="font-size: 1.1em; color: #999">front-end</a> <a href="/tags/%E5%B0%8F%E8%AE%BA%E6%96%87%E5%87%86%E5%A4%87/" style="font-size: 1.26em; color: #999fa8">小论文准备</a> <a href="/tags/Redis/" style="font-size: 1.48em; color: #99a8bd">Redis</a> <a href="/tags/00-%E7%A7%8B%E6%8B%9B%E5%87%86%E5%A4%87%E6%96%B9%E5%90%91/" style="font-size: 1.17em; color: #999c9f">00.秋招准备方向</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/" style="font-size: 1.39em; color: #99a5b4">基础篇——韩顺平</a> <a href="/tags/Awesome-LLM-for-RecSys-main/" style="font-size: 1.1em; color: #999">Awesome-LLM-for-RecSys-main</a> <a href="/tags/%E6%97%A9%E6%9C%9F%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 1.1em; color: #999">早期工作的基础知识</a> <a href="/tags/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C%EF%BC%9AMENTER-%E7%94%A8%E6%88%B7%E6%B3%A8%E5%85%A5-%E5%9B%A0%E6%9E%9C%E6%AD%A3%E5%88%99/" style="font-size: 1.32em; color: #99a2ae">第一次实验：MENTER+用户注入+因果正则</a> <a href="/tags/Spring/" style="font-size: 1.17em; color: #999c9f">Spring</a> <a href="/tags/1-%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" style="font-size: 1.26em; color: #999fa8">1.监督学习</a> <a href="/tags/Spring-MVC/" style="font-size: 1.3em; color: #99a1ac">Spring MVC</a> <a href="/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/" style="font-size: 1.12em; color: #999a9b">算法基础课</a> <a href="/tags/%E6%A8%A1%E5%9E%8B%E6%95%B4%E7%90%86/" style="font-size: 1.1em; color: #999">模型整理</a> <a href="/tags/2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" style="font-size: 1.14em; color: #999b9d">2.无监督学习</a> <a href="/tags/vue/" style="font-size: 1.12em; color: #999a9b">vue</a> <a href="/tags/7-SpringBoot/" style="font-size: 1.23em; color: #999ea6">7.SpringBoot</a> <a href="/tags/JVM/" style="font-size: 1.46em; color: #99a7bb">JVM</a> <a href="/tags/Github/" style="font-size: 1.12em; color: #999a9b">Github</a> <a href="/tags/Excalidraw/" style="font-size: 1.1em; color: #999">Excalidraw</a> <a href="/tags/SSM%E6%95%B4%E5%90%88/" style="font-size: 1.1em; color: #999">SSM整合</a> <a href="/tags/5-Maven%E4%B8%93%E9%A2%98/" style="font-size: 1.12em; color: #999a9b">5.Maven专题</a> <a href="/tags/%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0%E6%80%BB%E7%BB%93/" style="font-size: 1.12em; color: #999a9b">论文复现总结</a> <a href="/tags/3-JDBC/" style="font-size: 1.14em; color: #999b9d">3.JDBC</a> <a href="/tags/%E5%8F%AF%E8%83%BD%E4%BC%9A%E7%94%A8%E5%88%B0%E7%9A%84%E6%A8%A1%E5%9D%97/" style="font-size: 1.14em; color: #999b9d">可能会用到的模块</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>归档</span>
      <a class="card-more-btn" href="/archives/"
            title="查看更多">
            <i class="fas fa-angle-right"></i>
          </a>
    </div>
  
    <ul class="card-archive-list">
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/10/">
            <span class="card-archive-list-date">
              十月 2025
            </span>
            <span class="card-archive-list-count">201</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/09/">
            <span class="card-archive-list-date">
              九月 2025
            </span>
            <span class="card-archive-list-count">98</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/08/">
            <span class="card-archive-list-date">
              八月 2025
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/07/">
            <span class="card-archive-list-date">
              七月 2025
            </span>
            <span class="card-archive-list-count">39</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/06/">
            <span class="card-archive-list-date">
              六月 2025
            </span>
            <span class="card-archive-list-count">24</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/05/">
            <span class="card-archive-list-date">
              五月 2025
            </span>
            <span class="card-archive-list-count">13</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/04/">
            <span class="card-archive-list-date">
              四月 2025
            </span>
            <span class="card-archive-list-count">80</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/03/">
            <span class="card-archive-list-date">
              三月 2025
            </span>
            <span class="card-archive-list-count">6</span>
          </a>
        </li>
      
    </ul>
  </div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">603</div></div><div class="webinfo-item"><div class="item-name">运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2025-04-05T00:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">1041.3k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总浏览量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2025-10-31T04:19:46.697Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/backgroud.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By yuezi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>window.typedJSFn = {
  init: str => {
    window.typed = new Typed('#subtitle', Object.assign({
      strings: str,
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50,
    }, null))
  },
  run: subtitleType => {
    if (true) {
      if (typeof Typed === 'function') {
        subtitleType()
      } else {
        btf.getScript('https://cdn.jsdelivr.net/npm/typed.js/dist/typed.umd.min.js').then(subtitleType)
      }
    } else {
      subtitleType()
    }
  },
  processSubtitle: (content, extraContents = []) => {
    if (true) {
      const sub = [].slice()

      if (extraContents.length > 0) {
        sub.unshift(...extraContents)
      }

      if (typeof content === 'string') {
        sub.unshift(content)
      } else if (Array.isArray(content)) {
        sub.unshift(...content)
      }

      sub.length > 0 && typedJSFn.init(sub)
    } else {
      document.getElementById('subtitle').textContent = typeof content === 'string' ? content :
        (Array.isArray(content) && content.length > 0 ? content[0] : '')
    }
  }
}
btf.addGlobalFn('pjaxSendOnce', () => { typed.destroy() }, 'typedDestroy')
</script><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      const from = '出自 ' + data.from
      typedJSFn.processSubtitle(data.hitokoto, [from])
    })
    .catch(err => {
      console.error('Failed to get the Hitokoto API:', err)
      typedJSFn.processSubtitle([])
    })
}
typedJSFn.run(subtitleType)
</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>