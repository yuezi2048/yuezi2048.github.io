<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>yuezi</title><meta name="author" content="yuezi"><meta name="copyright" content="yuezi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="积微者速成">
<meta property="og:type" content="website">
<meta property="og:title" content="yuezi">
<meta property="og:url" content="https://yuezi2048.github.io/page/6/index.html">
<meta property="og:site_name" content="yuezi">
<meta property="og:description" content="积微者速成">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuezi2048.github.io/img/touxiang.jpg">
<meta property="article:author" content="yuezi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuezi2048.github.io/img/touxiang.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuezi2048.github.io/page/6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?bfb48b678d82bea9f9cc9d59227767e4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"FPH6F2TOJL","apiKey":"06d9ea26c803ba912b4d8e13404ed34d","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'yuezi',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'home'
}</script><link rel="stylesheet" href="/css/backgound.css"><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">785</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">91</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url(/img/backgroud.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yuezi</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="site-info"><h1 id="site-title">yuezi</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts nc" id="recent-posts"><div class="recent-post-items"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/59.ABA%E9%97%AE%E9%A2%98/" title="59.ABA问题">59.ABA问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T14:17:25.000Z" title="发表于 2025-11-06 22:17:25">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">ABA 问题是指在多线程环境下，某个变量的值在一段时间内经历了从 A 到 B 再到 A 的变化，这种变化可能被线程误认为值没有变化，从而导致错误的判断和操作。ABA 问题常发生在使用 CAS（Compare-And-Swap） 操作的无锁并发编程中。  补充解释 CAS ABA 问题影响  CAS 是一种无锁算法，用于在多线程环境下实现原子操作。它通过比较内存中的值是否与预期值一致，来决定是否更新变量的值。在这种机制下，如果一个线程读取到的变量值是 A，而在它执行 CAS 操作之前，另一个线程将该变量的值从 A 改成 B 然后又改回 A，那么第一个线程会认为变量的值没有变化，从而错误地进行下一步操作。 扩展知识ABA 问题的示例假设有一个简单的无锁栈，其 pop 操作如下： public class LockFreeStack&lt;T&gt; &#123;    private AtomicReference&lt;Node&lt;T&gt;&gt; head = new AtomicReference&lt;&gt;();    public T pop() &#123; ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/58.volatile%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%9C%E7%94%A8/" title="58.volatile关键字作用">58.volatile关键字作用</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T14:17:17.000Z" title="发表于 2025-11-06 22:17:17">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">volatile 它的主要作用是保证变量的可见性和禁止指令重排优化。 1）可见性（Visibility）：  volatile 关键字确保变量的可见性。当一个线程修改了 volatile 变量的值，新值会立即被刷新到主内存中，其他线程在读取该变量时可以立即获得最新的值。这样可以避免线程间由于缓存一致性问题导致的“看见”旧值的现象。  2）禁止指令重排序（Ordering）：  volatile 还通过内存屏障来禁止特定情况下的指令重排序，从而保证程序的执行顺序符合预期。对 volatile 变量的写操作会在其前面插入一个 StoreStore 屏障，而对 volatile 变量的读操作则会在其后插入一个 LoadLoad 屏障。这确保了在多线程环境下，某些代码块执行顺序的可预测性。  扩展知识可见性问题与 volatile 的解决在 Java 的多线程环境中，每个线程都有自己的工作内存（CPU 缓存），它会从主内存中读取变量的副本进行操作。  因此，线程 A 修改了某个变量后，线程 B 不一定能立即看到这个修改。volatile...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/57.Java%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%AD%BB%E9%94%81_%E9%81%BF%E5%85%8D/" title="57.Java什么情况会出现死锁_避免">57.Java什么情况会出现死锁_避免</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T14:17:05.000Z" title="发表于 2025-11-06 22:17:05">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">这是一个非常典型的八股文，死锁的发生必须满足以下四个条件，这些条件被称为“死锁的必要条件”：  互斥条件：每个资源只能被一个线程占用。 占有和等待：线程在持有至少一个资源的同时，等待获取其他资源。 不可抢占：线程所获得的资源在未使用完毕之前不能被其他线程抢占。 循环等待：多个线程形成一种头尾相接的循环等待资源关系。  只要我们打破上述的一个条件，就能避免死锁的发生。 避免死锁的方法 按序申请资源：确保所有线程在获取多个锁时，按照相同的顺序获取锁。 尽量减少锁的范围：将锁的粒度尽可能缩小，减少持有锁的时间。可以通过拆分锁或使用更细粒度的锁来实现。 使用尝试锁机制：使用 ReentrantLock 的 tryLock 方法，尝试在一段时间内获取锁，如果无法获取，则可以选择放弃或采取其他措施，避免死锁。 设置超时等待时间：为锁操作设置超时，防止线程无限期地等待锁。 避免嵌套锁：尽量避免在一个锁的代码块中再次尝试获取另一个锁。  </div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/56.wait_notify_notifyAll/" title="56.wait_notify_notifyAll">56.wait_notify_notifyAll</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T14:16:52.000Z" title="发表于 2025-11-06 22:16:52">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">这三个方法是Object内用于线程通信 &#x2F; 同步的方法，需要在 synchronized 修饰的方法或同步块中使用。  wait() 使得当前线程进入等待状态，且会释放锁。 notify() 会顺序（在 hotspot 的实现中）唤醒一个调用 wait 后等待的线程。 notifyAll 会唤醒所有调用 wait 等待的线程。  扩展知识在 Object 源码中 notify 方法上的注释写到：其唤醒 wait 的线程是任意（arbitrary）的，但是具体还是需要看实现：  目前一般我们的 JVM 实现都是 hotspot，因此我们看下 hotspot 源码的实现： 在调用 wait 的时候，可以看到实际上会调用 AddWaiter 方法，从源码来看就是入队排着：  然后 notify 的时候，实际上让排第一个的线程出队：  所以在 hotspot 中，notify 实际上是顺序唤醒线程的。 </div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/55.Thread.sleep(0)%E7%9A%84%E4%BD%9C%E7%94%A8/" title="55.Thread.sleep(0)的作用">55.Thread.sleep(0)的作用</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T14:16:40.000Z" title="发表于 2025-11-06 22:16:40">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">核心作用并不是睡眠，而是从睡眠-唤醒的这个过程，表示当前线程会暂时让出CPU，让CPU资源有短暂的空闲让别的线程有机会得到CPU资源。 类似Thread.yield() 命令，也是让当前线程主动放弃 CPU 使用权，使得其他线程有机会使用 CPU。  在一些大循环场景下，害怕这段逻辑会一直占用CPU资源，可以使用Thread.sleep(0)来让别的线程有机会使用CPU  </div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/54.Thread.sleep%E5%AF%B9%E6%AF%94yield/" title="54.Thread.sleep对比yield">54.Thread.sleep对比yield</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T14:16:28.000Z" title="发表于 2025-11-06 22:16:28">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">Thread.sleep() 和 Thread.yield() 都是用于控制线程行为的两个方法。  Thread.sleep()：使当前线程进入TIME_WAITTING状态，暂停指定的时间（ms），此时线程不会占用CPU时间片，结束后，才尝试重新获取CPU时间片，进入可运行状态（休眠时间取决于操作系统精度，会有轻微误差） Thread.yield()：提示当前线程愿意让出CPU时间片给其他线程，此时线程还是RUNNABLE状态，且没有被阻塞。调度器会尝试将时间片分配给相同优先级其他线程，但如果没有合适线程当前线程可能还会继续执行 只是一个提示，线程调度器可以选择忽略 不会进入阻塞状态，仍是RUNNABLE状态。     一些CPU密集型任务会使用到yield，避免某些线程长时间占用CPu  扩展知识Thread.sleep() 与 Thread.yield() 的底层机制：  Thread.sleep() 底层调用了操作系统的定时器机制，线程在指定时间内停止执行。当时间结束后，线程会被唤醒并进入可运行状态，等待 CPU 时间片的重新分配。 Thread.yield()...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/53.%E4%BB%80%E4%B9%88%E6%98%AFTransmittableThreadLocal/" title="53.什么是TransmittableThreadLocal">53.什么是TransmittableThreadLocal</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T14:16:10.000Z" title="发表于 2025-11-06 22:16:10">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/52.Netty%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8ThreadLocal%E8%80%8C%E6%98%AF%E8%87%AA%E5%AE%9A%E4%B9%89FastThreadLocal/" title="52.Netty为什么不用ThreadLocal而是自定义FastThreadLocal">52.Netty为什么不用ThreadLocal而是自定义FastThreadLocal</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T14:15:46.000Z" title="发表于 2025-11-06 22:15:46">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/51.ThreadLocal%E7%9A%84%E7%BC%BA%E7%82%B9/" title="51.ThreadLocal的缺点">51.ThreadLocal的缺点</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T14:15:34.000Z" title="发表于 2025-11-06 22:15:34">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">正常情况下使用 ThreadLocal 是没什么问题的，但是如果极端情况下，数据比较多，则可能会出现以下几个问题：  内存泄露问题（特别是线程复用场景） ThreadLocal 中的 ThreadLocalMap Hash 冲突用的是线性探测法，效率低 ThreadLocal 主动清理的开销问题  扩展知识内存泄漏问题ThreadLocal 的生命周期和线程的生命周期绑定，线程池中的线程可能被复用，但 ThreadLocal 中的值不会自动清理，导致可能发生内存泄漏。 ThreadLocalMap Hash 冲突线性探测法，效率低。  可以看到，图上显示的是经过两个遍历找到了空位，假设冲突多了，需要遍历的次数就多了。并且下次 get 的时候，hash 直接命中的位置发现不是要找的 Entry ，于是就接着遍历向后找，所以说这个效率低。 而像 HashMap 是通过链表法来解决冲突，并且为了防止链表过长遍历的开销变大，在一定条件之后又会转变成红黑树来查找，这样的解决方案在频繁冲突的条件下，肯定是优于线性探测法，所以这是一个优化方向。 ThreadLocal...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/50.InheritableThreadLocal%E6%98%AF%E4%BB%80%E4%B9%88/" title="50.InheritableThreadLocal是什么">50.InheritableThreadLocal是什么</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T14:15:22.000Z" title="发表于 2025-11-06 22:15:22">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">InheritableThreadLocal 是ThreadLocal一个拓展，用于线程创建时将父线程的ThreadLocal变量副本传递给子线程，使得子线程可以访问到父线程的本地变量。解决了 ThreadLocal 无法在子线程中继承父线程本地变量的问题。 工作原理：  当创建子线程时，InheritableThreadLocal 的值会被自动拷贝到子线程中。 子线程可以修改自己的副本，但不会影响父线程的值。   InheritableThreadLocal有一个缺陷，在线程池的预创建场景下，调用的时候无法直接使用，引出阿里的TransmittableThreadLocal。大致思想是：从线程池获取到ThreadLocal，复制ThreadLocal，holder变量维护本地变量。finally提交的时候把本地数据复原，防止内存泄露使用弱引用。  扩展知识源码分析原理其实很简单，在 Thread 中已经包含了这个成员：  在父线程创建子线程的时候，子线程的构造函数可以得到父线程，然后判断下父线程的 InheritableThreadLocal...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/48.%E4%B8%BA%E4%BB%80%E4%B9%88ThreadLocal%E5%AF%B9key%E6%98%AF%E5%BC%B1%E5%BC%95%E7%94%A8/" title="48.为什么ThreadLocal对key是弱引用">48.为什么ThreadLocal对key是弱引用</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T14:14:53.000Z" title="发表于 2025-11-06 22:14:53">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">key弱引用的目的：防止内存泄露。具体来说，当不再需要的线程强引用ThreadLocal实例时，线程结束后，对应的数据可能无法回收（比如线程池复用线程的情况）。 那么弱引用就可以允许在内存不足的时候GC，只要没有强引用指向ThreadLocal实例，就可以被及时回收。  追问：不用的线程回收不就好了？这样强引用没了不就可以自动回收了吗？ 理论上确实是对的，问题就在于我们一般会用线程池来复用线程（生命周期相对于ThreadLocal要长很多）。所以他是不会被清理的，那么引用链就会保持。所以 key到ThreadLocal的引用需要弱化，保证即使线程复用，对应的Entry能及时清理。  值得注意的是，栈中的ThreadLocal指向ThreadLocal对象是强引用，在GC的时候不会回收。当对应线程执行完了，栈帧弹出了就可以被回收，也这就是你说的这种强引用回收情况。 追问：那既然你说key指向ThreadLocal的对象清除了，那value的值呢？不是还有内存泄露的问题吗？  key 被回收了之后，会发生 Entry 中 key 为 null 的情况，因为有...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/49.ThreadLock%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" title="49.ThreadLock最佳实践">49.ThreadLock最佳实践</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T14:14:42.000Z" title="发表于 2025-11-06 22:14:42">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content"> 避免滥用ThreadLocal：适合每个线程维护独立副本的场景（数据库连接 用户会话 事务上下文 临时缓存） 能通过参数传递的上下文信息，就不需要使用ThreadLocal处理，避免不合理的设计和差可读性   避免内存泄露：虽然ThreadLocal的key是弱引用，但value仍是强引用，这需要在合适的时机调用remove方法清除ThreadLocal的值，避免内存泄露（特别是线程池的情况，线程会被重用） 使用静态变量存放ThreadLocal：通过类的静态变量保存，可以保证同一个线程局部变量在生命周期内都可以访问到，避免对象的频繁创建 合理的生命周期：使用ThreadLocal完成后及时释放，避免由于线程未结束导致资源浪费（尤其是长时间服务&#x2F;线程池情况，任务结束后要及时清理ThreadLocal变量）   注意：如Tomcat会隐式创建线程池，所以会出现线程复用的情况，所以及时释放的操作很有必要。  扩展知识合理初始化 ThreadLocal使用 ThreadLocal 时，可以通过重写 initialValue() 方法来提供默认值，这样可以避免在第一次调用...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/47.ThreadLocal%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB/" title="47.ThreadLocal如何实现资源隔离">47.ThreadLocal如何实现资源隔离</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T14:14:32.000Z" title="发表于 2025-11-06 22:14:32">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">ThreadLocal...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/46.%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%94%A8ThreadLocal/" title="46.为什么需要用ThreadLocal">46.为什么需要用ThreadLocal</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T14:14:21.000Z" title="发表于 2025-11-06 22:14:21">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">本质上是为了让线程隔离（可以避免多个线程同时修改共享变量导致线程安全问题），ThreadLocal使得每个线程有一个自己的独立变量样本，从而避免了多线程的变量共享和竞争。 相对于加锁、同步块等方式保证线程安全，他不需要对变量访问同步，减少了上下文切换 锁竞争的开销。  补充ThreadLocal作用：  代码 层级较深时（多层函数调用）并且需要共享上下文信息（用户ID 事务对象等），可以替代参数传递，直接在任意层获取数据即可 如数据库事务管理，存储当前线程的数据库连接，避免每层代码显式传递连接对象    追问：ThreadLocal具体原理？ 每个线程维护自己的ThreadLocalMap，而不是一个整体的Map  扩展知识常见应用场景 数据库连接管理：每个线程拥有自己的数据库连接，避免了多个线程共享同一个连接导致的线程安全问题。 用户上下文管理：在处理用户请求时，每个线程拥有独立的用户上下文（如用户ID、Session信息），在并发环境中确保正确的用户数据。  ThreadLocal 的原理ThreadLocal...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/45.final%E8%83%BD%E5%90%A6%E4%BF%9D%E8%AF%81%E5%8F%98%E9%87%8F%E5%8F%AF%E8%A7%81%E6%80%A7/" title="45.final能否保证变量可见性">45.final能否保证变量可见性</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T14:13:57.000Z" title="发表于 2025-11-06 22:13:57">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">不可以。因为变量的可见性和final的作用不是一个概念。我来跟你逐个解释一下：  变量的可见性：线程修改共享变量后，要求其他线程可以立马知道更改情况，从而得到最新的值 而final的作用：final修饰字段是为了保证，其他线程能拿到初始化final字段后的值，避免脏读到由于重排序未写入的字段（this引用没有传递出去的话） 但是多线程如果修改可变对象内部的值，是无法立刻知道线程何时修改了这些值的，所以无法保证可见性    简单来说，final如果指向可变对象（List等），final对象内部可见性是不能保证的（即List的内部数据的操作不能保证原子性、可见性） 解决方案：还是需要通过线程安全的集合、锁、CAS、volatile、原子操作等保证变量的可见性，所以单纯的说final保证了变量可见性并不是很准确，核心在于引用和对象内部的关系。 分析下面的案例，final的加入只是保证了：  构造函数首次对final域创建对象  happens before 随后将其引用赋值给引用变量，从而保证final对象在其他线程可见前可以正确初始化 线程首次拿到对象引用 happens...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/44.%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/" title="44.什么是指令重排">44.什么是指令重排</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T13:50:44.000Z" title="发表于 2025-11-06 21:50:44">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">指令重排：Java编译器、处理器优化性能的做法，保证单线程语义不变情况下，对指令执行顺序进行调整，但是在多线程情况下可能出现线程不同步的情况。 解决方案：内存模型（JMM），以及相关机制（volatile、synchronized）等限制该行为，保证并发的正确性。 主要原因： 编译器优化：编译器会在不影响单线程程序语义的情况下重排序代码，以提升执行效率。 处理器优化：现代处理器会进行指令流水线优化，允许多条指令并行执行或重排序。  重排序的影响： 单线程情况下不会影响程序执行结果。 多线程情况下，指令重排可能导致线程之间的数据不一致问题，影响并发的正确性。   追问：为了避免多线程的指令重排，有实际的应用场景能说说吗？ &#x2F; 如果让你解决指令重排问题，你会怎么解决？ 在单例模式的设计模式下，为了避免指令重排问题，通过双重检查锁定进行优化  原因：初始化单例对象时，由于编译器&#x2F;...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/41.Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/" title="41.Java内存模型JMM">41.Java内存模型JMM</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T13:42:17.000Z" title="发表于 2025-11-06 21:42:17">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">**Java 内存模型（Java Memory Model, JMM）**是JVM定义的规范，描述多线程中变量如何在内存存储和传递的规则（规范线程何时从主线程读取数据，何时将数据写回内存） JMM 的核心目标：保证多线程环境下的可见性、有序性和原子性，从而避免由于硬件和编译器优化带来的不一致问题。  原子性：是指操作不可分割，线程不会在执行过程中被中断。例如，synchronized 关键字能确保方法或代码块的原子性。 可见性：确保一个线程对变量的修改，能及时被其他线程看到。关键字 volatile 就是用来保证可见性的，它强制线程每次读写时都直接从主内存中获取最新值。 有序性：指线程执行操作的顺序。JMM 允许某些指令重排序以提高性能，但会保证线程内的操作顺序不会被破坏，并通过 happens-before 关系保证跨线程的有序性。   追问：happens-before的规则具体说说？  代码顺序保证：在一个线程内，按照代码顺序，前面的操作 Happens-Before 后面的操作。  锁的顺序保证：对一个锁（监视器锁）的解锁操作 Happens-Before...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/43.happens-before%E5%8E%9F%E5%88%99/" title="43.happens-before原则">43.happens-before原则</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T13:41:49.000Z" title="发表于 2025-11-06 21:41:49">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">happens-before 规则是 Java 内存模型 (Java Memory Model, JMM) 中的核心概念，用于定义多线程程序中操作的可见性和顺序性。它通过指定一系列操作之间的顺序关系，确保线程间的操作是有序的，避免由于重排序或线程间数据不可见导致的并发问题。 happens-before 规则的主要规则：1）程序次序规则：在一个线程中，代码的执行顺序是按照程序中的书写顺序执行的，即一个线程内，前面的操作 happens-before 后面的操作。 2）监视器锁规则：一个锁的解锁（unlock）操作 happens-before 后续对这个锁的加锁（lock）操作。也就是说，在释放锁之前的所有修改在加锁后对其他线程可见。 3）volatile 变量规则：对一个 volatile 变量的写操作 happens-before 后续对这个 volatile 变量的读操作。它保证 volatile 变量的可见性，确保一个线程修改 volatile 变量后，其他线程能立即看到最新值。 4） 线程启动规则：线程 A 执行 Thread.start() 操作后，线程 B...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/42.%E5%8E%9F%E5%AD%90%E6%80%A7_%E5%8F%AF%E8%A7%81%E6%80%A7_%E6%9C%89%E5%BA%8F%E6%80%A7/" title="42.原子性_可见性_有序性">42.原子性_可见性_有序性</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T13:40:21.000Z" title="发表于 2025-11-06 21:40:21">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">1）原子性（Atomicity）：原子性指的是一个操作或一系列操作要么全部执行成功，要么全部不执行，期间不会被其他线程干扰。 2）可见性（Visibility）：可见性指的是当一个线程修改了某个共享变量的值，其他线程能够立即看到这个修改。 3）有序性（Ordering）：有序性指的是程序执行的顺序和代码的先后顺序一致。但在多线程环境下，为了优化性能，编译器和处理器可能会对指令进行重排序。 扩展知识1）原子性 原子类与锁：Java 提供了 java.util.concurrent.atomic 包中的原子类，如 AtomicInteger, AtomicLong，来保证基本类型的操作具有原子性。此外，synchronized 关键字和 Lock 接口也可以用来确保操作的原子性。 CAS（Compare-And-Swap）：Java 的原子类底层依赖于 CAS 操作来实现原子性。CAS 是一种硬件级的指令，它比较内存位置的当前值与给定的旧值，如果相等则将内存位置更新为新值，这一过程是原子的。CAS...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/40.java%E7%9A%84%E8%AF%BB%E5%86%99%E9%94%81/" title="40.java的读写锁">40.java的读写锁</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T13:33:15.000Z" title="发表于 2025-11-06 21:33:15">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">读写锁，它允许多个线程同时读取共享资源，而在写操作时确保只有一个线程能够进行写操作（读读操作不互斥，读写互斥、写写互斥）。这种机制适合于读多写少的场景，因为它提高了系统的并发性和性能。 Java 中的 ReadWriteLock 是通过 ReentrantReadWriteLock 实现的，它提供了以下两种锁模式：  读锁（共享锁）：允许多个线程同时获取读锁，只要没有任何线程持有写锁。适合读操作频繁而写操作较少的场景。 写锁（独占锁）：写锁是独占的，当有线程持有写锁时，其他线程既不能获取写锁，也不能获取读锁。写锁用于保证写操作的独占性，防止数据不一致。  扩展知识读写锁的原理： 共享与独占：读锁是共享锁，多个线程可以同时获取；而写锁是独占锁，在持有写锁期间，其他线程不能获取写锁或读锁。 锁降级：ReentrantReadWriteLock 支持锁降级，即持有写锁的线程可以直接获取读锁，从而在写操作完成后不必完全释放锁，但不支持锁升级（即不能从读锁升级为写锁）。 公平锁与非公平锁：ReentrantReadWriteLock...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/39.%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96java%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8/" title="39.如何优化java锁的使用">39.如何优化java锁的使用</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T13:33:07.000Z" title="发表于 2025-11-06 21:33:07">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">主要有以下两种常见的优化方法：  减少锁粒度： 减小锁的范围（最小代码块），减少锁的持有时间 读多写少场景下可以使用读写锁ReentrantReadWriteLock 代替独占锁   减少锁使用 可以考虑无锁编程、CAS、原子类来避免使用锁，减少锁带来的性能损耗 减少共享资源使用，避免对同一资源的竞争，可考虑使用局部变量 &#x2F; 本地变量（ThreadLocal）减少多个线程对同一资源的访问    扩展知识锁的种类及使用场景 独占锁（Exclusive Lock）：如 synchronized 和 ReentrantLock，同一时间只允许一个线程持有锁，适合写操作较多的场景。 读写锁（ReadWriteLock）：允许多个线程并发读，但写时需要独占锁，适合读多写少的场景。 乐观锁和悲观锁：悲观锁假设会有并发冲突，每次操作都加锁；而乐观锁假设不会有冲突，通过版本号或 CAS 实现冲突检测。  CAS 500. 什么是 Java 的 CAS（Compare-And-Swap）操作？  原子类 489. 你使用过 Java 中的哪些原子类？  </div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/38.Volatile%E5%AF%B9%E6%AF%94Synchronized/" title="38.Volatile对比Synchronized">38.Volatile对比Synchronized</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T13:30:50.000Z" title="发表于 2025-11-06 21:30:50">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">volatile和synchronized作用和场景不同：  volatile： 应用于字段变量，保证变量可见性（每次读取volatile变量，会从主内存读取最新值，写入则会立即将其刷到内存），性能开销小（不加锁，只保证线程间可见） 但不保证原子性（如i++会有线程安全问题）   synchronized 应用于方法 &#x2F; 代码块，保证可见性（加锁的方式从主存读取最新值，将数据写入主存后释放锁） 保证原子性（锁保证同一时间只能有一个线程执行被保护的代码块），性能开销大（需要获取和释放锁，会造成线程阻塞）       特性 volatile synchronized    适用范围 单个变量 方法或代码块   可见性 保证 保证   原子性 不保证 保证   性能开销 较小 较大   典型场景 状态标志位 复杂操作或多个变量的保护   扩展知识volatile 如何保证可见性？ volatile 关键字在 Java 中通过特定的内存模型规则来保证变量的可见性。它确保一个线程对 volatile 变量的修改对其他线程是立即可见的。 1）Java 内存模型（JMM） Java...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/37.synchronized%E5%AF%B9%E6%AF%94reentrantLock/" title="37.synchronized对比reentrantLock">37.synchronized对比reentrantLock</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T12:52:23.000Z" title="发表于 2025-11-06 20:52:23">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">都是可重入锁。  Synchronized是Java内置关键字，实现基本同步机制，但不支持超时、非公平、不可中断、不支持多条件，不需要手动解锁 ReentrantLock是JUC类库（1.5引入），支持超时时间（避免死锁 更灵活），支持非公平、可中断、支持多条件Condition，需要手动解锁   性能目前来看差不多，以前是Synchronized性能差  扩展知识可重入锁重入锁指的是同一个线程在持有某个锁的时候，可以再次获取该锁而不会发生死锁。例如以下代码： outer 还需要调用 inner，它们都用到了同一把锁，如果不可重入那么就会导致死锁。 public class ReentrantLockExample &#123;    private final ReentrantLock lock = new ReentrantLock();    public void outer() &#123;        lock.lock();        try &#123;            inner();        &#125; finally &#123;  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/36.%E9%94%81%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B/" title="36.锁自适应自旋">36.锁自适应自旋</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T12:50:02.000Z" title="发表于 2025-11-06 20:50:02">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">锁自适应自旋 是 锁优化机制，用于减少竞争锁时由于阻塞&#x2F;唤醒的频繁挂起和恢复开销 核心思路是：进入等待前，基于之前自旋结果，自适应调整当前自诩次数进行自旋操作  其中， Syncronized 在争抢重量级锁时候会自旋，空转 CPU 等着锁的释放。  优点：  自旋可以避免线程的上下文切换开销，因为线程进入阻塞状态会涉及到操作系统层面的挂起和唤醒，代价较高。 通过动态调整自旋次数，可以缓解浪费CPU的情况，使得在轻度锁争用情况下的性能提升显著。  扩展知识自适应自旋扩展在 Java 中，锁通常是由操作系统的同步原语（如 mutex）实现的。当线程无法获取锁时，通常会被操作系统挂起，这会涉及到线程状态的转换和 CPU 上下文的切换，代价较高。而自旋锁避免了这种高开销操作。 在 HotSpot JVM 中，自适应自旋是默认开启的，且锁的自旋次数根据上一次锁的争用情况动态调整，具体实现可以参考 LockingMechanisms.cpp 文件中的 AdaptiveSpinLock 部分。 自适应自旋的调优：  在 JVM 中，可以通过 -XX:+UseSpinning...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/11/06/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/35.synchronized%E5%8D%87%E7%BA%A7%E5%88%B0%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%90%8E%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E9%87%8A%E6%94%BE%E9%94%81%E8%BF%98%E6%98%AF%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%90%97/" title="35.synchronized升级到重量级锁后所有线程释放锁还是重量级锁吗">35.synchronized升级到重量级锁后所有线程释放锁还是重量级锁吗</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-06T12:47:03.000Z" title="发表于 2025-11-06 20:47:03">2025-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/JUC/">JUC</a></span></div><div class="content">当重量级锁释放了之后，锁对象是无锁的。有新的线程来竞争的话又会从无锁再到轻量级锁开始后续的升级流程。 扩展知识我们都知道 synchronized 的锁升级，也听过锁升级之后不会降级，所以理所当然的认为当一个锁升级为重量级锁之后，任何线程再来争抢之后会走重量级锁的逻辑。 不会再从无锁到偏向锁到轻量级锁再到重量级锁。 那事实是怎样的呢？这篇咱们不看源码，直接整结果。 我们直接看锁对象的锁标志来判断。 	  注：1.8 的偏向锁是会延迟生效的，得在 JVM 启动 4 秒后生效，可通过 -XX:BiasedLockingStartupDelay&#x3D;0关闭偏向锁延迟  而我们忽略了偏向锁的结果是这样的：  初始状态无锁 4个线程同时竞争变成了重量级锁 而释放后，再去争抢锁，从无锁变成了轻量级锁（忽略了偏向锁）  	 源码 /** * @author yuezi2048 * @version 1.0 */public class resetLockDemo &#123;    static Object testLock;    public static void...</div></div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/5/#content-inner"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/#content-inner">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/#content-inner">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/#content-inner">32</a><a class="extend next" rel="next" href="/page/7/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yuezi</div><div class="author-info-description">积微者速成</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">785</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">91</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuezi2048"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">积微者速成</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/22/Excalidraw/Drawing%202024-11-01%2015.37.37.excalidraw/" title="Drawing 2024-11-01 15.37.37.excalidraw">Drawing 2024-11-01 15.37.37.excalidraw</a><time datetime="2026-02-22T05:56:41.839Z" title="发表于 2026-02-22 13:56:41">2026-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/22/2.Areas%F0%9F%8C%90/01.project/condefather/yupao/back-end/7.%E4%BC%98%E5%8C%96%E4%B8%BB%E9%A1%B5%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/" title="7.优化主页性能-优化批量导入数据">7.优化主页性能-优化批量导入数据</a><time datetime="2026-02-22T05:56:41.257Z" title="发表于 2026-02-22 13:56:41">2026-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/31/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/5.%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8/" title="5.工具调用">5.工具调用</a><time datetime="2026-01-31T03:54:22.000Z" title="发表于 2026-01-31 11:54:22">2026-01-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/30/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/4.RAG%E8%BF%9B%E9%98%B6/" title="4.RAG进阶">4.RAG进阶</a><time datetime="2026-01-30T13:23:42.000Z" title="发表于 2026-01-30 21:23:42">2026-01-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/3.RAG/" title="3.RAG">3.RAG</a><time datetime="2026-01-27T09:06:56.000Z" title="发表于 2026-01-27 17:06:56">2026-01-27</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
      <i class="fas fa-angle-right"></i></a>
          </div>
          <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/0-InBox%F0%9F%90%AD/"><span class="card-category-list-name">0.InBox🐭</span><span class="card-category-list-count">2</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/0-InBox%F0%9F%90%AD/md/"><span class="card-category-list-name">md</span><span class="card-category-list-count">2</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/"><span class="card-category-list-name">2.Areas🌐</span><span class="card-category-list-count">766</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/00-%E7%A7%8B%E6%8B%9B%E5%87%86%E5%A4%87%E6%96%B9%E5%90%91/"><span class="card-category-list-name">00.秋招准备方向</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/"><span class="card-category-list-name">01.project</span><span class="card-category-list-count">25</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/"><span class="card-category-list-name">condefather</span><span class="card-category-list-count">25</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/tuku/"><span class="card-category-list-name">tuku</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/user-center/"><span class="card-category-list-name">user-center</span><span class="card-category-list-count">9</span></a></li></ul></li></ul></li></ul></li>
          </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/3-JDBC/" style="font-size: 1.15em; color: #999b9e">3.JDBC</a> <a href="/tags/Github/" style="font-size: 1.13em; color: #999a9b">Github</a> <a href="/tags/front-end/" style="font-size: 1.1em; color: #999">front-end</a> <a href="/tags/%E8%AE%BA%E6%96%87%E6%A2%B3%E7%90%86/" style="font-size: 1.4em; color: #99a5b6">论文梳理</a> <a href="/tags/condefather/" style="font-size: 1.1em; color: #999">condefather</a> <a href="/tags/5-Maven%E4%B8%93%E9%A2%98/" style="font-size: 1.13em; color: #999a9b">5.Maven专题</a> <a href="/tags/7-SpringBoot/" style="font-size: 1.23em; color: #999ea5">7.SpringBoot</a> <a href="/tags/01/" style="font-size: 1.18em; color: #999ca0">01</a> <a href="/tags/%E5%B0%8F%E8%AE%BA%E6%96%87%E5%87%86%E5%A4%87/" style="font-size: 1.28em; color: #99a0aa">小论文准备</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/" style="font-size: 1.1em; color: #999">代码实现</a> <a href="/tags/Transformer%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" style="font-size: 1.32em; color: #99a2ae">Transformer前世今生</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 1.48em; color: #99a8bd">Java基础</a> <a href="/tags/md/" style="font-size: 1.13em; color: #999a9b">md</a> <a href="/tags/JUC/" style="font-size: 1.45em; color: #99a7ba">JUC</a> <a href="/tags/Spring/" style="font-size: 1.5em; color: #99a9bf">Spring</a> <a href="/tags/JVM/" style="font-size: 1.43em; color: #99a6b8">JVM</a> <a href="/tags/%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86/" style="font-size: 1.1em; color: #999">论文整理</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/" style="font-size: 1.38em; color: #99a4b3">基础篇——韩顺平</a> <a href="/tags/%E6%80%BB%E4%BD%93%E8%A7%84%E5%88%92/" style="font-size: 1.13em; color: #999a9b">总体规划</a> <a href="/tags/vue/" style="font-size: 1.13em; color: #999a9b">vue</a> <a href="/tags/%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0%E6%80%BB%E7%BB%93/" style="font-size: 1.13em; color: #999a9b">论文复现总结</a> <a href="/tags/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/" style="font-size: 1.18em; color: #999ca0">基本方法</a> <a href="/tags/SpringMVC/" style="font-size: 1.28em; color: #99a0aa">SpringMVC</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%AF%87/" style="font-size: 1.3em; color: #99a1ac">基础篇</a> <a href="/tags/back-end/" style="font-size: 1.35em; color: #99a3b1">back-end</a> <a href="/tags/%E8%AE%BA%E6%96%87/" style="font-size: 1.13em; color: #999a9b">论文</a> <a href="/tags/Excalidraw/" style="font-size: 1.1em; color: #999">Excalidraw</a> <a href="/tags/1-%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" style="font-size: 1.25em; color: #999fa7">1.监督学习</a> <a href="/tags/%E6%A8%A1%E5%9E%8B%E6%95%B4%E7%90%86/" style="font-size: 1.1em; color: #999">模型整理</a> <a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/" style="font-size: 1.23em; color: #999ea5">云服务器运行环境</a> <a href="/tags/docker/" style="font-size: 1.1em; color: #999">docker</a> <a href="/tags/%E5%AE%9E%E9%AA%8C/" style="font-size: 1.1em; color: #999">实验</a> <a href="/tags/pytorch%E5%9F%BA%E6%9C%AC%E5%8A%9F/" style="font-size: 1.15em; color: #999b9e">pytorch基本功</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" style="font-size: 1.3em; color: #99a1ac">代码随想录</a> <a href="/tags/communication/" style="font-size: 1.1em; color: #999">communication</a> <a href="/tags/Mybatis/" style="font-size: 1.18em; color: #999ca0">Mybatis</a> <a href="/tags/%E5%B0%8F%E8%AE%BA%E6%96%87%E6%95%85%E4%BA%8B%E7%BA%BF%E5%92%8C%E6%A8%A1%E5%9D%97%E8%AE%B0%E5%BD%95%E7%B4%A0%E6%9D%90/" style="font-size: 1.2em; color: #999da3">小论文故事线和模块记录素材</a> <a href="/tags/%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/" style="font-size: 1.1em; color: #999">基本问题</a> <a href="/tags/SSM%E6%95%B4%E5%90%88/" style="font-size: 1.1em; color: #999">SSM整合</a> <a href="/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/" style="font-size: 1.13em; color: #999a9b">算法基础课</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>归档</span>
      <a class="card-more-btn" href="/archives/"
            title="查看更多">
            <i class="fas fa-angle-right"></i>
          </a>
    </div>
  
    <ul class="card-archive-list">
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2026/02/">
            <span class="card-archive-list-date">
              二月 2026
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2026/01/">
            <span class="card-archive-list-date">
              一月 2026
            </span>
            <span class="card-archive-list-count">5</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/11/">
            <span class="card-archive-list-date">
              十一月 2025
            </span>
            <span class="card-archive-list-count">177</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/10/">
            <span class="card-archive-list-date">
              十月 2025
            </span>
            <span class="card-archive-list-count">199</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/09/">
            <span class="card-archive-list-date">
              九月 2025
            </span>
            <span class="card-archive-list-count">98</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/08/">
            <span class="card-archive-list-date">
              八月 2025
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/07/">
            <span class="card-archive-list-date">
              七月 2025
            </span>
            <span class="card-archive-list-count">39</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/06/">
            <span class="card-archive-list-date">
              六月 2025
            </span>
            <span class="card-archive-list-count">24</span>
          </a>
        </li>
      
    </ul>
  </div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">785</div></div><div class="webinfo-item"><div class="item-name">运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2025-04-05T00:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">1222.8k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总浏览量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2026-02-22T05:57:08.605Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/backgroud.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2026 By yuezi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>window.typedJSFn = {
  init: str => {
    window.typed = new Typed('#subtitle', Object.assign({
      strings: str,
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50,
    }, null))
  },
  run: subtitleType => {
    if (true) {
      if (typeof Typed === 'function') {
        subtitleType()
      } else {
        btf.getScript('https://cdn.jsdelivr.net/npm/typed.js/dist/typed.umd.min.js').then(subtitleType)
      }
    } else {
      subtitleType()
    }
  },
  processSubtitle: (content, extraContents = []) => {
    if (true) {
      const sub = [].slice()

      if (extraContents.length > 0) {
        sub.unshift(...extraContents)
      }

      if (typeof content === 'string') {
        sub.unshift(content)
      } else if (Array.isArray(content)) {
        sub.unshift(...content)
      }

      sub.length > 0 && typedJSFn.init(sub)
    } else {
      document.getElementById('subtitle').textContent = typeof content === 'string' ? content :
        (Array.isArray(content) && content.length > 0 ? content[0] : '')
    }
  }
}
btf.addGlobalFn('pjaxSendOnce', () => { typed.destroy() }, 'typedDestroy')
</script><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      const from = '出自 ' + data.from
      typedJSFn.processSubtitle(data.hitokoto, [from])
    })
    .catch(err => {
      console.error('Failed to get the Hitokoto API:', err)
      typedJSFn.processSubtitle([])
    })
}
typedJSFn.run(subtitleType)
</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>