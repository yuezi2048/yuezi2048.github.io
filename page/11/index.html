<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>yuezi</title><meta name="author" content="yuezi"><meta name="copyright" content="yuezi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="积微者速成">
<meta property="og:type" content="website">
<meta property="og:title" content="yuezi">
<meta property="og:url" content="https://yuezi2048.github.io/page/11/index.html">
<meta property="og:site_name" content="yuezi">
<meta property="og:description" content="积微者速成">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuezi2048.github.io/img/touxiang.jpg">
<meta property="article:author" content="yuezi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuezi2048.github.io/img/touxiang.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuezi2048.github.io/page/11/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?bfb48b678d82bea9f9cc9d59227767e4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"FPH6F2TOJL","apiKey":"06d9ea26c803ba912b4d8e13404ed34d","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'yuezi',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'home'
}</script><link rel="stylesheet" href="/css/backgound.css"><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">785</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">91</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url(/img/backgroud.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yuezi</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="site-info"><h1 id="site-title">yuezi</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts nc" id="recent-posts"><div class="recent-post-items"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/49.Redis%E6%BA%90%E7%A0%81%E5%B7%A7%E5%A6%99%E8%AE%BE%E8%AE%A1%E4%B8%BE%E4%BE%8B/" title="49.Redis源码巧妙设计举例">49.Redis源码巧妙设计举例</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T14:12:26.000Z" title="发表于 2025-10-27 22:12:26">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content"> Redis作为高性能内存数据库，为了更高效的数据处理，以及系统拓展 &#x2F; 性能优化的战未来，这些巧妙的设计提供了一份很好的答卷。  回答方向：线程模型、数据结构、共享对象池、过期设计、数据持久化设计等。  线程模型保证大量并发连接 数据结构优化内存分配，以及相关操作的策略 共享对象池复用数据 过期设计兼顾性能和准确性，设计两种策略 持久化设计：优化持久化的内容，提升持久化操作的效率  线程模型单线程 + 多路IO复用模型（select &#x2F; epoll），减少上下文切换，避免锁的开销，以及多线程编程的复杂性，同时多路IO可以保证大量的并发连接。 数据结构 String —— SDS  hash&#x2F;list&#x2F;zset —— ziplist  hash的渐进式扩容机制   SDS（Simple Dynamic...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/50.Redsson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/" title="50.Redsson分布式锁原理">50.Redsson分布式锁原理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T13:55:34.000Z" title="发表于 2025-10-27 21:55:34">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">Redisson是基于Redis实现的分布式锁，通过Redis的原子操作来保证多线程 &#x2F; 多进程 &#x2F; 多节点的系统中，，只有一个节点能获取到锁，避免并发操作的数据不一致问题。  获取锁：通过lua脚本，exists or  hexists + hincrby  来保证只有一个线程能成功设置键（表示获得锁），通过pexipre设置锁的过期时间，防止宕机等原因导致锁无法释放（死锁） 锁的续期：防止锁在持有过程中过期被其他节点抢占，所以有一个看门狗的自动续期功能，持有锁的线程会自动续期（更新锁的过期时间），保证任务完成时锁不能失效 锁的释放：通过lua脚本保证释放的原子性，hexists + del 保证只释放自己锁对应的线程，防止误释放锁的情况，并通过publish命令，广播唤醒其他等待的线程 可重入锁：持有锁的线程支持多次获取同一把锁而不会被阻塞，具体实现为利用Redis的hash，key为线程ID，如果重入则value + 1，释放则value - 1，减到0了锁门锁被释放，则del锁  扩展知识Redisson 分布式锁 lua...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/51.Zset%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="51.Zset实现原理">51.Zset实现原理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T13:45:33.000Z" title="发表于 2025-10-27 21:45:33">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">ZSet（有序集合，Sorted Set） 组成： 跳表（Skip List）  + 哈希表（Hash Table） 。整合了集合（Set）的特性和排序功能，能够存储具有唯一性的成员，并根据成员的分数（score）进行排序。  跳表（Skip List）：存储数据的排序关系 + 快速（范围）查找，O(logn + m) 哈希表（Hash Table）：存储成员-&gt;分数的映射，O(1)复杂度   注： Zset 元素数量较少时，Redis 会使用压缩列表（Zip List + hashSet）来节省内存，具体是同时满足以下两个条件  即元素个数 ≤ zset-max-ziplist-entries（默认 128） 元素成员名和分值的长度 ≤ zset-max-ziplist-value（默认 64 字节）  如果任何一个条件不满足，Zset 将使用 跳表 + 哈希表 作为底层实现。  扩展知识跳表的实现原理 638. Redis 中跳表的实现原理是什么？  哈希表Redis 使用哈希表来存储 ZSet 中的成员和分数之间的映射关系。哈希表的键是 ZSet...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/52.%E4%B8%BA%E4%BB%80%E4%B9%88ZSet%E4%B8%8D%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E6%88%96B+%E6%A0%91/" title="52.为什么ZSet不用红黑树或B+树">52.为什么ZSet不用红黑树或B+树</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T13:40:09.000Z" title="发表于 2025-10-27 21:40:09">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">为什么不用红黑树？ 跳表相比红黑树更简单：基于概率算法动态生成索引层级，而红黑树需要复杂的旋转操作维护结构，代码实现复杂度高 范围查询更高效：范围查询跳表O(logn)定位起点，然后在原始链表向后遍历即可 结构更灵活：跳表层数和节点结构可以动态调整，基于概率分布调整层数，可以适应不同的数据量（数据量大可以多一些层），红黑树无法调整  为什么不用 B+ 树？ B+树操作更复杂：页合页&#x2F;分裂操作，会产生额外计算 理论上内存开销也比较大：在控制层级情况下，大部分跳表节点只需要维护value和指针（含回退指针），而B+树是多叉树，一个节点多个指针，节点内部还有若干指针（每个元素在叶子节点保存完整内容，非叶子节点存储key的数据）   B+树自身的设计就是比较适合磁盘存储（特别是大规模数据），非叶子节点索引，完整数据在叶子节点中，便于海量数据的快速检索  扩展知识redis 作者对 zset 用跳表实现的原因解释 Is there any particular reason you chose skip list instead of btrees except for...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/53.%E7%9C%8B%E9%97%A8%E7%8B%97%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97/" title="53.看门狗机制了解吗">53.看门狗机制了解吗</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T13:33:05.000Z" title="发表于 2025-10-27 21:33:05">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">看门狗（watchdog）解决的问题是：避免Redis锁超时后，业务逻辑未执行完毕，锁自动释放的情况。通过定时刷新锁的方式来实现自动续期。 核心原理：  定时刷新：如果当前分布式锁未设置过期时间，Redisson基于Netty时间轮开启定时任务，定期向Redis发送命令，更新锁的过期时间（默认每10s请求，续期30s） 释放锁：客户端主动释放锁后，会取消看门狗的刷新操作，如果客户端宕机，定时任务也就不会执行，等超时时间到了，锁也就自动释放了   扩展知识Redisson 看门狗的核心源码分析定时续期的核心涉及以下两个方法：  scheduleExpirationRenewal：这个方法用于在客户端获取到锁后，启动锁的过期续期机制。 renewExpiration：这个方法的作用是定期刷新锁的过期时间（续期），确保锁不会因过期而被其他客户端抢占。  scheduleExpirationRenewal 方法1）创建 ExpirationEntry：首先创建一个新的 ExpirationEntry 对象，用于存储锁的过期信息。 2）putIfAbsent 添加条目：使用...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/40.%E5%A6%82%E4%BD%95%E5%9C%A8Redis%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/" title="40.如何在Redis实现队列和栈">40.如何在Redis实现队列和栈</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:35:36.000Z" title="发表于 2025-10-27 18:35:36">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content"> 队列实现：lpush添加元素，rpop弹出元素。或者rpush添加元素，lpop弹出元素。 栈：一端进行操作，lpush，lpop 或者rpush，rpop。 注意：  阻塞操作brpop&#x2F;blpop list里面不存在元素的时候，pop操作会返回null（超时时间和cpu空转的平衡） 业务代码里面一般用死循环不断的取元素，看是不是空，但如果list里面一直没有元素，会导致cpu空转，性能不好 redis还提供了brpop&#x2F;blpop操作，b就是block的意思，还支持超时时间。可以阻塞等待一段时间，如果还没有元素的话，就返回null，不一直空转。    优先级队列实现： 使用sorted set。分数表示优先级。 zadd添加元素，zpopmin获取优先级最高的元素。  可以通过 List 类型 来实现 队列 和 栈 ： 实现队列（FIFO）：  队列是一种 先进先出（FIFO） 的数据结构。在 Redis 中，可以使用 LPUSH 和 RPOP 命令组合来实现队列。 LPUSH 向列表的左侧推入元素，而 RPOP...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/39.List%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/" title="39.List常见操作命令">39.List常见操作命令</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:33:00.000Z" title="发表于 2025-10-27 18:33:00">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content"> lpush, lpop,llen, lindex, lrange, ltrim 3.2之后，list底层只由quicklist实现，替代了双向链表和压缩链表  Redis 中的 List 类型是一个字符串列表，这里是一些常见的操作命令： 1）lpush：将一个或多个值插入到列表头部。列表不存在，一个新的列表会被创建。 2）rpush：将一个或多个值插入到列表尾部。 3）lpop：移除并返回列表头部的元素。 4）rpop： 移除并返回列表尾部的元素。 5）lrange：获取列表指定范围内的元素。 6）lindex： 通过索引获取列表中的元素。 7）llen： 获取列表长度。 8）lset： 将列表中指定索引的元素设置为另一个值。 9）lrem： 移除列表中与参数匹配的元素。 10）ltrim： 修剪(裁剪)一个已存在的 list，使其只包含指定范围的元素。 示例代码如下： lpush mylist a    # 在列表 &#x27;mylist&#x27; 的头部插入元素 &#x27;a&#x27;rpush mylist b    # 在列表...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/38.%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%B8%B8%E8%A7%81%E6%8B%93%E6%89%91/" title="38.主从复制常见拓扑">38.主从复制常见拓扑</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:32:01.000Z" title="发表于 2025-10-27 18:32:01">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">Redis 主从的几种常见拓扑结构如下（忽略哨兵）：  主从（主写从读），一主多从（减少主节点复制到从节点压力），多主多从（默认不支持，多读多写分散压力）  1）一主多从： 这是最基本的拓扑结构，包含一个主节点和多个从节点。所有写操作都在主节点上执行，而读操作可以在从节点上进行，以提高读取速度和负载均衡。 	 2）树状主从结构（级联）： 从节点也可以作为其他从节点的主节点。这样形成了一个层次结构，主节点负责写操作，而从节点负责读操作，并将数据再次复制到更下一级的从节点。 	 因为主从复制对主节点有压力，所以这样的结构可以减轻主节点的压力。 3）主主结构（双主或多主）： 在这种拓扑中，有两个或多个主节点，它们之间相互复制数据。这种结构提高了系统的写能力和容错性。 	 但需要处理多主节点之间的数据同步和冲突解决，管理复杂度高，Redis 默认不支持主主复制。 扩展知识 651. Redis 主从复制的实现原理是什么？ 650. Redis 的哨兵机制是什么？ 652. Redis 集群的实现原理是什么？  </div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/37.%E5%8E%9F%E7%94%9F%E6%89%B9%E5%A4%84%E7%90%86MSETMGET%E5%AF%B9%E6%AF%94PipLine/" title="37.原生批处理MSETMGET对比PipLine">37.原生批处理MSETMGET对比PipLine</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:31:23.000Z" title="发表于 2025-10-27 18:31:23">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">原生批处理命令（MSET、MGET） 和 Pipeline都是一次处理多个命令，但是在实现和应用场景上不同：  实现 MSET&#x2F;MGET是批量设置和获取 多个kv，是作为单个命令执行的，网络传输是一次RTT PipeLine是允许用户一次性发送多个命令，Redis批量处理命令，将结果依次返回，不是单一的Redis命令，不满足原子性   场景 MSET&#x2F;MGET是多个kv的原子性读写操作 PipeLine是客户端的机制，用于任意类型的Redis操作    扩展知识性能对比 在执行批量操作时，MSET &#x2F; MGET 的执行速度可能比 Pipeline 更快，因为它们是原生支持的批处理命令，并且对于特定任务（批量读写键值）进行了优化。 Pipeline 的优势在于减少客户端和 Redis 之间的网络延迟，在需要执行多种操作（不仅仅是 MSET &#x2F; MGET）时，Pipeline 可以提供更高的灵活性和更好的吞吐量。  使用示例MSET &#x2F; MGET： MSET key1 value1 key2 value2 key3...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/36.EMBSTR%E5%AF%B9%E8%B1%A1%E9%98%88%E5%80%BC%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF44%EF%BC%88%E5%8E%86%E5%8F%B2%E8%B0%83%E6%95%B4%EF%BC%89/" title="36.EMBSTR对象阈值为什么是44（历史调整）">36.EMBSTR对象阈值为什么是44（历史调整）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:27:13.000Z" title="发表于 2025-10-27 18:27:13">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content"> Redis的内存是通过jemalloc进行内存分配，以64字节位阈值来区分字符串raw和EMBSTR RedisObject占用16字节，sdshdr占用4字节（len alloc flags  \0），最终剩余44字节   历史调整：3.2调整了sdshdr的结构，之前的sdshdr5版本是39个字节，之后的版本EMBSTR使用的是sdshdr8的结构，总容量和已使用容量字段少了6个字节，但增加了一个flag字节，所以最后是少了5个字节  为什么 EMBSTR 的阈值大小是 44 个字节？1）Redis 使用的是jemalloc作为内存分配器。 2）jemalloc 是以 64 字节作为内存单位进行内存分配的，如果超过了 64 字节，即超过了一个内存单元，使用的就是 raw 编码，反之使用的就是 EMBSTR 编码。 3）核心就是这个 64 字节，围绕 64 字节这个关键点来分析。Redis 的字符串对象是 redisObject 和 sdshdr 这两个部分组成的，redisObject 大小为 4 + 4 + 24 + 32 + 64 = 128bits = 16...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/35.%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96/" title="35.性能瓶颈怎么优化">35.性能瓶颈怎么优化</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:20:56.000Z" title="发表于 2025-10-27 18:20:56">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content"> 内存扩容：增加Redis配置，容纳更多的内存 如果单机配置不够，可以上Redis主从，从服务分担读数据压力，哨兵进行故障转移   集群：通过Reids Cluster进行数据分片 多级缓存  扩展知识redis 主从复制和读写分离通过配置 Redis 主从复制，可以实现读写分离，将写操作交给主节点进行处理，而读操作可以交给从节点，从而减轻主节点的压力。 主从架构的优势在于可以横向扩展读取能力，但是存在主从同步延迟的问题，如果从节点落后较多，可能会出现读取旧数据的情况。  651. Redis 主从复制的实现原理是什么？ 650. Redis 的哨兵机制是什么？  redis 集群 652. Redis 集群的实现原理是什么？  </div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/34.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%9C%80%E5%A4%A7%E5%80%BC/" title="34.字符串类型最大值">34.字符串类型最大值</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:18:44.000Z" title="发表于 2025-10-27 18:18:44">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">512MB 	 无论是网络传输、内存分配还是字符串操作，大字符串都会增加 Redis 服务器的负载。 且过大的字符串在 GET、SET、APPEND、STRLEN 等操作都会导致性能瓶颈。 所以官方给字符串的大小做了限制，防止单个键值对占用过多的内存，影响整体性能和稳定性。  注：不建议存储大于2MB的在字符串,因为大于2MB的字符串属于big Key   661. Redis String 类型的底层实现是什么？  </div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/33.%E9%A1%B9%E7%9B%AE%E7%9A%84Redis%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%94%A8%E4%BB%80%E4%B9%88/" title="33.项目的Redis客户端用什么">33.项目的Redis客户端用什么</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:14:02.000Z" title="发表于 2025-10-27 18:14:02">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">常见在项目中使用的客户端有以下三种：  Jedis ：简单的同步 &#x2F; 单线程 环境 Lettuce ：高性能 &#x2F; 高并发 &#x2F; 多线程，特别是异步 &#x2F; 响应式编程的场景 Redisson：复杂的分布式系统，提供丰富的分布式对象和服务，简化开发。  JedisJedis 是一款比较经典的 Java 客户端了，里面提供了比较全面的 Redis 命令，也是使用最为广泛的 Redis 客户端。 Jedis 是一个用 Java 实现的 Redis 客户端库，它具有以下优点：  简单易用：提供了直观的 API，使得开发者能够方便地与 Redis 进行交互。 使用广泛：在 Java 社区中被广泛采用，有丰富的文档和示例可供参考。 性能良好：在大多数情况下能够提供高效的 Redis 操作。 功能丰富：支持常见的 Redis 操作，如字符串、列表、哈希、集合等数据结构的操作。  然而，Jedis 也存在一些缺点：  线程安全问题：线程不安全，每个线程需独立使用 Jedis 实例。 不支持自动重连：在网络异常或 Redis...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/32.GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="32.GEO数据结构">32.GEO数据结构</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:10:08.000Z" title="发表于 2025-10-27 18:10:08">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content"> Geo（Geolocation 地理坐标）数据结构是地理位置信息的存储（GEOSEARCH），方便进行地理位置的存储、检索，同时可以计算地理距离等，底层使用Sorted Set，并结合GeoHash算法对地理位置进行处理  它是 Redis 2.2 版本后新增的数据类型  扩展知识Geo 常用命令GEOADD key longitude latitude member：  将地理坐标信息添加到 Redis 中。例如：GEOADD locations 13.361389 38.115556 “mianshiya”。  GEODIST key member1 member2 [unit]：  计算两个地理位置之间的距离，单位可以是 m（米）、km（公里）、mi（英里）等。例如：GEODIST locations “mianshiya” “mianshiya1” km。  GEORADIUS key longitude latitude radius unit：  查找指定位置附近指定范围内的所有点。例如：GEORADIUS locations 15 37 200 km...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/31.%E7%BB%9F%E8%AE%A1%E5%A4%A7%E9%87%8F%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E9%87%8FUV/" title="31.统计大量用户访问量UV">31.统计大量用户访问量UV</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:07:45.000Z" title="发表于 2025-10-27 18:07:45">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">通过HyperLogLog实现——网页UV&#x2F;PV场景，是基于基数估计算法的概率数据结构，用极少的内存统计海量用户唯一访问量的近似值。  注：Set也可以实现，且更精细，但当用户量访问大时，内存开销较大  扩展知识HyperLogLog 使用介绍HyperLogLog 具有极小的内存占用（每个 HyperLogLog 结构约 12 KB），而允许一定的误差（通常在 0.81% 以内）。即使统计数百万用户，内存开销依然是恒定的（约 12 KB），非常适合海量数据场景。 HyperLogLog 的基本操作：  PFADD key element [element ...]：将一个或多个元素添加到 HyperLogLog 数据结构中。 PFCOUNT key [key ...]：返回 HyperLogLog 结构中不重复元素的近似数量。 PFMERGE destkey sourcekey [sourcekey ...]：将多个 HyperLogLog 合并为一个。  以下是一个示例代码，展示在 Java 中如何使用 Redis 的 HyperLogLog 实现页面 UV...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/30.%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" title="30.快速实现布隆过滤器">30.快速实现布隆过滤器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T10:05:47.000Z" title="发表于 2025-10-27 18:05:47">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content"> 布隆过滤器是一种高效的概率数据结构，用于判断元素是否存在于一个集合中，可以减少数据库的查询次数，避免缓存穿透等问题  具体实现方式：  位图（Bitmap）  SETBIT &#x2F; GETBIT操作实现布隆过滤器，本质上是在比特数组上标识元素是否存在 给定数据，通过多个哈希函数计算索引，对应位图的位置设置为1，表示元素存在   RedisBloom  Redis官方提供的模块，封装了哈希函数、位图大小等操作，可以直接创建和管理布隆过滤器  具体通过BF.ADD向布隆过滤器添加元素，BF.EXISTS检查某个元素是否存在    扩展知识布隆过滤器原理布隆过滤器组成：位数组 + 多个哈希函数  添加位置：...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/27/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/29.%E5%AE%9E%E7%8E%B0%E6%8E%92%E8%A1%8C%E6%A6%9C/" title="29.实现排行榜">29.实现排行榜</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-27T09:53:05.000Z" title="发表于 2025-10-27 17:53:05">2025-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">通过**Sorted Set（有序集合）**实现，进行存储、更新和获取排名信息  存储分数和成员：ZADD命令。ZADD leaderboard 1000 user1 获取排名：ZRANK命令，ZRAND leaderboard user1，返回user1的排名（从0开始） 获取TopN：ZREVRANGE得到分数最高的前N名，ZREVRANGE leaderboard 0 9 WITHSCORES，得到前10名的用户和分数 更新分数：ZINCRBY命令对分数加减，ZINCRBY leaderboard 500 user1，对user1的分数增加500  扩展知识Sorted Set 的特点 内部基于**跳表（Skip List）**实现，每个成员有唯一的score，按照分数进行排序 Sorted Set的插入、更新和删除时间复杂度是O(log N)，支持快速查询制定区间的数据 Sorted Set保证成员的唯一性，如果插入相同的成员，ZADD会更新分数而不是重复插入  Sorted Set 相关 Redis...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/23/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/28.String%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%88SDS%EF%BC%89/" title="28.String的底层实现">28.String的底层实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-23T14:58:56.000Z" title="发表于 2025-10-23 22:58:56">2025-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">Redis 的 String 类型底层是基于 SDS（Simple Dynamic String 简单动态字符串）结构，并结合 int、embstr、raw 等不同的编码方式进行优化存储。 扩展 相比于C语言标准字符串，SDS做的优化：simple dynamic（操作简单 + 动态扩展）  加入了自定义结构 + 长度 + 分配空间元信息，去除了C语言固有的\0结尾，并且长度不需要遍历得到 动态拓展内存，预留额外空间的预分配内存策略 C语言字符串操作函数不高效且不安全，比如缓冲区溢出，其可能导致程序异常终止   引入了 int、embstr、raw 更多自定义结构   名称入手，simple操作的结构 + dynamic内存 + 类型的优化     特性 SDS（Redis 动态字符串） C语言原生字符串    结构 自定义结构，包含长度、分配空间等元信息 以 \0 结尾的字符数组   长度记录 独立记录字符串长度，获取长度为 O(1) 通过遍历计算字符串长度，获取长度为 O(n)   二进制安全 支持任意二进制数据，包括 \0 不支持，遇到 \0...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/23/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/27.%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4/" title="27.如何保证缓存和数据库数据一致">27.如何保证缓存和数据库数据一致</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-23T14:45:57.000Z" title="发表于 2025-10-23 22:45:57">2025-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">方案（不推荐）：  更新缓存，再更新数据库 更新数据库，再更新缓存 先删除缓存，再更新数据库，后续查询数据库回种缓存  方案（根据实际业务选择）：  缓存双删策略：先删除缓存，更新数据库，再延迟删除缓存 先写数据库，再删除缓存，后续查询数据库回种缓存（允许一定时间的不一致，但保证最终一致性）   缓存更新策略上来说，称为Cache...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/23/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/26.%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF_%E7%A9%BF%E9%80%8F_%E9%9B%AA%E5%B4%A9/" title="26.缓存击穿_穿透_雪崩">26.缓存击穿_穿透_雪崩</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-23T14:06:33.000Z" title="发表于 2025-10-23 22:06:33">2025-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/23/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/25.%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98/" title="25.实现分布式锁要考虑的问题">25.实现分布式锁要考虑的问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-23T13:53:14.000Z" title="发表于 2025-10-23 21:53:14">2025-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">思考方向：死锁 &#x2F;  并发冲突——&gt;数据不一致   业务互斥操作（锁的互斥性） 锁到期释放，但业务未执行完：Ridisson 看门狗续约 误释放锁问题：lua【id判断+释放】 可重入性问题：线程ID计数器（避免死锁）   脑裂 网络分区问题：参数优化   单点故障 单点故障问题：主从 + 哨兵 主从问题不同步：红锁 时钟漂移问题：NTP同步       问题 描述 解决方案    锁到期问题 锁的超时时间到期，但业务尚未执行完成，导致锁提前释放，其他线程可能错误地获取锁，导致并发问题。 使用 Watchdog 机制动态续期锁，确保锁在持有者未主动释放时不会提前失效。避免手动设置过长的超时时间以防降低并发度。   单点故障问题 使用单节点 Redis 时，若 Redis 宕机或不可用，分布式锁将无法正常工作，影响业务的正常执行。 使用 Redis 哨兵模式或集群模式，提升 Redis 的高可用性；或使用 RedLock...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/23/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/24.Red_Lock/" title="24.Red_Lock">24.Red_Lock</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-23T13:40:42.000Z" title="发表于 2025-10-23 21:40:42">2025-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">红锁Red Lock是分布式锁的一种实现方案，用来解决分布式锁的安全问题。 我们一般在生产环境会使用主从+哨兵方式来部署 Redis 但是会存在问题：主从切换过程中，从节点不一定同步主节点的锁信息  此时新的主节点没有锁的信息，会允许另一个业务拿锁执行业务逻辑 那么就会导致两个业务同时操作临界资源，进而发生数据不一致的问题  Redis官方引出红锁来避免该情况发生，及时部分节点发送故障也不影响锁的使用和数据问题的发生。 拓展 要实现红锁，官方推荐至少要5个实例（不需要部署从库和哨兵，只需主库），这5个实例没有任何关系（区别于cluster），他们之间没有任何信息交互。 客户端会依次对5个实例加锁，如果申请成功数量超过一半（&gt;&#x3D;3），那么申请成功，否则失败。  此时如果一台实例宕机了，不会有任何影响，因为理论上能申请成功的数量有4个，超过了半数。 也因为没有主从机制，不会有同步丢失锁的问题。  具体加锁流程如下：  客户端获取当前时间...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/23/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/23.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%9C%A8%E6%9C%AA%E5%AE%8C%E6%88%90%E5%89%8D%E5%B0%B1%E8%BF%87%E6%9C%9F%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/" title="23.分布式锁在未完成前就过期了怎么办">23.分布式锁在未完成前就过期了怎么办</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-23T12:57:34.000Z" title="发表于 2025-10-23 20:57:34">2025-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">未完成就过期，会导致数据不一致。此时另一个客户端会争抢到锁，这样会导致两个客户端同时业务操作，相当于锁失效。 解决方案：定时续期锁（如看门狗机制），保证在处理过程中锁不能过期 	    拓展 看门狗可以实现定时续期的功能：  抢到锁后，后台会新建定时的锁续期任务 锁过期时间是30s，那么10s（1&#x2F;3）后会重新设定为30s   当任务执行完后，移除定时任务   在鱼泡项目的debug过程中，看门狗也不会生效  	    redissonredisson 封装了很多 redis 操作，便于我们使用。  redisson分布式锁引入了看门狗机制，具体原理也是基于 Netty 的时间轮实现的定时任务，。 redisson 支持可重入锁，即同一个线程可以多次获取同一个分布式锁，且不会导致死锁。实现方法如下： 获取锁时，检查当前锁唯一标识是否是当前线程 如果是，则增加重入计数器   释放锁后，减少重入计数器，只有当计数器为0时才认为是真正释放了锁。  拓展：  《时间轮》  </div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/23/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/22.%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="22.实现分布式锁">22.实现分布式锁</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-23T12:47:29.000Z" title="发表于 2025-10-23 20:47:29">2025-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">实现思路：set nx + lua脚本，保证：  多个客户端不会获得同一个资源锁（nx）  安全解锁（过期）  意外情况下锁的自动释放（通过lua原子实现：判断唯一key  + 释放）   拓展 具体来看：  加锁：SET lock_key uniqueValue EX expire_time NX   过期时间EX：避免客户端拿锁后宕机，导致其他客户端拿不到锁（PX是毫秒） 2.6.12后支持setnx+ex原子操作   uniqueValue：避免锁被其他客户端释放，这里需要用到lua脚本来原子执行判断+删除逻辑 客户端1拿到锁后，但是执行时间超过过期时间，锁释放后被客户端2拿到，客户端2执行业务逻辑的过程中，客户端1执行完释放掉锁 导致：客户端2的锁被客户端1释放     解锁：lua 脚本实现——通过 get 获取 key 的 value 判断锁是否是自己加的，如果是则 del。   if redis.call(&quot;GET&quot;,KEYS[1]) == ARGV[1]then    return...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/23/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/21.%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E5%8A%9F%E8%83%BD/" title="21.订阅发布功能">21.订阅发布功能</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-23T12:30:53.000Z" title="发表于 2025-10-23 20:30:53">2025-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Redis/">Redis</a></span></div><div class="content">**订阅发布功能（ Pub&#x2F;Sub）**是一种消息通信机制，实现不同客户端之间消息的实时传递 &#x2F; 广播。 在pub&#x2F;sub模型下，客户端可订阅一个&#x2F;多个频道，当其他客户端向这些频道推送信息时，所有订阅该频道的客户端会立即收到消息，具体来说：  发布（Publish）：客户端向指定频道发布消息。 订阅（Subscribe）：一个或多个客户端订阅指定的频道，并在频道接收到消息时立刻获取该消息。  拓展 pub&#x2F;sub是消息队列的一种通信模型，生产者pub发送消息，订阅者sub接收消息。  发布者向一个或者多个频道发布消息，订阅者可以订阅一个或者多个频道所发布的消息。  	 使用： publish channel message  订阅频道后，就可以实时消费发布者的消息了：  1表示订阅成功，message就是后续的消息，之后的channel表示订阅频道  subscribe channel   	    支持消费者阻塞式拉取消息，另外还提供了匹配订阅，消费者可以根据一定的规则，订阅多个队列。 例如subscribe...</div></div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/10/#content-inner"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/#content-inner">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/#content-inner">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/#content-inner">32</a><a class="extend next" rel="next" href="/page/12/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yuezi</div><div class="author-info-description">积微者速成</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">785</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">91</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuezi2048"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">积微者速成</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/22/Excalidraw/Drawing%202024-11-01%2015.37.37.excalidraw/" title="Drawing 2024-11-01 15.37.37.excalidraw">Drawing 2024-11-01 15.37.37.excalidraw</a><time datetime="2026-02-22T05:56:41.839Z" title="发表于 2026-02-22 13:56:41">2026-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/22/2.Areas%F0%9F%8C%90/01.project/condefather/yupao/back-end/7.%E4%BC%98%E5%8C%96%E4%B8%BB%E9%A1%B5%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/" title="7.优化主页性能-优化批量导入数据">7.优化主页性能-优化批量导入数据</a><time datetime="2026-02-22T05:56:41.257Z" title="发表于 2026-02-22 13:56:41">2026-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/31/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/5.%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8/" title="5.工具调用">5.工具调用</a><time datetime="2026-01-31T03:54:22.000Z" title="发表于 2026-01-31 11:54:22">2026-01-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/30/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/4.RAG%E8%BF%9B%E9%98%B6/" title="4.RAG进阶">4.RAG进阶</a><time datetime="2026-01-30T13:23:42.000Z" title="发表于 2026-01-30 21:23:42">2026-01-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/3.RAG/" title="3.RAG">3.RAG</a><time datetime="2026-01-27T09:06:56.000Z" title="发表于 2026-01-27 17:06:56">2026-01-27</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
      <i class="fas fa-angle-right"></i></a>
          </div>
          <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/0-InBox%F0%9F%90%AD/"><span class="card-category-list-name">0.InBox🐭</span><span class="card-category-list-count">2</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/0-InBox%F0%9F%90%AD/md/"><span class="card-category-list-name">md</span><span class="card-category-list-count">2</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/"><span class="card-category-list-name">2.Areas🌐</span><span class="card-category-list-count">766</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/00-%E7%A7%8B%E6%8B%9B%E5%87%86%E5%A4%87%E6%96%B9%E5%90%91/"><span class="card-category-list-name">00.秋招准备方向</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/"><span class="card-category-list-name">01.project</span><span class="card-category-list-count">25</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/"><span class="card-category-list-name">condefather</span><span class="card-category-list-count">25</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/tuku/"><span class="card-category-list-name">tuku</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/2-Areas%F0%9F%8C%90/01-project/condefather/user-center/"><span class="card-category-list-name">user-center</span><span class="card-category-list-count">9</span></a></li></ul></li></ul></li></ul></li>
          </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/3-JDBC/" style="font-size: 1.15em; color: #999b9e">3.JDBC</a> <a href="/tags/Github/" style="font-size: 1.13em; color: #999a9b">Github</a> <a href="/tags/front-end/" style="font-size: 1.1em; color: #999">front-end</a> <a href="/tags/%E8%AE%BA%E6%96%87%E6%A2%B3%E7%90%86/" style="font-size: 1.4em; color: #99a5b6">论文梳理</a> <a href="/tags/condefather/" style="font-size: 1.1em; color: #999">condefather</a> <a href="/tags/5-Maven%E4%B8%93%E9%A2%98/" style="font-size: 1.13em; color: #999a9b">5.Maven专题</a> <a href="/tags/7-SpringBoot/" style="font-size: 1.23em; color: #999ea5">7.SpringBoot</a> <a href="/tags/01/" style="font-size: 1.18em; color: #999ca0">01</a> <a href="/tags/%E5%B0%8F%E8%AE%BA%E6%96%87%E5%87%86%E5%A4%87/" style="font-size: 1.28em; color: #99a0aa">小论文准备</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/" style="font-size: 1.1em; color: #999">代码实现</a> <a href="/tags/Transformer%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" style="font-size: 1.32em; color: #99a2ae">Transformer前世今生</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 1.48em; color: #99a8bd">Java基础</a> <a href="/tags/md/" style="font-size: 1.13em; color: #999a9b">md</a> <a href="/tags/JUC/" style="font-size: 1.45em; color: #99a7ba">JUC</a> <a href="/tags/Spring/" style="font-size: 1.5em; color: #99a9bf">Spring</a> <a href="/tags/JVM/" style="font-size: 1.43em; color: #99a6b8">JVM</a> <a href="/tags/%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86/" style="font-size: 1.1em; color: #999">论文整理</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/" style="font-size: 1.38em; color: #99a4b3">基础篇——韩顺平</a> <a href="/tags/%E6%80%BB%E4%BD%93%E8%A7%84%E5%88%92/" style="font-size: 1.13em; color: #999a9b">总体规划</a> <a href="/tags/vue/" style="font-size: 1.13em; color: #999a9b">vue</a> <a href="/tags/%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0%E6%80%BB%E7%BB%93/" style="font-size: 1.13em; color: #999a9b">论文复现总结</a> <a href="/tags/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/" style="font-size: 1.18em; color: #999ca0">基本方法</a> <a href="/tags/SpringMVC/" style="font-size: 1.28em; color: #99a0aa">SpringMVC</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%AF%87/" style="font-size: 1.3em; color: #99a1ac">基础篇</a> <a href="/tags/back-end/" style="font-size: 1.35em; color: #99a3b1">back-end</a> <a href="/tags/%E8%AE%BA%E6%96%87/" style="font-size: 1.13em; color: #999a9b">论文</a> <a href="/tags/Excalidraw/" style="font-size: 1.1em; color: #999">Excalidraw</a> <a href="/tags/1-%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" style="font-size: 1.25em; color: #999fa7">1.监督学习</a> <a href="/tags/%E6%A8%A1%E5%9E%8B%E6%95%B4%E7%90%86/" style="font-size: 1.1em; color: #999">模型整理</a> <a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/" style="font-size: 1.23em; color: #999ea5">云服务器运行环境</a> <a href="/tags/docker/" style="font-size: 1.1em; color: #999">docker</a> <a href="/tags/%E5%AE%9E%E9%AA%8C/" style="font-size: 1.1em; color: #999">实验</a> <a href="/tags/pytorch%E5%9F%BA%E6%9C%AC%E5%8A%9F/" style="font-size: 1.15em; color: #999b9e">pytorch基本功</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" style="font-size: 1.3em; color: #99a1ac">代码随想录</a> <a href="/tags/communication/" style="font-size: 1.1em; color: #999">communication</a> <a href="/tags/Mybatis/" style="font-size: 1.18em; color: #999ca0">Mybatis</a> <a href="/tags/%E5%B0%8F%E8%AE%BA%E6%96%87%E6%95%85%E4%BA%8B%E7%BA%BF%E5%92%8C%E6%A8%A1%E5%9D%97%E8%AE%B0%E5%BD%95%E7%B4%A0%E6%9D%90/" style="font-size: 1.2em; color: #999da3">小论文故事线和模块记录素材</a> <a href="/tags/%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/" style="font-size: 1.1em; color: #999">基本问题</a> <a href="/tags/SSM%E6%95%B4%E5%90%88/" style="font-size: 1.1em; color: #999">SSM整合</a> <a href="/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/" style="font-size: 1.13em; color: #999a9b">算法基础课</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>归档</span>
      <a class="card-more-btn" href="/archives/"
            title="查看更多">
            <i class="fas fa-angle-right"></i>
          </a>
    </div>
  
    <ul class="card-archive-list">
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2026/02/">
            <span class="card-archive-list-date">
              二月 2026
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2026/01/">
            <span class="card-archive-list-date">
              一月 2026
            </span>
            <span class="card-archive-list-count">5</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/11/">
            <span class="card-archive-list-date">
              十一月 2025
            </span>
            <span class="card-archive-list-count">177</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/10/">
            <span class="card-archive-list-date">
              十月 2025
            </span>
            <span class="card-archive-list-count">199</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/09/">
            <span class="card-archive-list-date">
              九月 2025
            </span>
            <span class="card-archive-list-count">98</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/08/">
            <span class="card-archive-list-date">
              八月 2025
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/07/">
            <span class="card-archive-list-date">
              七月 2025
            </span>
            <span class="card-archive-list-count">39</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/06/">
            <span class="card-archive-list-date">
              六月 2025
            </span>
            <span class="card-archive-list-count">24</span>
          </a>
        </li>
      
    </ul>
  </div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">785</div></div><div class="webinfo-item"><div class="item-name">运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2025-04-05T00:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">1222.8k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总浏览量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2026-02-22T05:57:08.605Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/backgroud.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2026 By yuezi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>window.typedJSFn = {
  init: str => {
    window.typed = new Typed('#subtitle', Object.assign({
      strings: str,
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50,
    }, null))
  },
  run: subtitleType => {
    if (true) {
      if (typeof Typed === 'function') {
        subtitleType()
      } else {
        btf.getScript('https://cdn.jsdelivr.net/npm/typed.js/dist/typed.umd.min.js').then(subtitleType)
      }
    } else {
      subtitleType()
    }
  },
  processSubtitle: (content, extraContents = []) => {
    if (true) {
      const sub = [].slice()

      if (extraContents.length > 0) {
        sub.unshift(...extraContents)
      }

      if (typeof content === 'string') {
        sub.unshift(content)
      } else if (Array.isArray(content)) {
        sub.unshift(...content)
      }

      sub.length > 0 && typedJSFn.init(sub)
    } else {
      document.getElementById('subtitle').textContent = typeof content === 'string' ? content :
        (Array.isArray(content) && content.length > 0 ? content[0] : '')
    }
  }
}
btf.addGlobalFn('pjaxSendOnce', () => { typed.destroy() }, 'typedDestroy')
</script><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      const from = '出自 ' + data.from
      typedJSFn.processSubtitle(data.hitokoto, [from])
    })
    .catch(err => {
      console.error('Failed to get the Hitokoto API:', err)
      typedJSFn.processSubtitle([])
    })
}
typedJSFn.run(subtitleType)
</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>