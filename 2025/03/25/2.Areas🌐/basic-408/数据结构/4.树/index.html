<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>4.树 | yuezi</title><meta name="author" content="yuezi"><meta name="copyright" content="yuezi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="〇、前置知识——递归 递归：某个函数直接或间接的调用自身（递进 回归）  （基于栈实现）   递归的本质：函数调用（创建副本）  如何理解递归代码：画出递归调用图  递归函数组成  递归出口 &#x2F; 终止条件 &#x2F; 边界条件：停止递归调用的条件（避免栈溢出 &#x2F; 爆内存） 特别注意：这里往往出问题（条件找错 &#x2F; 没找全条件）   递归体   解决的问题  如果一个问">
<meta property="og:type" content="article">
<meta property="og:title" content="4.树">
<meta property="og:url" content="https://yuezi2048.github.io/2025/03/25/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E6%A0%91/index.html">
<meta property="og:site_name" content="yuezi">
<meta property="og:description" content="〇、前置知识——递归 递归：某个函数直接或间接的调用自身（递进 回归）  （基于栈实现）   递归的本质：函数调用（创建副本）  如何理解递归代码：画出递归调用图  递归函数组成  递归出口 &#x2F; 终止条件 &#x2F; 边界条件：停止递归调用的条件（避免栈溢出 &#x2F; 爆内存） 特别注意：这里往往出问题（条件找错 &#x2F; 没找全条件）   递归体   解决的问题  如果一个问">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuezi2048.github.io/img/touxiang.jpg">
<meta property="article:published_time" content="2025-03-25T14:13:00.000Z">
<meta property="article:modified_time" content="2025-03-25T14:13:00.000Z">
<meta property="article:author" content="yuezi">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuezi2048.github.io/img/touxiang.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "4.树",
  "url": "https://yuezi2048.github.io/2025/03/25/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E6%A0%91/",
  "image": "https://yuezi2048.github.io/img/touxiang.jpg",
  "datePublished": "2025-03-25T14:13:00.000Z",
  "dateModified": "2025-03-25T14:13:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "yuezi",
      "url": "https://yuezi2048.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuezi2048.github.io/2025/03/25/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E6%A0%91/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?bfb48b678d82bea9f9cc9d59227767e4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"FPH6F2TOJL","apiKey":"06d9ea26c803ba912b4d8e13404ed34d","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '4.树',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/backgound.css"><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">603</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yuezi</span></a><a class="nav-page-title" href="/"><span class="site-name">4.树</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">4.树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-25T14:13:00.000Z" title="发表于 2025-03-25 22:13:00">2025-03-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-25T14:13:00.000Z" title="更新于 2025-03-25 22:13:00">2025-03-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/basic-408/">basic-408</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">14.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>62分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="〇、前置知识——递归"><a href="#〇、前置知识——递归" class="headerlink" title="〇、前置知识——递归"></a>〇、前置知识——递归</h1><ul>
<li><p>递归：某个函数直接或间接的调用自身（递进 回归）</p>
<ul>
<li>（基于栈实现）</li>
</ul>
</li>
<li><p>递归的本质：函数调用（创建副本）</p>
</li>
<li><p>如何理解递归代码：画出<code>递归调用图</code></p>
</li>
<li><p>递归函数组成</p>
<ul>
<li>递归出口 &#x2F; 终止条件 &#x2F; 边界条件：停止递归调用的条件（避免栈溢出 &#x2F; 爆内存）<ul>
<li>特别注意：这里往往出问题（条件找错 &#x2F; 没找全条件）</li>
</ul>
</li>
<li>递归体</li>
</ul>
</li>
<li><p>解决的问题</p>
<ul>
<li>如果一个问题能分成若干个小问题，并且小问题的解决思路和大问题一样</li>
<li>大问题和小问题的数据规模不一样</li>
</ul>
</li>
<li><p>开发中怎么写递归函数</p>
<ul>
<li>写的时候不要往深层次想执行过程，只需要知道函数解决什么问题的（一次递归的结果），该怎么分配子问题<ul>
<li>即编码的时候更多的看成是黑盒问题而不是白盒问题，验证和复盘的时候可以追究白盒</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 累加问题 1 + 2 + 3 + ... + n</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	5</span></span><br><span class="line"><span class="comment">	15</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = n + <span class="built_in">add</span>(n - <span class="number">1</span>); <span class="comment">// 递归体</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = <span class="built_in">add</span>(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240926174434912.png" alt="image-20240926174434912">	</p>
<ul>
<li>递归：只是一种代码的形式</li>
<li>任何一个递归的代码，可以转化为非递归形式<ul>
<li>大部分情况下要借用栈实现，一些简单的可以通过循环等方式转换为非递归形式</li>
</ul>
</li>
<li>开发中尽量不要用递归（开发手册），刷题经常用</li>
<li>尾递归优化：编译器层面的优化（递归函数最后一句 被调用的函数 覆盖掉，不是所有的编译器支持）</li>
</ul>
<h1 id="一、树的概念和存储方式"><a href="#一、树的概念和存储方式" class="headerlink" title="一、树的概念和存储方式"></a>一、树的概念和存储方式</h1><p>非线性逻辑结构：树型逻辑结构（一对多）、图型逻辑结构（多对多）</p>
<h2 id="1-1-树的概念"><a href="#1-1-树的概念" class="headerlink" title="1.1 树的概念"></a>1.1 树的概念</h2><p>树的概念和术语（理解就行，不用背）</p>
<ul>
<li>树（Tree）是n（n≥0）个节点的有限集合T，它满足两个条件 ：<ul>
<li>有且仅有一个特定的称为根（Root）的节点</li>
<li>其余的节点可以分为m（m≥0）个互不相交的有限集合T1、T2、……、Tm，其中每一个集合又是一棵树，<br>并称为其根的子树（Subtree）</li>
<li>树的定义具有递归性，即“树中还有树”。</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241005193910861.png" alt="image-20241005193910861">	</p>
<ul>
<li>节点：把每个数据都存放在树中的一个结点中</li>
<li>根节点：没有前驱节点</li>
<li>叶子节点：没有后继节点（后继节点为空）</li>
<li>节点之间的关系：父子关系、兄弟关系<ul>
<li>父亲节点、孩子节点、兄弟节点（相对而言）</li>
<li>狭义上的兄弟节点：亲兄弟，广义上的兄弟节点：堂兄弟 表兄弟 在同一层上（本书默认）</li>
</ul>
</li>
<li>度<ul>
<li>节点的度：节点（直接）孩子的个数</li>
<li>树的度：树中所有节点的度的最大值</li>
<li>n叉树：度为n的树，在n叉树中，每个节点最多有n个（直接）孩子<ul>
<li>思考一下 度为2的树 vs 二叉树</li>
</ul>
</li>
<li>高度和深度：高度是从下往上数，深度是从上往下数，数值一样，都是树的层数</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241005205923422.png" alt="image-20241005205923422">	</p>
<blockquote>
<p>结点A的度：3 结点B的度：2 结点M的度：0<br>结点A的孩子：B C D 结点B的孩子：E F<br>树的度：3 树的深度：4<br>叶子结点：K L F G M I J<br>结点A是结点F的祖先<br>结点F是结点K的叔叔结点  </p>
</blockquote>
<h2 id="1-2-树的存储方式"><a href="#1-2-树的存储方式" class="headerlink" title="1.2 树的存储方式"></a>1.2 树的存储方式</h2><p>存储树：树中的数据 —&gt; 数组</p>
<p>存储数据之间的关系（兄弟 &#x2F; 父子） —&gt;  有三种表示方式</p>
<h3 id="1-2-1-双亲表示法"><a href="#1-2-1-双亲表示法" class="headerlink" title="1.2.1 双亲表示法"></a>1.2.1 双亲表示法</h3><ul>
<li>双亲表示法：数据之间的父子关系，指明节点的父亲x下标即可</li>
<li>特点分析：<ul>
<li>根结点没有双亲，所以位置域设置为-1</li>
<li>知道一个结点，<strong>找他的父结点，非常容易</strong>，O(1)级</li>
<li>找孩子节点，必须遍历整个表</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241005201042255.png" alt="image-20241005201042255">	</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">char</span> data; <span class="comment">// 节点数据</span></span><br><span class="line">    <span class="type">int</span> fi; <span class="comment">// 父亲节点下标</span></span><br><span class="line">&#125;t[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size; <span class="comment">// 记录树的节点个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initTree</span><span class="params">(<span class="type">char</span> root)</span> </span>&#123;</span><br><span class="line">    t[<span class="number">0</span>].data = root;</span><br><span class="line">    t[<span class="number">0</span>].fi = <span class="number">-1</span>;</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> fx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i].data == fx) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> x, <span class="type">char</span> fx)</span> </span>&#123;</span><br><span class="line">    t[size].data = x;</span><br><span class="line">    t[size].fi = <span class="built_in">find</span>(fx);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> root;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;root);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">initTree</span>(root);</span><br><span class="line">    <span class="type">char</span> x, fx; <span class="comment">// x的父亲是fx</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 读入数据和父亲节点，注意给出的父亲节点要存在</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c&quot;</span>, &amp;x, &amp;fx);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">insert</span>(x, fx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;x);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到x的父亲节点</span></span><br><span class="line">        <span class="type">int</span> xIndex = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">int</span> fi = t[xIndex].fi;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fi == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No parent node.\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent node: %c\n&quot;</span>, t[fi].data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到x的孩子节点</span></span><br><span class="line">        <span class="type">int</span> child_num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i].fi == xIndex) &#123;</span><br><span class="line">                child_num ++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child node: %c\n&quot;</span>, t[i].data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (child_num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No child node. This is a leaf node.\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Total %d child nodes.\n&quot;</span>, child_num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">R</span></span><br><span class="line"><span class="comment">A R</span></span><br><span class="line"><span class="comment">B R</span></span><br><span class="line"><span class="comment">C R</span></span><br><span class="line"><span class="comment">D A</span></span><br><span class="line"><span class="comment">E A</span></span><br><span class="line"><span class="comment">F C</span></span><br><span class="line"><span class="comment">G F</span></span><br><span class="line"><span class="comment">H F</span></span><br><span class="line"><span class="comment">K F</span></span><br><span class="line"><span class="comment">B</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="1-2-2-孩子表示法"><a href="#1-2-2-孩子表示法" class="headerlink" title="1.2.2 孩子表示法"></a>1.2.2 孩子表示法</h3><p>数据之间的父子关系：指明某个节点的孩子是谁即可</p>
<ul>
<li>子表示法存储普通树采用的是 “顺序表+链表” 的组合结构。</li>
<li>其存储过程是：从树的根节点开始，使用顺序表依次存储树中各个节点。需要注意，与双亲表示法不同的是，孩子表示法会给各个节点配备一个链表，用于存储各节点的孩子节点位于顺序表中的位置。</li>
<li>如果节点没有孩子节点（叶子节点），则该节点的链表为空链表  </li>
<li>使用孩子表示法存储的树结构，正好和双亲表示法相反，查找孩子结点的效率很高，而不擅长做查找父结点的操作。</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241005220021878.png" alt="image-20241005220021878">	</p>
<p>我们还可以将双亲表示法和孩子表示法合二为一：  </p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241005220533149.png" alt="image-20241005220533149">	</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放孩子的单链表节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">childNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> childIndex; <span class="comment">// 孩子节点的下标</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">childNode</span> *next;</span><br><span class="line">&#125;chNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">char</span> data; <span class="comment">// 节点数据</span></span><br><span class="line">    chNode *firstChild; <span class="comment">// 指向孩子链表</span></span><br><span class="line">&#125;t[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size; <span class="comment">// 记录树的节点个数</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initTree</span><span class="params">(<span class="type">char</span> root)</span> </span>&#123;</span><br><span class="line">    t[<span class="number">0</span>].data = root;</span><br><span class="line">    t[<span class="number">0</span>].firstChild = <span class="literal">NULL</span>;</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> fx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i].data == fx) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> x, <span class="type">char</span> fx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存数据</span></span><br><span class="line">    t[size].data = x;</span><br><span class="line">    <span class="comment">// 存节点关系</span></span><br><span class="line">    t[size].firstChild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将孩子节点x的下标头插到父节点fx的链表头部fx的链表中</span></span><br><span class="line">    <span class="comment">// 采用头插法，所以输出时会和插入的时候相反</span></span><br><span class="line">    <span class="type">int</span> fxIndex = <span class="built_in">find</span>(fx);</span><br><span class="line">    chNode *newNode = (chNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(chNode));</span><br><span class="line">    newNode-&gt;childIndex = size;</span><br><span class="line">    newNode-&gt;next = t[fxIndex].firstChild;</span><br><span class="line">    t[fxIndex].firstChild = newNode;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findFather</span><span class="params">(<span class="type">int</span> xIndex)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;父亲节点：&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    chNode *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">// 标记是否找到父亲节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        p = t[i].firstChild;</span><br><span class="line">        <span class="keyword">while</span> (p!= <span class="literal">NULL</span> &amp;&amp; p-&gt;childIndex != xIndex) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;childIndex == xIndex) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, t[i].data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not found.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findChild</span><span class="params">(<span class="type">int</span> xIndex)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;孩子节点：&quot;</span>);</span><br><span class="line"></span><br><span class="line">    chNode *p = t[xIndex].firstChild;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not found.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, t[p-&gt;childIndex].data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> root;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;root);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">initTree</span>(root);</span><br><span class="line">    <span class="type">char</span> x, fx; <span class="comment">// x的父亲是fx</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 读入数据和父亲节点，注意给出的父亲节点要存在</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c&quot;</span>, &amp;x, &amp;fx);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">insert</span>(x, fx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;x);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找x的父亲</span></span><br><span class="line">        <span class="type">int</span> xIndex = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="built_in">findFather</span>(xIndex);</span><br><span class="line">        <span class="built_in">findChild</span>(xIndex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">R</span></span><br><span class="line"><span class="comment">A R</span></span><br><span class="line"><span class="comment">B R</span></span><br><span class="line"><span class="comment">C R</span></span><br><span class="line"><span class="comment">D A</span></span><br><span class="line"><span class="comment">E A</span></span><br><span class="line"><span class="comment">F C</span></span><br><span class="line"><span class="comment">G F</span></span><br><span class="line"><span class="comment">H F</span></span><br><span class="line"><span class="comment">K F</span></span><br><span class="line"><span class="comment">B</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="1-2-3-孩子兄弟表示法"><a href="#1-2-3-孩子兄弟表示法" class="headerlink" title="1.2.3 孩子兄弟表示法"></a>1.2.3 孩子兄弟表示法</h3><ul>
<li>完全基于链式存储 –&gt; 二叉链表</li>
<li>二叉链表的数据域：树中节点的数据</li>
<li>存孩子和亲兄弟关系（狭义关系）：左指针指向第一个孩子，右指针指向该节点右边相邻的兄弟的地址<ul>
<li>左孩子，右兄弟</li>
</ul>
</li>
</ul>
<p>有一个二叉链表（看成二叉树）root，以root为根节点的二叉链表找fx（C）所在的节点</p>
<ul>
<li>\1. 和根节点对比，如果root-&gt;data &#x3D;&#x3D; fx  return root，否则执行2 + 3</li>
<li>\2. 问题1转化为：以root-&gt;left 为根节点找fx（递归调用）</li>
<li>\3. 问题2转化为：以root-&gt;right 为根节点找fx（递归调用）</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241006201635871.png" alt="image-20241006201635871">	</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉链表的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span> *left; <span class="comment">// data的第一个孩子</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span> *right; <span class="comment">// data右边的第一个兄弟</span></span><br><span class="line">&#125;TNode, *TreeList; <span class="comment">// TreeList表示二叉链表的根指针</span></span><br><span class="line"></span><br><span class="line"><span class="function">TreeList <span class="title">initTree</span><span class="params">(<span class="type">char</span> r)</span> </span>&#123;</span><br><span class="line">    TNode *s = (TNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = r;</span><br><span class="line">    s-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    s-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决：寻找以root为根结点的树中，找到fx所在的结点</span></span><br><span class="line"><span class="comment">// 1. 首先和root比较，如果相等，返回root，否则执行2</span></span><br><span class="line"><span class="comment">// 2. 然后和root的左子树比较(如果存在)，如果相等，返回root的左子树，否则执行3</span></span><br><span class="line"><span class="comment">// 3. 然后和root的右子树比较(如果存在)，如果相等，返回root的右子树，否则执行4</span></span><br><span class="line"><span class="comment">// 4. 递归出口：root = NULL</span></span><br><span class="line"><span class="function">TNode* <span class="title">find</span><span class="params">(TreeList root, <span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归出口和第一种情况可以合在一起</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;data == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TNode *ans = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 这里的判断可以去掉，但是为了易读性，所以加上了</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ans = <span class="built_in">find</span>(root-&gt;left, x);</span><br><span class="line">        <span class="comment">// 注意这里一定要判断左子树的结果进行return，否则第3步会执行不到</span></span><br><span class="line">        <span class="comment">// 加上两个条件是为了严谨，不容易出错</span></span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="literal">NULL</span> &amp;&amp; ans-&gt;data == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ans = <span class="built_in">find</span>(root-&gt;right, x);</span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="literal">NULL</span> &amp;&amp; ans-&gt;data == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// x不存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为根指针始终为root, 因此这里insert以后使用void</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(TreeList root, <span class="type">char</span> x, <span class="type">char</span> fx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在以root为根的二叉链表中找到fx所在的结点(难点)</span></span><br><span class="line">    TNode *f = <span class="built_in">find</span>(root, fx);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父亲结点不存在，插入失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们因为假设是无序树，所以直接插入到fx的第一个孩子，使用头插法即可</span></span><br><span class="line">    TNode *s = (TNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;right = f-&gt;left;</span><br><span class="line">    s-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    f-&gt;left = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> r;</span><br><span class="line">    TreeList root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;r);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    root = <span class="built_in">initTree</span>(r);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> x, fx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c&quot;</span>, &amp;x, &amp;fx);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">insert</span>(root, x, fx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找孩子</span></span><br><span class="line">    TNode *f = <span class="built_in">find</span>(root, x);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x不存在&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TNode *p = f-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data);</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">R</span></span><br><span class="line"><span class="comment">A R</span></span><br><span class="line"><span class="comment">B R</span></span><br><span class="line"><span class="comment">C R</span></span><br><span class="line"><span class="comment">D A</span></span><br><span class="line"><span class="comment">E A</span></span><br><span class="line"><span class="comment">F C</span></span><br><span class="line"><span class="comment">G F</span></span><br><span class="line"><span class="comment">H F</span></span><br><span class="line"><span class="comment">K F</span></span><br><span class="line"><span class="comment">F</span></span><br><span class="line"><span class="comment">答案：K H G</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="1-3-二叉树"><a href="#1-3-二叉树" class="headerlink" title="1.3 二叉树"></a>1.3 二叉树</h2><p>二叉树：概念 + 性质 + 存储方式 + 遍历</p>
<h3 id="1-3-1-二叉树概念和性质"><a href="#1-3-1-二叉树概念和性质" class="headerlink" title="1.3.1 二叉树概念和性质"></a>1.3.1 二叉树概念和性质</h3><ul>
<li>二叉树：度为2的树，每个结点最多两个孩子 </li>
<li>具有5种基本形态</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241014203323532.png" alt="image-20241014203323532">	</p>
<p>性质：假设根结点是第一层结点</p>
<ul>
<li><p>性质1：二叉树第i层最多有2^(i - 1)个节点</p>
</li>
<li><p>性质2：深度为k的二叉树，最多有2^k - 1个节点</p>
<ul>
<li>引出满二叉树：深度为k，具有2^k -1个节点的二叉树</li>
<li>完全二叉树：对满二叉树的节点进行编号（从上到下，从左到右），从后面删除连续的若干编号最大的节点，剩下的部分就是完全二叉树<ul>
<li>度为1的节点最多只有1个</li>
<li>可<strong>根据完全二叉树的总结点n的数量判断是否存在度为1的节点</strong>：如果完全二叉树有奇数个节点，那么度为1的节点有0个，否则，度为1的节点有1个<ul>
<li>如果没有度为1的节点，那么<code> n = n0 + n2 = 2 * n2 + 1 = 2 * n0 - 1</code></li>
<li>如果有度为1的节点，那么<code>n = n0 + n2 + 1 = 2 * n2 + 1 = 2 * n0</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>性质3：任何一颗非空二叉树中，度为0的节点个数比度为2的节点的个数多一个</p>
<ul>
<li>假设有n0个度为0的节点，n1个度为1的节点，n2个度为2的节点 &#x3D;&#x3D;&#x3D;&#x3D;&gt;  <code>n0 = n2 + 1 </code>（n &#x3D; n0 + n1 + n2 &#x3D; 1 + n1 + 2* n2 得到）</li>
</ul>
</li>
<li><p>性质4：二叉树的深度公式</p>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241014210105200.png" alt="image-20241014210105200">	</p>
<ul>
<li>性质5：对于完全二叉树，如果根节点的编号为i，左孩子的编号为2 * i，右孩子的编号为2 * i + 1，父亲节点的编号为 i &#x2F; 2（编号0当作不存在）<ul>
<li>可以借助该性质构建二叉树</li>
</ul>
</li>
</ul>
<h3 id="1-3-2-二叉树的存储方式"><a href="#1-3-2-二叉树的存储方式" class="headerlink" title="1.3.2 二叉树的存储方式"></a>1.3.2 二叉树的存储方式</h3><p>1.基于性质5，直接采用数组存储二叉树</p>
<ul>
<li>即使该树不是完全二叉树，也可以补成完全二叉树（补上空孩子）</li>
<li>i下标的数据的左孩子下标是2 * i，右孩子是2 * i + 1，父亲是 i &#x2F; 2</li>
<li>缺点：浪费空间</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241014212738785.png" alt="image-20241014212738785">	</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> data[<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> flag; <span class="comment">// 0为左孩子，1为右孩子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为不知道最大下标，所以需要用整个数组容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1005</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i] == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> root;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1005</span>; i ++) &#123;</span><br><span class="line">        data[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;root);</span><br><span class="line">    data[<span class="number">1</span>] = root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入剩下的n-1个节点</span></span><br><span class="line">    <span class="type">char</span> x, fx;</span><br><span class="line">    <span class="type">int</span> fxi, xi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c %d&quot;</span>, &amp;x, &amp;fx, &amp;flag);</span><br><span class="line">        fxi = <span class="built_in">find</span>(fx);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            xi = <span class="number">2</span> * fxi;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            xi = <span class="number">2</span> * fxi + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data[xi] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出父节点</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;x);</span><br><span class="line">    xi = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (xi == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该节点不存在父亲节点\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父节点为：%c\n&quot;</span>, data[xi / <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出左右孩子</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;左孩子：%c\n&quot;</span>, data[<span class="number">2</span> * xi]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;右孩子：%c\n&quot;</span>, data[<span class="number">2</span> * xi + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b a 0</span></span><br><span class="line"><span class="comment">c a 1</span></span><br><span class="line"><span class="comment">d b 0</span></span><br><span class="line"><span class="comment">e b 1</span></span><br><span class="line"><span class="comment">f e 0</span></span><br><span class="line"><span class="comment">g e 1</span></span><br><span class="line"><span class="comment">e</span></span><br><span class="line"><span class="comment">父节点为：b</span></span><br><span class="line"><span class="comment">左孩子：f</span></span><br><span class="line"><span class="comment">右孩子：g</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>2.类似于孩子兄弟表示法，天然使用二叉链表存储</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241014213653827.png" alt="image-20241014213653827">	</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉链表节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span> *lchild, *rchild;</span><br><span class="line">    <span class="comment">// struct BitNode *fa; // 指向父节点</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BiTree <span class="title">initBiTree</span><span class="params">(<span class="type">char</span> data)</span> </span>&#123;</span><br><span class="line">    BiTree root = (BiTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;data = data;</span><br><span class="line">    root-&gt;lchild = root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// root-&gt;fa = NULL;</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BiTNode* <span class="title">find</span><span class="params">(BiTree T, <span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span> || T-&gt;data == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BiTNode* ans = <span class="built_in">find</span>(T-&gt;lchild, x);</span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="literal">NULL</span> &amp;&amp; ans-&gt;data == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BiTNode* ans = <span class="built_in">find</span>(T-&gt;rchild, x);</span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="literal">NULL</span> &amp;&amp; ans-&gt;data == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BiTree <span class="title">insert</span><span class="params">(BiTree T, <span class="type">char</span> data, <span class="type">char</span> fx, <span class="type">int</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到父节点</span></span><br><span class="line">    BitNode* f = <span class="built_in">find</span>(T, fx);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父节点不存在！插入失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BiTNode *s = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = data;</span><br><span class="line">    <span class="comment">// s-&gt;fa = f;</span></span><br><span class="line">    s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">        f-&gt;lchild = s;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        f-&gt;rchild = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> root;</span><br><span class="line">    BiTree T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;root);</span><br><span class="line"></span><br><span class="line">    T = <span class="built_in">initBiTree</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入剩下的n-1个节点</span></span><br><span class="line">    <span class="type">char</span> x, fx;</span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c %d&quot;</span>, &amp;x, &amp;fx, &amp;flag);</span><br><span class="line">        <span class="comment">// 这里逻辑上来说修改了树的结构，但由于根指针地址不变，也可以不返回值</span></span><br><span class="line">        T = <span class="built_in">insert</span>(T, x, fx, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出父节点</span></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;x);</span><br><span class="line">    BiTNode* p = <span class="built_in">find</span>(T, x);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果需要找父亲节点，再加一个父亲指针域即可，用的较少</span></span><br><span class="line">        <span class="comment">// if (p-&gt;fa != NULL) &#123;</span></span><br><span class="line">        <span class="comment">//     printf(&quot;父节点：%c\n&quot;, p-&gt;fa-&gt;data);</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//     printf(&quot;父节点：NULL\n&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;左孩子：%c\n&quot;</span>, p-&gt;lchild-&gt;data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;左孩子：NULL\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;右孩子：%c\n&quot;</span>, p-&gt;rchild-&gt;data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;右孩子：NULL\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b a 0</span></span><br><span class="line"><span class="comment">c b 0</span></span><br><span class="line"><span class="comment">d b 1</span></span><br><span class="line"><span class="comment">e d 0</span></span><br><span class="line"><span class="comment">f d 1</span></span><br><span class="line"><span class="comment">g e 1</span></span><br><span class="line"><span class="comment">e</span></span><br><span class="line"><span class="comment">左孩子：NULL</span></span><br><span class="line"><span class="comment">右孩子：g</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="1-3-3-二叉树的操作"><a href="#1-3-3-二叉树的操作" class="headerlink" title="1.3.3 二叉树的操作"></a>1.3.3 二叉树的操作</h3><ul>
<li>遍历：沿着某条路径周游二叉树，对数的每个节点访问一次且仅访问一次</li>
<li>由于二叉树是非线性结构，每个节点有两个后继，遍历方式有两种方式<ul>
<li>按<code>层次（广度）遍历</code>。按照父子关系，直到父节点，将所有子节点走一遍</li>
<li>按<code>深度遍历</code>。一条路走到黑，然后返回走另外一个道。分为<code>先序遍历、中序遍历、后序遍历</code></li>
</ul>
</li>
</ul>
<h4 id="层次（广度）遍历"><a href="#层次（广度）遍历" class="headerlink" title="层次（广度）遍历"></a>层次（广度）遍历</h4><p>思路</p>
<ul>
<li>引入队列，根节点入队</li>
<li>从队列中取出队头元素，访问该节点，左右孩子入队</li>
<li>再次从队列中取出对头元素，并访问，依次重复</li>
<li>队列为空时停止循环，遍历完成</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉链表节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span> *lchild, *rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列: 单链表节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span>&#123;</span><br><span class="line">    <span class="type">char</span> data; <span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span> *next; <span class="comment">// 指针域</span></span><br><span class="line">&#125; QNode, *Queue;</span><br><span class="line"></span><br><span class="line">QNode *front;</span><br><span class="line">QNode *rear;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QNode *p = (QNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    front = rear = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enQueue</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    QNode *s = (QNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = rear-&gt;next;</span><br><span class="line">    rear-&gt;next = s;</span><br><span class="line">    rear = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> front == rear &amp;&amp; front-&gt;next == <span class="literal">NULL</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回出队元素</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QNode *p = front-&gt;next;</span><br><span class="line">    <span class="type">char</span> x = p-&gt;data;</span><br><span class="line">    front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (front-&gt;next == <span class="literal">NULL</span> &amp;&amp; rear == p) &#123;</span><br><span class="line">        rear = front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BiTree <span class="title">initBiTree</span><span class="params">(<span class="type">char</span> data)</span> </span>&#123;</span><br><span class="line">    BiTree root = (BiTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;data = data;</span><br><span class="line">    root-&gt;lchild = root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BiTNode* <span class="title">find</span><span class="params">(BiTree T, <span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span> || T-&gt;data == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BiTNode* ans = <span class="built_in">find</span>(T-&gt;lchild, x);</span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="literal">NULL</span> &amp;&amp; ans-&gt;data == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BiTNode* ans = <span class="built_in">find</span>(T-&gt;rchild, x);</span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="literal">NULL</span> &amp;&amp; ans-&gt;data == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BiTree <span class="title">insert</span><span class="params">(BiTree T, <span class="type">char</span> data, <span class="type">char</span> fx, <span class="type">int</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到父节点</span></span><br><span class="line">    BitNode* f = <span class="built_in">find</span>(T, fx);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父节点不存在！插入失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BiTNode *s = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = data;</span><br><span class="line">    s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">        f-&gt;lchild = s;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        f-&gt;rchild = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">initQueue</span>(); <span class="comment">// 初始化队列</span></span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;树为空！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">enQueue</span>(T-&gt;data); <span class="comment">// 根节点入队</span></span><br><span class="line">    BiTNode *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="type">char</span> x = <span class="built_in">deQueue</span>(); <span class="comment">// 出队</span></span><br><span class="line">        <span class="built_in">visit</span>(x); <span class="comment">// 访问x</span></span><br><span class="line">        <span class="comment">// 找x所在的节点</span></span><br><span class="line">        p = <span class="built_in">find</span>(T, x);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">enQueue</span>(p-&gt;lchild-&gt;data); <span class="comment">// 左孩子入队</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">enQueue</span>(p-&gt;rchild-&gt;data); <span class="comment">// 右孩子入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> root;</span><br><span class="line">    BiTree T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;root);</span><br><span class="line"></span><br><span class="line">    T = <span class="built_in">initBiTree</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入剩下的n-1个节点</span></span><br><span class="line">    <span class="type">char</span> x, fx;</span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c %d&quot;</span>, &amp;x, &amp;fx, &amp;flag);</span><br><span class="line">        <span class="comment">// 这里逻辑上来说修改了树的结构，但由于根指针地址不变，也可以不返回值</span></span><br><span class="line">        T = <span class="built_in">insert</span>(T, x, fx, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层次遍历</span></span><br><span class="line">    <span class="built_in">levelTraverse</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b a 0</span></span><br><span class="line"><span class="comment">c b 0</span></span><br><span class="line"><span class="comment">d b 1</span></span><br><span class="line"><span class="comment">e d 0</span></span><br><span class="line"><span class="comment">f d 1</span></span><br><span class="line"><span class="comment">g e 1</span></span><br><span class="line"><span class="comment">a b c d e f g</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="深度遍历"><a href="#深度遍历" class="headerlink" title="深度遍历"></a>深度遍历</h4><p>对树看成三个部分：左子树，根节点，右子树</p>
<ul>
<li><code>先序遍历</code>：先访问根节点，再对左子树先序遍历 ，最后对右子树进行先序遍历</li>
<li><code>中序遍历</code>：先对左子树先序遍历，再访问根节点，最后对右子树进行先序遍历</li>
<li><code>后序遍历</code>：先对左子树先序遍历，再对右子树进行先序遍历，最后访问根节点</li>
</ul>
<p>给出两个序列的组合，画出二叉树，只有3种情况能确定（中序就是要知道左子树和右子树有哪些）</p>
<ul>
<li>前序 + 中序<ul>
<li>根 左 右   &#x3D;&#x3D;&gt;  提供根节点</li>
<li>左 根 右  &#x3D;&#x3D;&#x3D;&gt;  查找左右子树</li>
</ul>
</li>
<li>后序 + 中序<ul>
<li>左 右 根   &#x3D;&#x3D;&gt;  提供根节点</li>
<li>左 根 右  &#x3D;&#x3D;&#x3D;&gt;  查找左右子树</li>
</ul>
</li>
<li>层次 + 中序<ul>
<li>根 + 兄弟&#x2F;子树  &#x3D;&#x3D;&gt;  提供根节点</li>
<li>左 根 右  &#x3D;&#x3D;&#x3D;&gt;  查找左右子树</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉链表节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span> *lchild, *rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function">BiTree <span class="title">initBiTree</span><span class="params">(<span class="type">char</span> data)</span> </span>&#123;</span><br><span class="line">    BiTree root = (BiTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;data = data;</span><br><span class="line">    root-&gt;lchild = root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// root-&gt;fa = NULL;</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BiTNode* <span class="title">find</span><span class="params">(BiTree T, <span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span> || T-&gt;data == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BiTNode* ans = <span class="built_in">find</span>(T-&gt;lchild, x);</span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="literal">NULL</span> &amp;&amp; ans-&gt;data == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BiTNode* ans = <span class="built_in">find</span>(T-&gt;rchild, x);</span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="literal">NULL</span> &amp;&amp; ans-&gt;data == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BiTree <span class="title">insert</span><span class="params">(BiTree T, <span class="type">char</span> data, <span class="type">char</span> fx, <span class="type">int</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到父节点</span></span><br><span class="line">    BitNode* f = <span class="built_in">find</span>(T, fx);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父节点不存在！插入失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BiTNode *s = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = data;</span><br><span class="line">    <span class="comment">// s-&gt;fa = f;</span></span><br><span class="line">    s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">        f-&gt;lchild = s;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        f-&gt;rchild = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对以T为根的树进行先序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">visit</span>(T-&gt;data); <span class="comment">// 访问根节点</span></span><br><span class="line">    <span class="built_in">preOrder</span>(T-&gt;lchild); <span class="comment">// 对左子树先序遍历</span></span><br><span class="line">    <span class="built_in">preOrder</span>(T-&gt;rchild); <span class="comment">// 对右子树先序遍历</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对以T为根的树进行中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">inOrder</span>(T-&gt;lchild); <span class="comment">// 对左子树先序遍历</span></span><br><span class="line">    <span class="built_in">visit</span>(T-&gt;data); <span class="comment">// 访问根节点</span></span><br><span class="line">    <span class="built_in">inOrder</span>(T-&gt;rchild); <span class="comment">// 对右子树先序遍历</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对以T为根的树进行后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">postOrder</span>(T-&gt;lchild); <span class="comment">// 对左子树先序遍历</span></span><br><span class="line">    <span class="built_in">postOrder</span>(T-&gt;rchild); <span class="comment">// 对右子树先序遍历</span></span><br><span class="line">    <span class="built_in">visit</span>(T-&gt;data); <span class="comment">// 访问根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> root;</span><br><span class="line">    BiTree T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;root);</span><br><span class="line"></span><br><span class="line">    T = <span class="built_in">initBiTree</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入剩下的n-1个节点</span></span><br><span class="line">    <span class="type">char</span> x, fx;</span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c %d&quot;</span>, &amp;x, &amp;fx, &amp;flag);</span><br><span class="line">        <span class="comment">// 这里逻辑上来说修改了树的结构，但由于根指针地址不变，也可以不返回值</span></span><br><span class="line">        T = <span class="built_in">insert</span>(T, x, fx, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先序遍历</span></span><br><span class="line">    <span class="built_in">preOrder</span>(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="built_in">inOrder</span>(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="built_in">postOrder</span>(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b a 0</span></span><br><span class="line"><span class="comment">c b 0</span></span><br><span class="line"><span class="comment">d b 1</span></span><br><span class="line"><span class="comment">e d 0</span></span><br><span class="line"><span class="comment">f d 1</span></span><br><span class="line"><span class="comment">g e 1</span></span><br><span class="line"><span class="comment">a b c d e g f </span></span><br><span class="line"><span class="comment">c b e g d f a </span></span><br><span class="line"><span class="comment">c g e f d b a</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="深度遍历（非递归）"><a href="#深度遍历（非递归）" class="headerlink" title="深度遍历（非递归）"></a>深度遍历（非递归）</h4><p>对于先序遍历（根 左 右）</p>
<p>问题引入：找完左子树，如何回退到根节点进而找右子树？需要回退到根节点找地址空间，那么回溯的实现？栈。</p>
<ul>
<li>引入遍历的指针p，初始化为根节点</li>
<li>进入循环，遍历每个节点，循环退出条件（p !&#x3D; NULL || ! isEmpty(S)）<ul>
<li>（1）如果 p !&#x3D; NULL，访问以p为根的子树的根节点p，p入栈，然后继续处理以左子树为根节点的问题，p &#x3D; p-&gt; lchild</li>
<li>（2）如果 p &#x3D;&#x3D; NULL，此时以p为根的子树不存在，栈顶出栈，回溯到上一个节点k，此时表示栈顶和栈顶的左子树遍历完毕，接下来处理以右子树为根节点的问题 p &#x3D; k-&gt;rchild</li>
</ul>
</li>
<li>从另外一个角度看：<code>各子树根节点入栈的顺序</code>就是先序遍历序列</li>
</ul>
<p>对于中序遍历（左 根 右），这里思路类似先序遍历，同样引入一个p指针用来遍历树上的各节点</p>
<ul>
<li>进入循环，遍历每个节点，退出条件（p !&#x3D; NULL || ! isEmpty(S)）<ul>
<li>（1）如果 p !&#x3D; NULL，访问以p为根的子树的根节点p，直接处理以左子树为根节点的问题，p &#x3D; p-&gt; lchild</li>
<li>（2）如果 p &#x3D;&#x3D; NULL，此时以p为根的子树不存在，栈顶出栈，回溯到上一个节点k，<strong>访问上一层子树的根节点</strong>，此时表示栈顶和栈顶的左子树遍历完毕，接下来处理以右子树为根节点的问题 p &#x3D; k-&gt;rchild</li>
<li>与先序区别：访问根节点的时机是回溯前还是回溯后的问题</li>
</ul>
</li>
<li>从另外一个角度看：<code>各子树根节点出栈的顺序</code>就是中序遍历序列</li>
</ul>
<p>现提出一个问题：给出一个先序遍历ABCD，一共有多少种可能的二叉树？</p>
<ul>
<li>利用深度遍历非递归时的结论，入栈序列对应入栈顺序，出栈序列对应出栈顺序， 而我们已知先序+中序可以唯一确定一颗二叉树</li>
<li>问题就转化为给定固定的入栈序列ABCD（n&#x3D;4），有多少种可能的出栈序列  &#x3D;&#x3D;&#x3D;&gt; 卡特兰数求解<img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241017193528368.png" alt="image-20241017193528368" style="zoom: 67%;" /></li>
</ul>
<p>对于后序遍历（左 右 根），首先也是指针p来遍历元素，这里使用的是一个栈的思路，也有一个易于理解的两个栈的思路</p>
<p>入循环，遍历每个节点，退出条件（p !&#x3D; NULL || ! isEmpty(S)）</p>
<ul>
<li>（1）如果 p !&#x3D; NULL，访问以p为根的子树的根节点p，直接处理以左子树为根节点的问题，p &#x3D; p-&gt; lchild</li>
<li>（2）如果 p &#x3D;&#x3D; NULL，此时以p为根的子树不存在，栈顶出栈，回溯到上一个节点k，此时表示栈顶的左子树遍历完毕，接下来处理以右子树为根节点的问题 p &#x3D; k-&gt;rchild（该步骤缺少判断上一步是右子树的情况）</li>
<li>提出疑问：沿用原来的思路，右子树访问完以后，就可以访问根节点了，那如何表示呢？即如何判断该根节点是从左子树回溯回来还是右子树回溯回来的？</li>
<li>解决方案：引入pre指针保存上一次判断的节点，取出栈顶元素，判断上一次访问pre是否为该栈顶元素根节点的右孩子（或者说有孩子为空）<ul>
<li>如果是右孩子或者右孩子为空，那就表示左右孩子访问完毕，可以访问根节点，出栈（<strong><code>此时p依然为NULL表示以k为根节点的子树后序遍历完毕</code></strong>）</li>
<li>否则，表示只访问了左子树，需要让p &#x3D; k-&gt;right，再访问右子树</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉链表节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span> *lchild, *rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列: 单链表节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stackNode</span> &#123;</span><br><span class="line">    BiTNode *data; <span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stackNode</span> *next; <span class="comment">// 指针域</span></span><br><span class="line">&#125; StackNode, *Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">initStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack s = (StackNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(StackNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isStackEmpty</span><span class="params">(Stack s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BiTNode* <span class="title">pop</span><span class="params">(Stack s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isStackEmpty</span>(s)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StackNode *p = s-&gt;next;</span><br><span class="line">    BitNode *k = p-&gt;data;</span><br><span class="line"></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(Stack s, BitNode* k)</span> </span>&#123;</span><br><span class="line">    StackNode* p = (StackNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(StackNode));</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;data = k;</span><br><span class="line">    p-&gt;next = s-&gt;next;</span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BiTree <span class="title">initBiTree</span><span class="params">(<span class="type">char</span> data)</span> </span>&#123;</span><br><span class="line">    BiTree root = (BiTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;data = data;</span><br><span class="line">    root-&gt;lchild = root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// root-&gt;fa = NULL;</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BiTNode* <span class="title">find</span><span class="params">(BiTree T, <span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span> || T-&gt;data == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BiTNode* ans = <span class="built_in">find</span>(T-&gt;lchild, x);</span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="literal">NULL</span> &amp;&amp; ans-&gt;data == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BiTNode* ans = <span class="built_in">find</span>(T-&gt;rchild, x);</span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="literal">NULL</span> &amp;&amp; ans-&gt;data == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BiTree <span class="title">insert</span><span class="params">(BiTree T, <span class="type">char</span> data, <span class="type">char</span> fx, <span class="type">int</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到父节点</span></span><br><span class="line">    BitNode* f = <span class="built_in">find</span>(T, fx);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父节点不存在！插入失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BiTNode *s = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = data;</span><br><span class="line">    <span class="comment">// s-&gt;fa = f;</span></span><br><span class="line">    s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">        f-&gt;lchild = s;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        f-&gt;rchild = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对以T为根的树进行先序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    Stack s = <span class="built_in">initStack</span>();</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;树为空！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义遍历指针p,临时出栈指针k</span></span><br><span class="line">    BiTNode* p = T;</span><br><span class="line">    BiTNode* k;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || !<span class="built_in">isStackEmpty</span>(s)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">            <span class="built_in">push</span>(s, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = <span class="built_in">pop</span>(s);</span><br><span class="line">            p = k-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对以T为根的树进行中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    Stack s = <span class="built_in">initStack</span>();</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;树为空！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义遍历指针p,临时出栈指针k</span></span><br><span class="line">    BiTNode* p = T;</span><br><span class="line">    BiTNode* k;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || !<span class="built_in">isStackEmpty</span>(s)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">push</span>(s, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = <span class="built_in">pop</span>(s);</span><br><span class="line">            <span class="built_in">visit</span>(k-&gt;data);</span><br><span class="line">            p = k-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到栈顶元素，但不弹出</span></span><br><span class="line"><span class="function">BitNode* <span class="title">getTop</span><span class="params">(Stack s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isStackEmpty</span>(s)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> s-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对以T为根的树进行后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    Stack s = <span class="built_in">initStack</span>();</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;树为空！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义遍历指针p,临时出栈指针k, 遍历指针上一个节点指针pre</span></span><br><span class="line">    BiTNode* p = T;</span><br><span class="line">    BitNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    BiTNode* k;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || !<span class="built_in">isStackEmpty</span>(s)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">push</span>(s, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = <span class="built_in">getTop</span>(s);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 右子树如果访问过或者为空，则直接访问根节点 p=NULL，接着往上一层子树继续遍历，否则继续看右子树</span></span><br><span class="line">            <span class="keyword">if</span> (k -&gt; rchild == <span class="literal">NULL</span> || pre == k-&gt;rchild) &#123;</span><br><span class="line">                k = <span class="built_in">pop</span>(s);</span><br><span class="line">                <span class="built_in">visit</span>(k-&gt;data);</span><br><span class="line">                pre = k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = k-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> root;</span><br><span class="line">    BiTree T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;root);</span><br><span class="line"></span><br><span class="line">    T = <span class="built_in">initBiTree</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入剩下的n-1个节点</span></span><br><span class="line">    <span class="type">char</span> x, fx;</span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c %d&quot;</span>, &amp;x, &amp;fx, &amp;flag);</span><br><span class="line">        <span class="comment">// 这里逻辑上来说修改了树的结构, 但由于根指针地址不变, 也可以不返回值</span></span><br><span class="line">        T = <span class="built_in">insert</span>(T, x, fx, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先序遍历</span></span><br><span class="line">    <span class="built_in">preOrder</span>(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="built_in">inOrder</span>(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="built_in">postOrder</span>(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b a 0</span></span><br><span class="line"><span class="comment">c b 0</span></span><br><span class="line"><span class="comment">d b 1</span></span><br><span class="line"><span class="comment">e d 0</span></span><br><span class="line"><span class="comment">f d 1</span></span><br><span class="line"><span class="comment">g e 1</span></span><br><span class="line"><span class="comment">a b c d e g f </span></span><br><span class="line"><span class="comment">c b e g d f a </span></span><br><span class="line"><span class="comment">c g e f d b a</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="1-3-4-线索化二叉树"><a href="#1-3-4-线索化二叉树" class="headerlink" title="1.3.4 线索化二叉树"></a>1.3.4 线索化二叉树</h3><p><strong>线索化的引入</strong></p>
<ul>
<li>对于n个节点的二叉树，使用二叉链表存储，一共有2n个指针域，不为空的指针域有n-1个，为空的指针域有n+1个<ul>
<li>空指针域的空间浪费问题</li>
</ul>
</li>
<li>中序遍历，如何找到结点的前驱和后继？<ul>
<li>传统方法：直接从中序遍历序列中找</li>
<li>现有方法：利用空指针域进行中序线索化，可以直接在树上找答案</li>
</ul>
</li>
</ul>
<p><strong>线索化的分类</strong></p>
<ul>
<li>中序线索化、先序线索化、后序线索化（后续开发不常用）</li>
<li><code>线索化</code>：某结点的空指针域指向该结点的前驱后继，定义规则如下：<ul>
<li>若结点的左子树为空，则该结点的左孩子指针指向其前驱结点。</li>
<li>若结点的右子树为空，则该结点的右孩子指针指向其后继结点。</li>
</ul>
</li>
<li>这种指向前驱和后继的指针称为<code>线索</code>。将一棵普通二叉树以某种次序遍历，并添加线索的过程称为<code>线索化  </code></li>
</ul>
<img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241020212806924.png" alt="image-20241020212806924" style="zoom:67%;" />	

<p>提出两个问题：</p>
<p>（1）如何添加线索？</p>
<p>在中序遍历的过程中添加线索（之前visit函数由输出操作改为加线索的操作）</p>
<ul>
<li>引入pre指针，记录上一个访问的结点</li>
<li>假设现在访问x结点，此时x的前驱为pre<ul>
<li>如果x-&gt;left &#x3D;&#x3D; NULL, x-&gt;left &#x3D; pre</li>
<li>如果pre -&gt; right &#x3D;&#x3D; NULL, pre-&gt;right &#x3D; x</li>
</ul>
</li>
<li>访问完后，另pre &#x3D; x</li>
</ul>
<p>我们这里修改递归的中序遍历为例，来进行代码说明。</p>
<ul>
<li>执行完后<ul>
<li>B-&gt;lflag&#x3D; 1 B-&gt;rflag &#x3D; 0</li>
<li>F-&gt;rflag &#x3D; 0</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉链表节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BitNode</span> *lchild, *rchild;</span><br><span class="line">    <span class="type">int</span> lflag, rflag; <span class="comment">// 左右线索标记 0表示没有孩子 可以放线索，1表示有孩子 不能放线索</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line">BiTNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加线索</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(BitNode* x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        x-&gt;lchild = pre;</span><br><span class="line">        x-&gt;lflag = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// x如果是pre的后继，需要给pre添加后继线索</span></span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = x;</span><br><span class="line">        pre-&gt;rflag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pre = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（2）如何在中序线索化的树上查找某个结点的前驱和后继</p>
<ul>
<li>找前驱<ul>
<li>情况1：x-&gt;lflag &#x3D;&#x3D; 1，x的左指针指向线索，return x-&gt;left</li>
<li>情况2：x-&gt;lflag &#x3D;&#x3D; 0，返回x左子树中最靠右结点（左根右 展开，该子算法比较重要，后续二叉排序树也会用到）</li>
</ul>
</li>
<li>找后继<ul>
<li>情况1：x-&gt;rflag &#x3D;&#x3D; 1，x的右指针指向线索，return x-&gt;right</li>
<li>情况2：x-&gt;rflag &#x3D;&#x3D; 0，同理，返回x右子树最靠左结点</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">BiTNode* <span class="title">find</span><span class="params">(BiTree T, <span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span> || T-&gt;data == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;lchild != <span class="literal">NULL</span> &amp;&amp; T-&gt;lflag == <span class="number">0</span>) &#123;</span><br><span class="line">        BiTNode* ans = <span class="built_in">find</span>(T-&gt;lchild, x);</span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="literal">NULL</span> &amp;&amp; ans-&gt;data == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;rchild != <span class="literal">NULL</span> &amp;&amp; T-&gt;rflag == <span class="number">0</span>) &#123;</span><br><span class="line">        BiTNode* ans = <span class="built_in">find</span>(T-&gt;rchild, x);</span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="literal">NULL</span> &amp;&amp; ans-&gt;data == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BitNode *<span class="title">find_pre</span><span class="params">(BiTree T, BiTNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;lflag == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BiTNode *q = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span> (q-&gt;rflag == <span class="number">0</span> &amp;&amp; q-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            q = q-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;rflag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BitNode *<span class="title">find_post</span><span class="params">(BiTree T, BiTNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rflag == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BiTNode *q = p-&gt;rchild;</span><br><span class="line">        <span class="keyword">while</span> (q-&gt;lflag == <span class="number">0</span> &amp;&amp; q-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            q = q-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;lflag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b a 0</span></span><br><span class="line"><span class="comment">c b 0</span></span><br><span class="line"><span class="comment">d b 1</span></span><br><span class="line"><span class="comment">e d 0</span></span><br><span class="line"><span class="comment">f d 1</span></span><br><span class="line"><span class="comment">g e 1</span></span><br><span class="line"><span class="comment">e</span></span><br><span class="line"><span class="comment">pre: b</span></span><br><span class="line"><span class="comment">next: g</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>接下来说明先序遍历和后序遍历，思路差不多，但是注意一些点</p>
<ul>
<li>问题复述：先序遍历有可能会对左子树添加线索，然后再遍历左子树的情况，造成死循环</li>
<li>解决方案：遍历访问时判断r-&gt;left是否添加了线索，即当 r-&gt;lflag !&#x3D; 1 时才执行对左子树遍历</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241020213941226.png" alt="image-20241020213941226">	</p>
<ul>
<li>对于先序遍历和后序遍历找前驱，都需要借助父亲结点</li>
<li>后续在计网的路由器的CIDR算法，最长前缀匹配，会用到线索树二叉树来优化匹配效率（了解即可，网络底层开发相关）</li>
</ul>
<h2 id="1-4-二叉排序树-BST"><a href="#1-4-二叉排序树-BST" class="headerlink" title="1.4 二叉排序树 BST"></a>1.4 二叉排序树 BST</h2><ul>
<li>高级搜索树：用于数据的存储和查找的树 <code>BST AVL树 红黑树 B树 B+树</code></li>
<li>定义：在普通二叉树的基础上，增加以下约束（保证顺序）<ul>
<li>如果某节点的左子树不空，那么左子树所有节点的值都要小于该节点的值</li>
<li>如果某节点的右子树不空，那么右子树所有节点的值都要大于该节点的值</li>
<li>所有节点都满足以上约束</li>
</ul>
</li>
<li>性质：中序遍历有序</li>
<li>操作：插入、查找、删除</li>
<li>应用：对无序数据查找时间复杂度可以控制在O(log n)</li>
<li>缺点：如果用于建树的初始序列本身有序，算法会退化为O(n)<ul>
<li>解决方案：<code>平衡二叉树</code></li>
</ul>
</li>
</ul>
<h3 id="1-4-1-插入操作"><a href="#1-4-1-插入操作" class="headerlink" title="1.4.1 插入操作"></a>1.4.1 插入操作</h3><ul>
<li>在空树上插入x，x作根节点即可</li>
<li>如果在非空树上插入x，假设树的根节点是r  &#x3D;&#x3D;&gt; 问题：在以r为根节点的BST树上插入x<ul>
<li>递归出口：r &#x3D;&#x3D; NULL, 说明该位置就是x应该在的位置，在空树上插入x即可</li>
<li>x &lt; r-&gt;data，说明x应该插入到r的左子树上 &#x3D;&#x3D;&#x3D;&gt;  子问题：在以r-&gt;lchild为根节点的BST树上插入x</li>
<li>x &gt; r-&gt;data，说明x应该插入到r的右子树上 &#x3D;&#x3D;&#x3D;&gt;  子问题：在以r-&gt;rchild为根节点的BST树上插入x</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用二叉链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BSTNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTNode</span> *lchild, *rchild;</span><br><span class="line">&#125; BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一定要返回值，因为子树发生了变化, 画递归调用图会更清晰</span></span><br><span class="line"><span class="function">BSTree <span class="title">insert</span><span class="params">(BSTree root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包含初始化时空树的情况</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BSTree node = (BSTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BSTNode));</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed.\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;data = key;</span><br><span class="line">        node-&gt;lchild = node-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = <span class="built_in">insert</span>(root-&gt;lchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;rchild = <span class="built_in">insert</span>(root-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(BSTree root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">105</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BSTree root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        root = <span class="built_in">insert</span>(root, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">inorder</span>(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">8 3 10 1 6 14 4 7 13</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><strong>非递归版本</strong></p>
<ul>
<li>如果是空树上插入x，x做根节点即可</li>
<li>如果是非空树上插入x<ul>
<li>找x应该在的位置</li>
<li>执行插入操作（通过pre指针访问待插入的指针域）</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 非递归写法</span></span><br><span class="line"><span class="function">BSTree <span class="title">insert2</span><span class="params">(BSTree root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    BSTree node = (BSTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BSTNode));</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;data = key;</span><br><span class="line">    node-&gt;lchild = node-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    BSTNode *p = root;</span><br><span class="line">    BSTNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; p-&gt;data) &#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意不能想当然地直接 p=node, 实际上这并没有真正放到pre的指针域中</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; pre-&gt;data) &#123;</span><br><span class="line">        pre-&gt;lchild = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pre-&gt;rchild = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-4-2-查找操作"><a href="#1-4-2-查找操作" class="headerlink" title="1.4.2 查找操作"></a>1.4.2 查找操作</h3><p>实际上和非递归的递归思路一致</p>
<ul>
<li>与根节点比较，相等就找到</li>
<li>否则与根节点比较，如果比根节点小，就往左子树找，否则就往右子树找，如果访问到了NULL，说明节点不存在</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BSTNode* <span class="title">find</span><span class="params">(BSTree root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == key) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    BSTNode* p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == p-&gt;data) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Find %d\n&quot;</span>, key);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; p-&gt;data) &#123;</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Not find %d\n&quot;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-4-3-删除操作"><a href="#1-4-3-删除操作" class="headerlink" title="1.4.3 删除操作"></a>1.4.3 删除操作</h3><p>目标：删除以r为根节点的树中，删除数据x</p>
<ul>
<li>找到x所在的节点p，同时把x的父亲节点pre找到</li>
<li>删除x，有三种情况：<ul>
<li>如果p的度为2，将p的数据域，用p左子树最右边节点q1或者右子树最左边节点q2来代替，然后再删除代替的节点q（问题转化为删除度为0或1的节点）</li>
<li>如果p的度为1，拿其唯一的孩子节点来顶替原来的位置即可（注意递归调用过程，实际上是将被替换的节点return 给上一层的子树的）</li>
<li>如果p的度为0，<strong>可以当成度为1的节点做删除处理</strong>（把NULL看成是一个孩子）</li>
</ul>
</li>
</ul>
<p>考虑到子问题转换，因此尝试进行递归的思路</p>
<p>目标：删除以r为根节点的树中，删除数据x</p>
<p>（1） x &lt; r-&gt;data：问题转换为在以r-&gt;lchild为根的子树上删除x</p>
<p>（2） x &gt; r-&gt;data： 问题转换为在以r-&gt;rchild为根的子树上删除x</p>
<p>（3）x &#x3D;&#x3D; r-&gt;data ：r就是要被删除的节点，根据r的度判断如何删除</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241021221638065.png" alt="image-20241021221638065">	</p>
<ul>
<li>注：如果采用非递归写法，需要记录3个指针：删除节点，父节点和删除节点唯一的子节点（含NULL）<ul>
<li>仅度为1或0的情况，就要分2*2种情况讨论</li>
<li>对于度为2的，找到最左边的孩子后，需要处理该节点的左右指针，比较复杂</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BSTree <span class="title">delet</span><span class="params">(BSTree root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = <span class="built_in">delet</span>(root-&gt;lchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;rchild = <span class="built_in">delet</span>(root-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == root-&gt;data) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 此时root是要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild != <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild != <span class="literal">NULL</span>) &#123; <span class="comment">// 度为2的子树</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到左子树中最靠右的节点</span></span><br><span class="line">            BSTNode *p = <span class="built_in">findLeftMax</span>(root-&gt;lchild);</span><br><span class="line">            root-&gt;data = p-&gt;data;</span><br><span class="line">            root-&gt;lchild = <span class="built_in">delet</span>(root-&gt;lchild, p-&gt;data); <span class="comment">// 问题转换为去左子树中删除p-&gt;data</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 度为0或1的子树, 直接修改根节点为子节点的值即可</span></span><br><span class="line">            BSTNode *p = root;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                root = root-&gt;lchild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 这里包含了度为0的情况</span></span><br><span class="line">                root = root-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 释放原有地址空间</span></span><br><span class="line">            <span class="built_in">free</span>(p); </span><br><span class="line">            p = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-5-二叉平衡树-AVL"><a href="#1-5-二叉平衡树-AVL" class="headerlink" title="1.5 二叉平衡树  AVL"></a>1.5 二叉平衡树  AVL</h2><p><code>二叉排序树</code>：在二叉排序树的基础上，每个节点的平衡因子不能超过1（左子树和右子树的高度差：0 1 -1），是一个特殊的二叉排序树</p>
<ul>
<li><p>有点：查找效率稳定 O(log n)</p>
</li>
<li><p>缺点：在最坏的情况下，每两次增删操作就会导致失衡，就要调整1次。调整会很频繁</p>
</li>
<li><p>应用场景：不适合大量增删的查找</p>
</li>
<li><p>失衡节点：AVL树中，平衡因子超过1的节点</p>
</li>
<li><p>而我们遇到失衡节点时，需要进行调整，使其重新平衡</p>
</li>
<li><p>调整策略：往矮的一边旋转</p>
<ul>
<li><p>左旋：左边矮，右边往左边旋转</p>
<ul>
<li><p>对根节点x（失衡节点）左旋</p>
</li>
<li><p>引入变量 y &#x3D; x-&gt;right   &#x3D;&#x3D;&#x3D;&#x3D;&gt;   x-&gt;right &#x3D; y-&gt;left, y-&gt;left &#x3D; x, return y</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241023084737373.png" alt="image-20241023084737373"></p>
</li>
</ul>
</li>
<li><p>右旋：右边矮，左边往右边旋转</p>
<ul>
<li><p>对根节点（失衡节点）右旋</p>
</li>
<li><p>引入变量 y &#x3D; x-&gt;left &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; x-&gt;left &#x3D; y-&gt;right, y-&gt;right &#x3D; x , return y</p>
<img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241023085616189.png" alt="image-20241023085616189" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>AVL的操作：增加、删除、查找（同BST）</p>
</li>
</ul>
<h3 id="1-5-1-插入操作"><a href="#1-5-1-插入操作" class="headerlink" title="1.5.1 插入操作"></a>1.5.1 插入操作</h3><p><code>最小失衡子树</code>：插入或删除一个节点之后，可能会导致多颗子树失衡，而离插入&#x2F;被删除节点最近的子树称为最小失衡子树</p>
<p>如何判断失衡：计算平衡因子 &lt;&#x3D;&#x3D; 左右高度之差 &lt;&#x3D;&#x3D; 得到左子树高度，右子树高度 &lt;&#x3D;&#x3D; 维护高度h（1. 如何计算高度  2. 空树如何维护高度）</p>
<ul>
<li><p>按照BST插入过程进行插入x，保证顺序性</p>
</li>
<li><p>插入之后，返回子树时要检测直系祖先节点是否失衡，如果失衡，从最小失衡子树开始调整</p>
<ul>
<li><p>LL：在y的左孩子的左子树中插入了x导致y失衡，此时对y进行右旋（单旋）</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241023092445687.png" alt="image-20241023092445687"></p>
</li>
<li><p>LR：在y的左孩子的右子树中插入了x导致y失衡，先对失衡节点左孩子左旋调整 ，此时为LL情况，再对失衡节点y进行右旋（双旋）</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241023093247630.png" alt="image-20241023093247630"></p>
</li>
<li><p>RR：在y的右孩子的右子树中插入了x导致y失衡，此时对y进行左旋</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241023092656691.png" alt="image-20241023092656691">    </p>
</li>
<li><p>RL：在y的右孩子的左子树中插入了x导致y失衡，先对失衡节点右孩子右旋调整  ，此时为RR情况，再对失衡节点y进行左旋</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241023093837524.png" alt="image-20241023093837524"></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用二叉链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVLNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">AVLNode</span> *lchild, *rchild;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">&#125; AVLTNode, *AVLTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(AVLNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整函数</span></span><br><span class="line"><span class="comment">// LL 失衡节点x的左孩子左子树插入节点y，导致失衡，右旋</span></span><br><span class="line"><span class="function">AVLTree <span class="title">LL_rotation</span><span class="params">(AVLTree x)</span> </span>&#123;</span><br><span class="line">    AVLNode *y = x-&gt;lchild;</span><br><span class="line">    x-&gt;lchild = y-&gt;rchild;</span><br><span class="line">    y-&gt;rchild = x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意: 更新高度</span></span><br><span class="line">    x-&gt;h = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">getHeight</span>(x-&gt;lchild), <span class="built_in">getHeight</span>(x-&gt;rchild));</span><br><span class="line">    y-&gt;h = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">getHeight</span>(y-&gt;lchild), <span class="built_in">getHeight</span>(y-&gt;rchild));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RR 失衡节点x的右孩子右子树插入节点y，导致失衡，左旋</span></span><br><span class="line"><span class="function">AVLTree <span class="title">RR_rotation</span><span class="params">(AVLTree x)</span> </span>&#123;</span><br><span class="line">    AVLNode *y = x-&gt;rchild;</span><br><span class="line">    x-&gt;rchild = y-&gt;lchild;</span><br><span class="line">    y-&gt;lchild = x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意: 更新高度</span></span><br><span class="line">    x-&gt;h = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">getHeight</span>(x-&gt;lchild), <span class="built_in">getHeight</span>(x-&gt;rchild));</span><br><span class="line">    y-&gt;h = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">getHeight</span>(y-&gt;lchild), <span class="built_in">getHeight</span>(y-&gt;rchild));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LR 失衡节点x的左孩子右子树插入节点y，导致失衡，先对左子树左旋，再右旋(LL情况)</span></span><br><span class="line"><span class="function">AVLTree <span class="title">LR_rotation</span><span class="params">(AVLTree x)</span> </span>&#123;</span><br><span class="line">    x-&gt;lchild = <span class="built_in">RR_rotation</span>(x-&gt;lchild);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LL_rotation</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RL 失衡节点x的右孩子左子树插入节点y，导致失衡，先对右子树右旋，再左旋(RR情况)</span></span><br><span class="line"><span class="function">AVLTree <span class="title">RL_rotation</span><span class="params">(AVLTree x)</span> </span>&#123;</span><br><span class="line">    x-&gt;rchild = <span class="built_in">LL_rotation</span>(x-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RR_rotation</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">insert</span><span class="params">(AVLTree root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = (AVLTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(AVLTNode));</span><br><span class="line">        root-&gt;data = key;</span><br><span class="line">        root-&gt;lchild = root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;h = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = <span class="built_in">insert</span>(root-&gt;lchild, key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时在r的左子树插入了一个节点</span></span><br><span class="line">        <span class="comment">// r有可能失衡，只需要比较左孩子和右孩子的高度即可（右孩子可能为空）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getHeight</span>(root-&gt;lchild) - <span class="built_in">getHeight</span>(root-&gt;rchild) &gt; <span class="number">1</span>) &#123; <span class="comment">// LL/LR</span></span><br><span class="line">            <span class="comment">// 如何判断LL/LR？比较key和root-&gt;lchild-&gt;data即可</span></span><br><span class="line">            <span class="keyword">if</span> (key &lt; root-&gt;lchild-&gt;data) &#123; <span class="comment">// LL</span></span><br><span class="line">                root = <span class="built_in">LL_rotation</span>(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;lchild-&gt;data) &#123; <span class="comment">// LR</span></span><br><span class="line">                root = <span class="built_in">LR_rotation</span>(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;rchild = <span class="built_in">insert</span>(root-&gt;rchild, key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getHeight</span>(root-&gt;rchild) - <span class="built_in">getHeight</span>(root-&gt;lchild) &gt; <span class="number">1</span>) &#123; <span class="comment">// RR/RL</span></span><br><span class="line">            <span class="keyword">if</span> (key &gt; root-&gt;rchild-&gt;data) &#123; <span class="comment">// RR</span></span><br><span class="line">                root = <span class="built_in">RR_rotation</span>(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root-&gt;rchild-&gt;data) &#123; <span class="comment">// RL</span></span><br><span class="line">                root = <span class="built_in">RL_rotation</span>(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为对子树调整，即使没有失衡，root的高度也可能发生变化</span></span><br><span class="line">    root-&gt;h = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">getHeight</span>(root-&gt;lchild), <span class="built_in">getHeight</span>(root-&gt;rchild));</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="1-5-2-删除操作"><a href="#1-5-2-删除操作" class="headerlink" title="1.5.2 删除操作"></a>1.5.2 删除操作</h3><ul>
<li>首先执行二叉排序树的删除过程，保证顺序性</li>
<li>判断有无节点失衡：关键思路<ul>
<li>左边删除导致的失衡 ”相当于“ 右边插入导致的失衡  –&gt; R* —&gt; 通过高度判断 RR &#x2F; RL</li>
<li>右边删除导致的失衡 ”相当于“ 左边插入导致的失衡  –&gt; L* —&gt; 通过高度判断 LR &#x2F; LR</li>
<li>特例：如果高度相同时，只能看成单旋</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241023213038062.png" alt="image-20241023213038062">	</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">AVLNode* <span class="title">find_pre</span><span class="params">(AVLNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function">AVLTree <span class="title">delet</span><span class="params">(AVLTree root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;lchild = <span class="built_in">delet</span>(root-&gt;lchild, key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// root左子树删除一个节点，可能会导致失衡</span></span><br><span class="line">        <span class="comment">// 失衡效果相当于右子树插入 </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getHeight</span>(root-&gt;rchild) - <span class="built_in">getHeight</span>(root-&gt;lchild) &gt; <span class="number">1</span>) &#123; <span class="comment">// RL/RR</span></span><br><span class="line">            AVLNode *q = root-&gt;rchild;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">getHeight</span>(q-&gt;rchild) &gt;= <span class="built_in">getHeight</span>(q-&gt;lchild)) &#123; <span class="comment">// RR</span></span><br><span class="line">                root = <span class="built_in">RR_rotation</span>(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// RL</span></span><br><span class="line">                root = <span class="built_in">RL_rotation</span>(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;rchild = <span class="built_in">delet</span>(root-&gt;rchild, key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// root右子树删除一个节点，可能会导致失衡</span></span><br><span class="line">        <span class="comment">// 失衡效果相当于左子树插入 </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getHeight</span>(root-&gt;lchild) - <span class="built_in">getHeight</span>(root-&gt;rchild) &gt; <span class="number">1</span>) &#123; <span class="comment">// RL/RR</span></span><br><span class="line">            AVLNode *q = root-&gt;lchild;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">getHeight</span>(q-&gt;lchild) &gt;= <span class="built_in">getHeight</span>(q-&gt;rchild)) &#123; <span class="comment">// LL</span></span><br><span class="line">                root = <span class="built_in">LL_rotation</span>(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// LR</span></span><br><span class="line">                root = <span class="built_in">LR_rotation</span>(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild != <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            AVLNode *q = <span class="built_in">find_pre</span>(root-&gt;lchild);</span><br><span class="line">            root-&gt;data = q-&gt;data;</span><br><span class="line">            root-&gt;lchild = <span class="built_in">delet</span>(root-&gt;lchild, q-&gt;data);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// root左子树删除一个节点，可能会导致失衡</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">getHeight</span>(root-&gt;rchild) - <span class="built_in">getHeight</span>(root-&gt;lchild) &gt; <span class="number">1</span>) &#123; <span class="comment">// RL/RR</span></span><br><span class="line">                AVLNode *q = root-&gt;rchild;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">getHeight</span>(q-&gt;rchild) &gt;= <span class="built_in">getHeight</span>(q-&gt;lchild)) &#123; <span class="comment">// RR</span></span><br><span class="line">                    root = <span class="built_in">RR_rotation</span>(root);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// RL</span></span><br><span class="line">                    root = <span class="built_in">RL_rotation</span>(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AVLNode *q = root;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                root = root-&gt;lchild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = root-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">            q = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root-&gt;h = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">getHeight</span>(root-&gt;lchild), <span class="built_in">getHeight</span>(root-&gt;rchild));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-6-应用——并查集-哈夫曼树"><a href="#1-6-应用——并查集-哈夫曼树" class="headerlink" title="1.6 应用——并查集 哈夫曼树"></a>1.6 应用——并查集 哈夫曼树</h2><h3 id="1-6-1-并查集"><a href="#1-6-1-并查集" class="headerlink" title="1.6.1 并查集"></a>1.6.1 并查集</h3><p>介绍基于树形结构的算法：并查集 + 哈夫曼树（最优二叉树）</p>
<p> 并查集：给出n个互不相交的集合，有如下操作：</p>
<ul>
<li>1.合并，将两个数据所在的两个集合合并为一个集合</li>
<li>2.查询，询问两个数据是否同属于一个集合</li>
</ul>
<p>给出含有n个操作的操作序列（操作类型 操作数1 操作数2）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>用树型结构来表示（存储）一个集合，n个集合就是一颗树</p>
<p>合并：将两颗树合并为一棵树，将一颗树的根节点作为另外一棵树的根节点的父亲即可</p>
<p>查询：找到两个节点所在树的根节点，看根节点是否为同一个节点即可。</p>
<ul>
<li>需通过孩子节点找到根节点：因此选择使用双亲表示法来表示树形结构，可以简单通过数组f[i]来表示节点i的父亲<ul>
<li>对根节点的父亲做特殊的规定：f(z) &#x3D; z，表示根节点的父亲是自己</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241101202749638.png" alt="image-20241101202749638">	</p>
<p>具体的操作</p>
<ul>
<li><p>合并：f[fx] &#x3D; f[fy]  或者 f[fy] &#x3D; f[fx]</p>
</li>
<li><p>询问：f[x] 与 f[y] 比较即可</p>
</li>
<li><p>如何找到根节点？通过while(f[x] !&#x3D; x) x &#x3D; f[fx] 即可</p>
</li>
</ul>
<p>接下来考虑路径压缩（如果不压缩会出现查找根节点最坏On的情况）</p>
<ul>
<li>拓展：种类并查集，敌人的敌人是朋友？（后续算法集训课会讲到）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> f[], <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (f[x]!= x) &#123;</span><br><span class="line">        x = f[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x] = x; <span class="comment">// 路径压缩</span></span><br><span class="line">&#125; <span class="comment">// 压缩后树的深度不会超过α(n) &lt;= 4 --&gt; 增长极其缓慢的n的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_r</span><span class="params">(<span class="type">int</span> f[], <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] == x ? x : f[x] = <span class="built_in">find_r</span>(f, f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    6 2 2</span></span><br><span class="line"><span class="comment">    2 5</span></span><br><span class="line"><span class="comment">    5 1</span></span><br><span class="line"><span class="comment">    1 2</span></span><br><span class="line"><span class="comment">    Yes</span></span><br><span class="line"><span class="comment">    2 4</span></span><br><span class="line"><span class="comment">    No</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m1, m2, x, y;</span><br><span class="line">    <span class="type">int</span> f[<span class="number">105</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m1, &amp;m2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m1; i ++) &#123; <span class="comment">// 合并</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">find_r</span>(f, x);</span><br><span class="line">        <span class="type">int</span> fy = <span class="built_in">find_r</span>(f, y);</span><br><span class="line">        <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">            f[fx] = fy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m2; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">find_r</span>(f, x);</span><br><span class="line">        <span class="type">int</span> fy = <span class="built_in">find_r</span>(f, y);</span><br><span class="line">        <span class="keyword">if</span> (fx == fy) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-6-2-哈夫曼树-编码"><a href="#1-6-2-哈夫曼树-编码" class="headerlink" title="1.6.2 哈夫曼树&#x2F;编码"></a>1.6.2 哈夫曼树&#x2F;编码</h3><p>哈夫曼树：实现变长编码，相关概念：</p>
<ul>
<li><code>节点的路径长度</code>：从根节点到该节点的连接数</li>
<li><code>树的路径长度</code>：树的每个叶子长度的路径长度之和（有些参考书会定义路径长度为所有节点路径长度之和，对叶子节点之和叫做<code>外路径长度</code>）</li>
<li><code>节点的带权路径长度</code>：路径长度 * 点的权值</li>
<li><code>树的带权路径长度 WPL</code>：规定所有叶子节点的带权路径之和</li>
</ul>
<p>根据WPL，定义哈夫曼树：</p>
<ul>
<li>给出n个带权值节点，对这n个节点做叶子节点并且可以再添加n - 1个节点，构造出 WPL 最小的二叉树，这棵WPL最小的二叉树成为<code>最优二叉树</code>也叫<code>哈夫曼树</code></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241101214400979.png" alt="image-20241101214400979">	</p>
<p>为了让WPL小，因此要</p>
<ul>
<li><p>尽可能使得权值小的节点离根节点路径长度大，</p>
</li>
<li><p>并且越早合并的叶子节点，离叶节点远，所以我们一开始就要先合并权值小的节点</p>
</li>
</ul>
<p>那么构造哈夫曼树的过程：每次选根节点权值最小的两棵树合并，合并n-1次，最终把n个叶子节点（n颗树），合并成一棵树，该树就是哈夫曼树，其中</p>
<ul>
<li>指定n个叶子节点构造出来的哈夫曼树不唯一（左右子树方向的问题）</li>
<li>指定n个叶子节点构造出来的哈夫曼树的WPL值是唯一的</li>
</ul>
<p>应用场景：<strong>数据编码</strong></p>
<ul>
<li>定长编码：ASCII规定每一个字符编码8个比特位<ul>
<li>表示5个字符，最少需要3位，而传输5个字符，那么就需要15位了</li>
<li>优点：简单</li>
<li>缺点：会造成一定的空间浪费</li>
</ul>
</li>
<li>变长编码：每个字符的编码长度不固定<ul>
<li>优点：简短</li>
<li>缺点：编码复杂 —&gt; 前缀属性（即一个字符的编码不能是其他编码的前缀，这是为了将编码的数据还原）</li>
</ul>
</li>
</ul>
<p>如何进行变长编码？其中一种方式就是<code>哈夫曼编码</code>：确保了每个叶子节点的路径前缀是唯一的（因为叶节点没有子孩子）</p>
<ul>
<li>将每个字符出现的次数统计出来（总体样本的频率），将频率看成是权值，将字符放入到树的节点中</li>
<li>那么如果有n个字符，就有n个节点，我们基于这n个节点做叶子节点构造哈夫曼树</li>
<li>哈夫曼树中往左走的标1，往右走的标0</li>
<li>根节点到每个叶子节点路径经过的1&#x2F;0组成的二进制串就是叶子节点对于字符的编码</li>
</ul>
<p>接下来编写代码，相关可能用到的知识？</p>
<ul>
<li>指针模拟声明数组</li>
<li>strcpy(s1, &amp;s2[3])函数：将字符串s2第三个位置开始赋值给s1</li>
</ul>
<p>建立消息this is his message的一颗哈夫曼编码树<br>统计字符出现的次数  </p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241102104756800.png" alt="image-20241102104756800">	</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 规定哈夫曼树左边走0，右边走1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">// 节点的权值</span></span><br><span class="line">    <span class="type">int</span> l, r, p; <span class="comment">// 左右孩子，父亲节点的下标</span></span><br><span class="line">&#125; HuffmanNode, *HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findNode</span><span class="params">(HuffmanTree tree, <span class="type">int</span> k, <span class="type">int</span> *s1, <span class="type">int</span> *s2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minn = <span class="number">0</span>; <span class="comment">// 保存权值最小的两个根节点下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[i].p == <span class="number">0</span>) &#123;</span><br><span class="line">            minn = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[i].p == <span class="number">0</span> &amp;&amp; tree[i].weight &lt; tree[minn].weight) &#123;</span><br><span class="line">            minn = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *s1 = minn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再找次小的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[i].p == <span class="number">0</span> &amp;&amp; i != *s1) &#123;</span><br><span class="line">            minn = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != *s1 &amp;&amp; tree[i].p == <span class="number">0</span> &amp;&amp; tree[i].weight &lt; tree[minn].weight) &#123;</span><br><span class="line">            minn = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *s2 = minn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffmanTree <span class="title">CreateHuffmanTree</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> w[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>; <span class="comment">// 构造的树的节点数</span></span><br><span class="line">    HuffmanTree tree = (HuffmanNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(HuffmanNode) * (m + <span class="number">1</span>)); <span class="comment">// 通过数组的第一个节点表示根节点的父亲，因此要多开一个数据</span></span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化每个叶子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        tree[i].weight = w[i];</span><br><span class="line">        tree[i].l = tree[i].r = tree[i].p = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加n-1个节点</span></span><br><span class="line">    <span class="type">int</span> s1, s2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="comment">// 从数组下标为[1, i-1]的节点中查找 待添加的节点的两个左右孩子的下标</span></span><br><span class="line">        <span class="built_in">findNode</span>(tree, i - <span class="number">1</span>, &amp;s1, &amp;s2); <span class="comment">// 通过地址传参返回得到两个下标</span></span><br><span class="line">        tree[i].weight = tree[s1].weight + tree[s2].weight;</span><br><span class="line">        tree[i].l = s1;</span><br><span class="line">        tree[i].r = s2;</span><br><span class="line">        tree[i].p = <span class="number">0</span>;</span><br><span class="line">        tree[s1].p = tree[s2].p = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>** <span class="title">CreateHuffmanCode</span><span class="params">(HuffmanTree tree, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* t = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * n);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>** codes = (<span class="type">char</span>**)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>*) * n);</span><br><span class="line">    <span class="keyword">if</span> (codes == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化赋值，防止野指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;  n + <span class="number">1</span>; i ++) &#123;</span><br><span class="line">        codes[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于需要从下往上，需要从右往左放一个临时数组，然后再复制到codes数组</span></span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> x, xp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        start = n - <span class="number">1</span>;</span><br><span class="line">        t[start] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        x = i;</span><br><span class="line">        xp = tree[x].p;</span><br><span class="line">        <span class="keyword">while</span> (xp != <span class="number">0</span>) &#123;</span><br><span class="line">            start --;</span><br><span class="line">            <span class="comment">// 判断start位置放1还是0</span></span><br><span class="line">            <span class="keyword">if</span> (x == tree[xp].l) &#123;</span><br><span class="line">                t[start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t[start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x = xp;</span><br><span class="line">            xp = tree[x].p;</span><br><span class="line">        &#125;</span><br><span class="line">        codes[i] = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>*) * (n - start));</span><br><span class="line">        <span class="built_in">strcpy</span>(codes[i], &amp;t[start]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">    t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> codes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">a 1</span></span><br><span class="line"><span class="comment">g 1</span></span><br><span class="line"><span class="comment">m 1</span></span><br><span class="line"><span class="comment">t 1</span></span><br><span class="line"><span class="comment">e 2</span></span><br><span class="line"><span class="comment">h 2</span></span><br><span class="line"><span class="comment">  3</span></span><br><span class="line"><span class="comment">i 3</span></span><br><span class="line"><span class="comment">s 5</span></span><br><span class="line"><span class="comment">1 1 1 1 2 2 3 3 5 2 2 4 4 6 8 11 19</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">105</span>];</span><br><span class="line">    <span class="type">int</span> w[<span class="number">105</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %d&quot;</span>, &amp;s[i], &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*   构造haffman树</span></span><br><span class="line"><span class="comment">         Q:选择哪个树形结构来构造？</span></span><br><span class="line"><span class="comment">         分析:需要从叶子节点往上找根节点，进而与其他子树构造，那么需要保存 该节点+左右孩子+父亲节点+权值</span></span><br><span class="line"><span class="comment">         简单起见，选用数组存树的方式来表示孩子和父亲关系，通过指针模拟开数组。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   </span><br><span class="line">    HuffmanTree tree = <span class="literal">NULL</span>;</span><br><span class="line">    tree = <span class="built_in">CreateHuffmanTree</span>(n, w);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tree[i].weight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据Haffman树进行编码</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">char</span>** codes = <span class="built_in">CreateHuffmanCode</span>(tree, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c:%s\n&quot;</span>, s[i], codes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241102114019088.png" alt="image-20241102114019088">	</p>
<h2 id="1-7-树和森林的转换"><a href="#1-7-树和森林的转换" class="headerlink" title="1.7 树和森林的转换"></a>1.7 树和森林的转换</h2><p>森林：多颗树（&gt;&#x3D;2）</p>
<p>问题1：将树转换成二叉树（提醒：算算法题要<strong>总结【包括为什么没有看到这个点 i写成j等】</strong>，举一反三，首先要完全理解算法，其次不要换个场景就不会了）</p>
<ul>
<li>即孩子兄弟表示法</li>
</ul>
<p>问题2：将森林转换为一颗二叉树</p>
<ul>
<li>把第一颗树的根节点当成总结点，其他树的根节点看成该总结点的兄弟节点</li>
</ul>
<p>举一反三：</p>
<p>对于森林F（k颗树），B是由F得到的二叉树，如果F有n个非叶子节点，B中右指针域为NULL的节点数一共有 n + 1个，分成两部分</p>
<ul>
<li>根指针域 右边一定有1个</li>
<li>而对于其他节点，一个父亲节点，如果有孩子，最后一个孩子的右指针域一定为空，即非叶子节点，n个</li>
</ul>
<p><strong>总结</strong></p>
<p>树：存储方式（3种）</p>
<p>特殊的树：二叉树（2种存储方式） + 操作（遍历 线索化）</p>
<p>BST：增删查</p>
<p>AVL：增删查 —&gt; 旋转调整</p>
<p>应用：并查集 哈夫曼树&#x2F;编码</p>
<p>后续：时间复杂度 图 排序 查找 KMP</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yuezi2048.github.io">yuezi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yuezi2048.github.io/2025/03/25/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E6%A0%91/">https://yuezi2048.github.io/2025/03/25/2.Areas🌐/basic-408/数据结构/4.树/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://yuezi2048.github.io" target="_blank">yuezi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post-share"><div class="social-share" data-image="/img/touxiang.jpg" data-sites="qq,wechat"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/16/2.Areas%F0%9F%8C%90/03.algorithm/01/%E9%93%BE%E8%A1%A8/" title="链表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">链表</div></div><div class="info-2"><div class="info-item-1">化特殊情况为一般情况 </div></div></div></a><a class="pagination-related" href="/2025/04/07/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E5%9B%BE/" title="5.图"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">5.图</div></div><div class="info-2"><div class="info-item-1">五、图5.1 基本概念 图：用来描述事物之间相互联系或相互作用的多对多的关系 图是由两个有限集合构成的，分别是点集V和边集E，其中边是通过两个端点来描述的 分类标准1：有无自边和重边，分为简单图（默认）和非简单图 分类标准2：根据边是否有方向性$&lt;v_i,v_j&gt;$，分为有向图和无向图 对于有向图来说，起点$v_i$是弧尾，终点$v_j$是弧头 一条无向边相当于两条有向边（为图的存储铺垫） 环&#x2F;回路：从图中某点出发，沿着边走，最终回到起点 —&gt; 有向无环图（DAG图） 完全有向图：图有n个点，一共有$n(n-1)$个边 完全无向图：图有n个点，一共有$\frac{n(n-1)}{2}$个边   分类标准3：根据边的数目 分为稠密图和稀疏图 分类标准4：根据边是否有权值 分为...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/10/05/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%20C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" title="1. C语言基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-05</div><div class="info-item-2">1. C语言基础</div></div><div class="info-2"><div class="info-item-1">一、基础语法1.1 编译过程程序为什么要被编译器编译之后才能运行？  机器识别的只有机器语言（由二进制的0和1组成） 因此我们必须将高级语言翻译为能让机器识别的机器语言程序  转换成机器语言的过程是怎么样的？  预处理：展开头文件&#x2F;宏替换&#x2F;去注释&#x2F;条件编译 编译：检查语法，生成汇编代码 汇编：将汇编代码转化为二进制的机器码 链接合成可执行的程序，并在声明的文件找相关的定义  1.2 宏定义和typedef关键字define  使用一个标识符来表示一个字符串，这就是宏，标识符叫宏名 替换文本可以是常数、表达式、字符串、基本数据类型、简单函数  typedef  为数据类型定义新名称，常用于结构体（对struct {} 起一个别名）  #include &lt;stdio.h&gt;#define ll long long#define Max 20#define MAX(x, y) ((x) &gt; (y) ? (x) : (y))typedef long long lll;ll a;lll b;int aa[Max];    typedef...</div></div></div></a><a class="pagination-related" href="/2024/09/12/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.DS%E6%A6%82%E8%BF%B0%E5%92%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/" title="2.DS概述和顺序表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-12</div><div class="info-item-2">2.DS概述和顺序表</div></div><div class="info-2"><div class="info-item-1">一、数据结构基本概念1.1 抽象数据类型我们现在有基本数据类型：  int表示2^32个数字：[-2^31, 2^31-1]  为了表示更多的数据类型表示实际复杂的业务，我们需要一个抽象数据类型 抽象数据类型（可自定义）：静态的数据 + 动态的操作（函数） 引出数据结构Data Structure：数据（data）和数据之间的关系（structure） 我们使用抽象数据类型来定义一个数据结构  分析问题：找到数据之间逻辑的关系（逻辑结构） 解决问题：如何把数据和数据之间的关系存入存储器（存储结构&#x2F;物理结构&#x2F;映像） 关系：存储结构是用计算机语言实现的逻辑结构  1.2 逻辑结构和存储结构数据结构可分为两块：逻辑结构和存储结构 逻辑结构  线性逻辑结构：一对一（线性表 栈 队列） 非线性逻辑结构：一对多（树形结构）、多对多（图型结构）  存储结构  顺序存储：逻辑上相邻的元素，在存储中位置也相邻（数组） 链式存储：逻辑上相邻的元素，存储器的位置可以不相邻，但需要实现逻辑上的相邻（链表） 索引存储，散列存储（Hash）...</div></div></div></a><a class="pagination-related" href="/2024/10/15/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" title="3.栈和队列"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-15</div><div class="info-item-2">3.栈和队列</div></div><div class="info-2"><div class="info-item-1">一、栈1.1 受限逻辑结构栈：受限的线性表（逻辑结构）—&gt; 顺序表和链表是物理结构 线性表：可以在任意位置进行操作 对线性表的操作进行约束：只允许在一端进行添加或者删除，另一端及中间位置不能操作：栈（Stack），生活例子：弹夹  允许操作的一端：栈顶 不允许操作的一段：栈底 如果没有元素：空栈  栈相关方法：  操作 入栈 出栈   判断 判满 判空  性质：先进后出 应用场景：  函数调用的实现（递归） 倒着走的业务逻辑（历史记录 撤销） 内存的堆栈：物理 STL库：stack容器  –&gt; 栈  1.2 顺序存储实现存储结构 顺序存储实现栈：顺序栈 —-&gt; 数组a[MAX_SIZE] 初始化栈：栈底固定不动，在下标0位置。栈顶是活动的，需要变量（int）标记栈顶：top —&gt; 为了描述方便，通常借用指针称呼top变量：栈顶指针  top &#x3D; -1 —&gt; top指向栈顶元素真正的位置 入栈：需判满，top++，指向新的栈顶位置，再在top下标位置放入元素  –&gt; a[++top] &#x3D;...</div></div></div></a><a class="pagination-related" href="/2025/04/07/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E5%9B%BE/" title="5.图"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-07</div><div class="info-item-2">5.图</div></div><div class="info-2"><div class="info-item-1">五、图5.1 基本概念 图：用来描述事物之间相互联系或相互作用的多对多的关系 图是由两个有限集合构成的，分别是点集V和边集E，其中边是通过两个端点来描述的 分类标准1：有无自边和重边，分为简单图（默认）和非简单图 分类标准2：根据边是否有方向性$&lt;v_i,v_j&gt;$，分为有向图和无向图 对于有向图来说，起点$v_i$是弧尾，终点$v_j$是弧头 一条无向边相当于两条有向边（为图的存储铺垫） 环&#x2F;回路：从图中某点出发，沿着边走，最终回到起点 —&gt; 有向无环图（DAG图） 完全有向图：图有n个点，一共有$n(n-1)$个边 完全无向图：图有n个点，一共有$\frac{n(n-1)}{2}$个边   分类标准3：根据边的数目 分为稠密图和稀疏图 分类标准4：根据边是否有权值 分为...</div></div></div></a><a class="pagination-related" href="/2024/12/10/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.%20%E6%8E%92%E5%BA%8F/" title="6. 排序"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-10</div><div class="info-item-2">6. 排序</div></div><div class="info-2"><div class="info-item-1">六、排序（默认升序）  就地排序、非就地排序 –&gt; 空间复杂度 内部排序、外部排序（只能拿一部分数据在内存中排，其他的存在外存中）—&gt; 基本上是内部排序 稳定性：重复数据的相对位置如果不发生变化，那么就是稳定交换 时间复杂度  排序算法包括：  插入：直接插入排序、shell排序（缩小增量排序） 交换：冒泡排序、快速排序 选择：简单选择排序、堆排序（堆） 归并排序：2-路归并 计数排序：桶排序、基数排序  约定  上课案例：a[1] - a[n] 数组分成两部分：乱序区、有序区 初始：整个数组是乱序区 乱序区不断缩小，有序区不断增大 最终：整个数组是有序区    6.1 插入6.1.1 插入排序 初始：a[1]是有序区、a[2]-a[n]是乱序区 每次把乱序区的一个数据插入到有序区中的合适位置，有序区长度+1，乱序区长度-1，执行n-1次为止   如何把数据插入到有序区的合适位置，即对于a[1]~a[i-1]的有序区，如何将a[i]加入到有序区中   找位置：a[i]从后往前比，直到遇到第一个小于等于a[i]的数a[k]，则 k+1...</div></div></div></a><a class="pagination-related" href="/2025/01/02/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.%20%E6%9F%A5%E6%89%BE/" title="7. 查找"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-02</div><div class="info-item-2">7. 查找</div></div><div class="info-2"><div class="info-item-1">连地址法链地址法（拉链法 链接法）：一个地址处只能存放同义词，不存放非同义词，将同义词组成链表，存在对应的地址处即可 不同情况下的ASL：查找一个数据的比较次数 ASL平均查找长度：查找n个数查找长度和 &#x2F; n 开放地址法  ASL成功查找长度 ASL失败查找长度  链地址法  ASL成功查找长度  #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define size 13// 链表的节点结构typedef struct Node &#123;    int data;    struct Node *next;&#125;HNode, *HLink;int Hash(int k) &#123;    return k % 13;&#125;void Insert(HLink hash[], int k) &#123;    int i = Hash(k);        // 申请链表节点    HNode* p = (HNode*)malloc(sizeof(HNode));    p-&gt;data = k; ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yuezi</div><div class="author-info-description">积微者速成</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">603</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuezi2048"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">积微者速成</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%87%E3%80%81%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E9%80%92%E5%BD%92"><span class="toc-text">〇、前置知识——递归</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">一、树的概念和存储方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1.1 树的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">1.2 树的存储方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">1.2.1 双亲表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">1.2.2 孩子表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">1.2.3 孩子兄弟表示法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">1.3 二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A6%82%E5%BF%B5%E5%92%8C%E6%80%A7%E8%B4%A8"><span class="toc-text">1.3.1 二叉树概念和性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">1.3.2 二叉树的存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">1.3.3 二叉树的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%EF%BC%88%E5%B9%BF%E5%BA%A6%EF%BC%89%E9%81%8D%E5%8E%86"><span class="toc-text">层次（广度）遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86"><span class="toc-text">深度遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89"><span class="toc-text">深度遍历（非递归）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-4-%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">1.3.4 线索化二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-BST"><span class="toc-text">1.4 二叉排序树 BST</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">1.4.1 插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="toc-text">1.4.2 查找操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">1.4.3 删除操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91-AVL"><span class="toc-text">1.5 二叉平衡树  AVL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">1.5.1 插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">1.5.2 删除操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%B9%B6%E6%9F%A5%E9%9B%86-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-text">1.6 应用——并查集 哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-1-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">1.6.1 并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-2-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-%E7%BC%96%E7%A0%81"><span class="toc-text">1.6.2 哈夫曼树&#x2F;编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">1.7 树和森林的转换</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/Excalidraw/Drawing%202024-11-01%2015.37.37.excalidraw/" title="Drawing 2024-11-01 15.37.37.excalidraw">Drawing 2024-11-01 15.37.37.excalidraw</a><time datetime="2025-10-31T04:19:26.621Z" title="发表于 2025-10-31 12:19:26">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/01.project/condefather/yupao/back-end/7.%E4%BC%98%E5%8C%96%E4%B8%BB%E9%A1%B5%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/" title="7.优化主页性能-优化批量导入数据">7.优化主页性能-优化批量导入数据</a><time datetime="2025-10-31T04:19:26.102Z" title="发表于 2025-10-31 12:19:26">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/81.%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B8%E6%A0%87Cursor%E5%88%86%E9%A1%B5_%E5%AF%B9%E6%AF%94%E4%BC%A0%E7%BB%9FLIMIT_OFFSET%E5%88%86%E9%A1%B5%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88/" title="81.什么是游标Cursor分页_对比传统LIMIT_OFFSET分页的优势是什么">81.什么是游标Cursor分页_对比传统LIMIT_OFFSET分页的优势是什么</a><time datetime="2025-10-31T04:14:27.000Z" title="发表于 2025-10-31 12:14:27">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/80.%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E5%90%84%E8%87%AA%E4%BC%98%E7%BC%BA%E7%82%B9/" title="80.全量同步和增量同步各自优缺点">80.全量同步和增量同步各自优缺点</a><time datetime="2025-10-31T04:13:32.000Z" title="发表于 2025-10-31 12:13:32">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/79.%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93_%E7%9B%B8%E6%AF%94%E5%8D%95%E6%9D%A1%E6%8F%92%E5%85%A5%E4%BC%98%E5%8A%BF/" title="79.什么是批量数据入库_相比单条插入优势">79.什么是批量数据入库_相比单条插入优势</a><time datetime="2025-10-31T04:03:26.000Z" title="发表于 2025-10-31 12:03:26">2025-10-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/default.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By yuezi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>