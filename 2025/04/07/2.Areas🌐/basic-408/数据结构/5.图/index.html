<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>5.图 | yuezi</title><meta name="author" content="yuezi"><meta name="copyright" content="yuezi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="五、图5.1 基本概念 图：用来描述事物之间相互联系或相互作用的多对多的关系 图是由两个有限集合构成的，分别是点集V和边集E，其中边是通过两个端点来描述的 分类标准1：有无自边和重边，分为简单图（默认）和非简单图 分类标准2：根据边是否有方向性$&lt;v_i,v_j&gt;$，分为有向图和无向图 对于有向图来说，起点$v_i$是弧尾，终点$v_j$是弧头 一条无向边相当于两条有向边（为图的存储铺">
<meta property="og:type" content="article">
<meta property="og:title" content="5.图">
<meta property="og:url" content="https://yuezi2048.github.io/2025/04/07/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E5%9B%BE/index.html">
<meta property="og:site_name" content="yuezi">
<meta property="og:description" content="五、图5.1 基本概念 图：用来描述事物之间相互联系或相互作用的多对多的关系 图是由两个有限集合构成的，分别是点集V和边集E，其中边是通过两个端点来描述的 分类标准1：有无自边和重边，分为简单图（默认）和非简单图 分类标准2：根据边是否有方向性$&lt;v_i,v_j&gt;$，分为有向图和无向图 对于有向图来说，起点$v_i$是弧尾，终点$v_j$是弧头 一条无向边相当于两条有向边（为图的存储铺">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuezi2048.github.io/img/touxiang.jpg">
<meta property="article:published_time" content="2025-04-07T11:31:01.000Z">
<meta property="article:modified_time" content="2025-04-07T11:31:01.000Z">
<meta property="article:author" content="yuezi">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuezi2048.github.io/img/touxiang.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "5.图",
  "url": "https://yuezi2048.github.io/2025/04/07/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E5%9B%BE/",
  "image": "https://yuezi2048.github.io/img/touxiang.jpg",
  "datePublished": "2025-04-07T11:31:01.000Z",
  "dateModified": "2025-04-07T11:31:01.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "yuezi",
      "url": "https://yuezi2048.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuezi2048.github.io/2025/04/07/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E5%9B%BE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?bfb48b678d82bea9f9cc9d59227767e4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"FPH6F2TOJL","apiKey":"06d9ea26c803ba912b4d8e13404ed34d","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '5.图',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/backgound.css"><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">603</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yuezi</span></a><a class="nav-page-title" href="/"><span class="site-name">5.图</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">5.图</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-07T11:31:01.000Z" title="发表于 2025-04-07 19:31:01">2025-04-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-07T11:31:01.000Z" title="更新于 2025-04-07 19:31:01">2025-04-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/basic-408/">basic-408</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">10.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>45分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="五、图"><a href="#五、图" class="headerlink" title="五、图"></a>五、图</h1><h2 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h2><ul>
<li><code>图</code>：用来描述事物之间相互联系或相互作用的多对多的关系</li>
<li>图是由两个有限集合构成的，分别是点集V和边集E，其中边是通过两个端点来描述的</li>
<li>分类标准1：有无自边和重边，分为<code>简单图</code>（默认）和非简单图</li>
<li>分类标准2：根据边是否有方向性$&lt;v_i,v_j&gt;$，分为<code>有向图</code>和<code>无向图</code><ul>
<li>对于有向图来说，起点$v_i$是<code>弧尾</code>，终点$v_j$是<code>弧头</code></li>
<li>一条无向边相当于两条有向边（为图的存储铺垫）</li>
<li>环&#x2F;回路：从图中某点出发，沿着边走，最终回到起点 —&gt; <code>有向无环图（DAG图）</code></li>
<li><code>完全有向图</code>：图有n个点，一共有$n(n-1)$个边</li>
<li><code>完全无向图</code>：图有n个点，一共有$\frac{n(n-1)}{2}$个边</li>
</ul>
</li>
<li>分类标准3：根据边的数目 分为<code>稠密图</code>和<code>稀疏图</code></li>
<li>分类标准4：根据边是否有权值 分为 <code>带权图(网)</code>和<code>无权图</code></li>
</ul>
<hr>
<ul>
<li>端点，邻接点：一条边两个端点为<code>邻接点</code></li>
<li>度：无向图是邻接点的个数，而有向图的度为入度+出度<ul>
<li>有向图中，如果有e条边，那么度数之和为$2e$</li>
</ul>
</li>
<li><code>路径</code>：从一个顶点i到另一个顶点js的顶点序列<ul>
<li><code>简单路径</code>：除起点和终点，其余节点不能重复，即每个节点只经过一次</li>
<li>简单回路：简单路径的回路<ul>
<li>欧拉回路：经过图中各个边恰好一次的环路（即长度恰好等于图中边的总数）</li>
<li>哈密尔顿回路：经过图各个顶点恰好一次的环路（长度恰好构成环路的边）</li>
</ul>
</li>
</ul>
</li>
<li>联通，<code>连通图，联通分量（极大联通子图） </code> —&gt; 无向图<ul>
<li>联通图：任意两个顶点都联通 </li>
<li>极大联通子图：把能包含的点都包含进来，能联通且尽可能大（区分极大和最大，极大可以有多个）</li>
</ul>
</li>
<li><code>强联通，强联通分量</code>  –&gt; 有向图<ul>
<li>强连通：同样是要求任意两个点联通</li>
<li>极大强联通子图：强连通图就一个强联通分量，非强联通图有多个强联通分量</li>
</ul>
</li>
<li>无向图中的<code>极小联通子图</code>（生成树），生成树加一条边就是环</li>
</ul>
<h2 id="5-2-图的存储结构"><a href="#5-2-图的存储结构" class="headerlink" title="5.2 图的存储结构"></a>5.2 图的存储结构</h2><p>图的存储结构：</p>
<p>有向图+无向图：边集数组、邻接矩阵、邻接表（链式前向星 静态链表实现的邻接表）</p>
<p>有向图：<code>十字链表</code></p>
<p>无向图：<code>多重邻接表</code></p>
<p>我们存储：点和边</p>
<p>假设一个图有n个点，m条边（n &lt; 100, m &lt; 10000，w &lt; 10^6，inf &#x3D; 10^6+1）</p>
<hr>
<h3 id="5-2-1-边集数组"><a href="#5-2-1-边集数组" class="headerlink" title="5.2.1 边集数组"></a>5.2.1 边集数组</h3><p>一、边集数组（基于顺序存储）</p>
<ul>
<li>存点：顶点数组 v[105]；v[i] &#x3D; x</li>
<li>存边：结构体数组 e[10005]（<code>边集数组</code>）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">int</span> start;</span><br><span class="line">  <span class="type">int</span> end;</span><br><span class="line">  <span class="type">int</span> weight</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带权有向图为例</span></span><br><span class="line"><span class="type">int</span> v[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里也可以将顶点编号改为直接存节点数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> start, end, weight; <span class="comment">// start, end为顶点编号，weight为权值</span></span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line">Edge e[<span class="number">10005</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到字符x对应的顶点编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i] == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">// x-&gt;y 权值为1</span></span><br><span class="line">    <span class="comment">// 假设顶点数据为char类型</span></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> x, y;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="type">int</span> xi, yi; <span class="comment">// 通过字符得到的顶点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c%c%d&quot;</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line">        xi = <span class="built_in">find</span>(x);</span><br><span class="line">        yi = <span class="built_in">find</span>(y);</span><br><span class="line">        e[i].start = xi;</span><br><span class="line">        e[i].end = yi;</span><br><span class="line">        e[i].weight = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-2-邻接矩阵"><a href="#5-2-2-邻接矩阵" class="headerlink" title="5.2.2 邻接矩阵"></a>5.2.2 邻接矩阵</h3><p> 二、邻接矩阵存图</p>
<ul>
<li>存点：顶点数组v[105]</li>
<li>存边：g[105][105]<ul>
<li>对于无权图来说 g[i][j]表示顶点i到顶点j存在有向边（取值1或0）</li>
<li>对于带权图俩说，g[i][j]表示顶点i到顶点j存在一条权值为w的有向边（取值w和无穷大）</li>
<li>对于无向图来说，一条无向边相当于两条方向相反，权值相同的有向边，即g[i][j]&#x3D;g[j][i]&#x3D;w（对称矩阵）</li>
</ul>
</li>
<li>性质：可以求得某一个顶点的度</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241110200904357.png" alt="image-20241110200904357">	</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带权有向图为例</span></span><br><span class="line"><span class="type">int</span> v[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里也可以将顶点编号改为直接存节点数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> start, end, weight; <span class="comment">// start, end为顶点编号，weight为权值</span></span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line">Edge e[<span class="number">10005</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到字符x对应的顶点编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i] == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">// x-&gt;y 权值为1</span></span><br><span class="line">    <span class="comment">// 假设顶点数据为char类型</span></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> x, y;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="type">int</span> xi, yi; <span class="comment">// 通过字符得到的顶点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c%c%d&quot;</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line">        xi = <span class="built_in">find</span>(x);</span><br><span class="line">        yi = <span class="built_in">find</span>(y);</span><br><span class="line">        e[i].start = xi;</span><br><span class="line">        e[i].end = yi;</span><br><span class="line">        e[i].weight = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-3-邻接表"><a href="#5-2-3-邻接表" class="headerlink" title="5.2.3 邻接表"></a>5.2.3 邻接表</h3><p>三、邻接表</p>
<ul>
<li>存点：顶点数组v[105]</li>
<li>存边：每个顶点的弧尾建立邻接表，以出度为基础构造链表<ul>
<li>逆邻接表：以入度为基础构造链表</li>
</ul>
</li>
</ul>
<img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241110200915821.png" alt="image-20241110200915821" style="zoom:67%;" />	

<p>关于0x7fffffff，本质上是2^31-1（2147483647）是int的最大值</p>
<p>关于0x3f3f3f3f，算出来是1061109567（2147483647 &#x2F; 2 &#x3D; 107…）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 100005</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以带权无向图为例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 边表的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ENode</span> &#123;</span><br><span class="line">    <span class="type">int</span> adj; <span class="comment">// 终点下标</span></span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ENode</span>* next; <span class="comment">// 指向下一条边的指针</span></span><br><span class="line">&#125;ENode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="type">char</span> data; <span class="comment">// 顶点数据</span></span><br><span class="line">    ENode* first; <span class="comment">// 指向该节点的边表</span></span><br><span class="line">&#125; g[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到字符x对应的顶点编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[i].data == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">// x-&gt;y 权值为1</span></span><br><span class="line">    <span class="comment">// 假设顶点数据为char类型</span></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;g[i].data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> x, y;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="type">int</span> xi, yi; <span class="comment">// 通过字符得到的顶点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c %d&quot;</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line">        xi = <span class="built_in">find</span>(x);</span><br><span class="line">        yi = <span class="built_in">find</span>(y);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先把yi插入到x的边表中 表示x-&gt;y</span></span><br><span class="line">        ENode* s = (ENode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ENode));</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;adj = yi;</span><br><span class="line">        s-&gt;w = w;</span><br><span class="line">        s-&gt;next = g[xi].first;</span><br><span class="line">        g[xi].first = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同理再执行y-&gt;x（有向图就无需执行）</span></span><br><span class="line">        ENode* s2 = (ENode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ENode));</span><br><span class="line">        <span class="keyword">if</span> (s2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s2-&gt;adj = xi;</span><br><span class="line">        s2-&gt;w = w;</span><br><span class="line">        s2-&gt;next = g[yi].first;</span><br><span class="line">        g[yi].first = s2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="comment">// 统计x节点的度</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;x);</span><br><span class="line">    xi = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="type">int</span> degree = <span class="number">0</span>;</span><br><span class="line">    ENode *p = g[xi].first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        degree++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, degree);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">ABCD</span></span><br><span class="line"><span class="comment">A B 2</span></span><br><span class="line"><span class="comment">B C 3</span></span><br><span class="line"><span class="comment">A D 6</span></span><br><span class="line"><span class="comment">C D 1</span></span><br><span class="line"><span class="comment">A C 3</span></span><br><span class="line"><span class="comment">D</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="5-2-4-十字链表"><a href="#5-2-4-十字链表" class="headerlink" title="5.2.4 十字链表"></a>5.2.4 十字链表</h3><ul>
<li>将有向图的邻接表进行优化，有向图的邻接表和逆邻接表合二为一构成<code>十字链表</code>，一个链表结点对应一条有向边（<code>弧</code>），其中：<ul>
<li>tail_i是弧尾节点</li>
<li>tail_next是指向下一条弧尾相同的指针（出边）</li>
<li>head_i是弧头下标</li>
<li>head_next是指向下一条弧头相同的指针（入边）</li>
</ul>
</li>
<li>出度：顺着tail_next找，入度：顺着head_next找</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241116211336395.png" alt="image-20241116211336395">	</p>
<p>以下图为例：</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241116213006252.png" alt="image-20241116213006252">	</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 100005</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以带权有向图为例</span></span><br><span class="line"><span class="comment">// 十字链表的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ENode</span> &#123;</span><br><span class="line">    <span class="type">int</span> w; <span class="comment">// 权值</span></span><br><span class="line">    <span class="type">int</span> tail_i, head_i; <span class="comment">// 弧尾、弧头顶点编号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ENode</span>* t_next; <span class="comment">// 弧尾相同的下一条弧（出边）</span></span><br><span class="line">    <span class="keyword">struct</span>  <span class="title class_">ENode</span>* h_next; <span class="comment">// 弧头相同的下一条弧（入边）</span></span><br><span class="line">&#125;ENode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="type">char</span> data; <span class="comment">// 顶点数据</span></span><br><span class="line">    ENode* firstout; <span class="comment">// 指向该节点的出边表</span></span><br><span class="line">    ENode* firstin; <span class="comment">// 指向该节点的入边表</span></span><br><span class="line">&#125; g[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到字符x对应的顶点编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[i].data == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">// x-&gt;y 权值为1</span></span><br><span class="line">    <span class="comment">// 假设顶点数据为char类型</span></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;g[i].data);</span><br><span class="line">        g[i].firstin = g[i].firstout = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> x, y;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="type">int</span> xi, yi; <span class="comment">// 通过字符得到的顶点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入x-&gt;y的边，权值为w，建立十字链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c %d&quot;</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line">        xi = <span class="built_in">find</span>(x);</span><br><span class="line">        yi = <span class="built_in">find</span>(y);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 建立十字链表</span></span><br><span class="line">        ENode* s = (ENode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ENode));</span><br><span class="line">        s-&gt;w = w;</span><br><span class="line">        s-&gt;tail_i = xi;</span><br><span class="line">        s-&gt;head_i = yi;</span><br><span class="line">        <span class="comment">// s插入到y的出边链表中</span></span><br><span class="line">        s-&gt;t_next = g[xi].firstout;</span><br><span class="line">        g[xi].firstout = s;</span><br><span class="line">        <span class="comment">// s插入到y的入边链表中</span></span><br><span class="line">        s-&gt;h_next = g[yi].firstin;</span><br><span class="line">        g[yi].firstin = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="comment">// 统计x节点的入度和出度</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;x);</span><br><span class="line">    xi = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="type">int</span> inDegree = <span class="number">0</span>, outDegree = <span class="number">0</span>;</span><br><span class="line">    ENode *p = g[xi].firstout;</span><br><span class="line">    ENode *q = g[xi].firstin;</span><br><span class="line">    <span class="comment">// 求出度</span></span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        outDegree++;</span><br><span class="line">        p = p-&gt;t_next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求入度</span></span><br><span class="line">    <span class="keyword">while</span> (q) &#123;</span><br><span class="line">        inDegree++;</span><br><span class="line">        q = q-&gt;h_next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;入度：%d\n&quot;</span>, inDegree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出度：%d\n&quot;</span>, outDegree);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 6</span></span><br><span class="line"><span class="comment">ABCD</span></span><br><span class="line"><span class="comment">A B 1</span></span><br><span class="line"><span class="comment">B A 2</span></span><br><span class="line"><span class="comment">C A 3</span></span><br><span class="line"><span class="comment">B C 4</span></span><br><span class="line"><span class="comment">A D 5</span></span><br><span class="line"><span class="comment">C D 6</span></span><br><span class="line"><span class="comment">D</span></span><br><span class="line"><span class="comment">入度：2</span></span><br><span class="line"><span class="comment">出度：0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="5-2-5-多重邻接表"><a href="#5-2-5-多重邻接表" class="headerlink" title="5.2.5 多重邻接表"></a>5.2.5 多重邻接表</h3><ul>
<li>无向图邻接表存在空间浪费问题，一条边存两次，仿照十字链表的方式进行优化，得到多重邻接表<ul>
<li>x_i和y_i是无向边两个端点的下标</li>
<li>x_next是指向下一条连接x点的指针</li>
<li>y_next是指向下一条连接y点的指针</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241116220252382.png" alt="image-20241116220252382">	</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241116221917139.png" alt="image-20241116221917139">	</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 100005</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以带权无向图为例</span></span><br><span class="line"><span class="comment">// 多重邻接表的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ENode</span> &#123;</span><br><span class="line">    <span class="type">int</span> w; <span class="comment">// 权值</span></span><br><span class="line">    <span class="type">int</span> xi, yi; <span class="comment">// 弧尾、弧头顶点编号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ENode</span>* xnext; <span class="comment">// 指向连接y的下一条边</span></span><br><span class="line">    <span class="keyword">struct</span>  <span class="title class_">ENode</span>* ynext; <span class="comment">// 指向连接y的的下一条边</span></span><br><span class="line">&#125;ENode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="type">char</span> data; <span class="comment">// 顶点数据</span></span><br><span class="line">    ENode* first; <span class="comment">// 该结点的边表</span></span><br><span class="line">&#125; g[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到字符x对应的顶点编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[i].data == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">// x-&gt;y 权值为1</span></span><br><span class="line">    <span class="comment">// 假设顶点数据为char类型</span></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;g[i].data);</span><br><span class="line">        g[i].first = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> x, y;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="type">int</span> xi, yi; <span class="comment">// 通过字符得到的顶点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入x-&gt;y的边，权值为w，建立十字链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c %d&quot;</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line">        xi = <span class="built_in">find</span>(x);</span><br><span class="line">        yi = <span class="built_in">find</span>(y);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 建立多重邻接表存该边</span></span><br><span class="line">        ENode* s = (ENode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ENode));</span><br><span class="line">        s-&gt;w = w;</span><br><span class="line">        <span class="comment">// s插入到xi的边表中</span></span><br><span class="line">        s-&gt;xi = xi;</span><br><span class="line">        s-&gt;xnext = g[xi].first;</span><br><span class="line">        g[xi].first = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s插入到yi的边表中</span></span><br><span class="line">        s-&gt;yi = yi;</span><br><span class="line">        s-&gt;ynext = g[yi].first;</span><br><span class="line">        g[yi].first = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="comment">// 统计x节点的入度和出度</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;x);</span><br><span class="line">    xi = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="type">int</span> degree = <span class="number">0</span>;</span><br><span class="line">    ENode* p = g[xi].first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求度</span></span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        degree++;</span><br><span class="line">        <span class="comment">// 注意，这里求度的时候不一定是xnext，需要判断（实际上看输入的）</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;xi == xi) &#123;</span><br><span class="line">            p = p-&gt;xnext;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;yi == xi) &#123;</span><br><span class="line">            p = p-&gt;ynext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;度：%d\n&quot;</span>, degree);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">ABCD</span></span><br><span class="line"><span class="comment">A B 1</span></span><br><span class="line"><span class="comment">B C 2</span></span><br><span class="line"><span class="comment">A C 3</span></span><br><span class="line"><span class="comment">C D 4</span></span><br><span class="line"><span class="comment">A D 5</span></span><br><span class="line"><span class="comment">D</span></span><br><span class="line"><span class="comment">度：2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3-图的遍历"><a href="#5-3-图的遍历" class="headerlink" title="5.3 图的遍历"></a>5.3 图的遍历</h2><ul>
<li>图的遍历：沿着某条搜索路径周游对应的序列，即把图的每个结点访问仅访问一次，分为深度优先遍历和广度优先遍历</li>
</ul>
<h3 id="5-3-1-深度优先遍历-DFS"><a href="#5-3-1-深度优先遍历-DFS" class="headerlink" title="5.3.1 深度优先遍历 DFS"></a>5.3.1 深度优先遍历 DFS</h3><p>深度优先遍历DFS：</p>
<ul>
<li><p>以图中某个点为起点，去访问其一个邻接点，以该邻接点开始再访问其他未访问到的结点</p>
</li>
<li><p>直到访问到某个点 没有未被访问的邻接点，那么就是最深的点（死胡同），此时返回到上一个点，看有没有新的未被访问的临界点</p>
</li>
<li><p>直到所有的点都没有未被访问的邻接点（全部都访问完毕），本次深度优先遍历结束</p>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241117195721801.png" alt="image-20241117195721801">	</p>
<p>以上图为例构造测试样例</p>
<blockquote>
<p> 注：递归代码如果时间复杂度不好算，可从思路分析：</p>
<ul>
<li>最坏情况下，对于每个点都要和邻接矩阵上其他n个点判断，O(n)，然后有n个结点要这样判断，所以O(n)，相乘后为O(n^2)</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DFS：基于邻接表，时间复杂度O(n + m)，基于邻接矩阵，时间复杂度O(n^2)，类比树的遍历，都是基于递归</span></span><br><span class="line"><span class="comment">    1. 首先选定一个未被访问的点v作为起点，并访问该点</span></span><br><span class="line"><span class="comment">    2. 搜索v的邻接点，判断这些邻接点是否被访问过，如果有未被访问的邻接点，则选取一个w，访问该邻接点</span></span><br><span class="line"><span class="comment">        重复执行步骤2，直到没有未被访问过的邻接点为止，直到起点所在的（强）联通分量的点全部被访问完为止</span></span><br><span class="line"><span class="comment">    3. 如果是非（强）连通图，则再选取没有访问到的点，继续步骤1进行访问</span></span><br><span class="line"><span class="comment">以无权有向图(不保证连通)为例---&gt;邻接矩阵为例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// n个点，m条边的无权有向图</span></span><br><span class="line"><span class="type">char</span> v[<span class="number">105</span>]; <span class="comment">// 顶点数组</span></span><br><span class="line"><span class="type">int</span> g[<span class="number">105</span>][<span class="number">105</span>]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="type">int</span> flag[<span class="number">105</span>]; <span class="comment">// flag[i]=0表示未被访问，1表示已被访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i] == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以编号为i为起点，进行深度优先搜索</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, v[i]); <span class="comment">// 访问结点</span></span><br><span class="line">    flag[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归搜索邻接点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[i][j] == <span class="number">1</span> &amp;&amp; flag[j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="type">char</span> x, y;</span><br><span class="line">    <span class="type">int</span> xi, yi;</span><br><span class="line">    <span class="comment">// O(m * n)时间复杂度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">1</span>; i &lt;= m; i ++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        xi = <span class="built_in">find</span>(x);</span><br><span class="line">        yi = <span class="built_in">find</span>(y);</span><br><span class="line">        g[xi][yi] = g[yi][xi] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 时间复杂度O(n^2)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8 9</span></span><br><span class="line"><span class="comment">ABCDEFGH</span></span><br><span class="line"><span class="comment">A B</span></span><br><span class="line"><span class="comment">A C</span></span><br><span class="line"><span class="comment">B D</span></span><br><span class="line"><span class="comment">B E</span></span><br><span class="line"><span class="comment">C F</span></span><br><span class="line"><span class="comment">C G</span></span><br><span class="line"><span class="comment">D H</span></span><br><span class="line"><span class="comment">E H</span></span><br><span class="line"><span class="comment">F G</span></span><br><span class="line"><span class="comment">A B D H E C F G</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="5-3-2-广度优先遍历-BFS"><a href="#5-3-2-广度优先遍历-BFS" class="headerlink" title="5.3.2 广度优先遍历 BFS"></a>5.3.2 广度优先遍历 BFS</h3><p>还是上面这个图</p>
<ul>
<li>从v1走到v2，接下来怎么走到v3？所以要引入<code>队列</code>，在访问v1的时候就事先存储v1的邻接点（类比树的层次遍历）</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241117195721801.png" alt="image-20241117195721801">	</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 105</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BFS(基于队列)：基于邻接表，时间复杂度O(n + m)，基于邻接矩阵，时间复杂度O(n^2)，类比层次遍历，都是基于队列的</span></span><br><span class="line"><span class="comment">    1. 首先选定一个未被访问的点v作为起点，将该点入队</span></span><br><span class="line"><span class="comment">    2. 循环：只要队列非空，队首出列，访问队首结点，将该点所有邻接点入队</span></span><br><span class="line"><span class="comment">        重复执行步骤2，直到队列空为止。</span></span><br><span class="line"><span class="comment">    3. 如果是非（强）连通图，则再选取没有访问到的点，继续步骤1进行访问</span></span><br><span class="line"><span class="comment">以无权有向图(不保证连通)为例---&gt; 邻接表为例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// n个点，m条边的无权有向图</span></span><br><span class="line"><span class="type">int</span> flag[<span class="number">105</span>]; <span class="comment">// flag[i]=0表示未被访问，1表示已被访问（实际上是标记是否入队）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------循环队列----------------------------*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[MAXN];</span><br><span class="line">    <span class="type">int</span> f, r; <span class="comment">// 队首队尾指针</span></span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initQueue</span><span class="params">(Queue* q)</span> </span>&#123;</span><br><span class="line">    q-&gt;f = q-&gt;r = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enQueue</span><span class="params">(Queue* q, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((q-&gt;r + <span class="number">1</span>) % MAXN == q-&gt;f) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列已满！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;data[q-&gt;r] = x;</span><br><span class="line">    q-&gt;r = (q-&gt;r + <span class="number">1</span>) % MAXN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmpty</span><span class="params">(Queue* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;f == q-&gt;r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deQueue</span><span class="params">(Queue* q, <span class="type">int</span>* x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *x = q-&gt;data[q-&gt;f];</span><br><span class="line">    q-&gt;f = (q-&gt;f + <span class="number">1</span>) % MAXN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------循环队列----------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 边表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ENode</span> &#123;</span><br><span class="line">    <span class="type">int</span> adj; <span class="comment">// 邻接点下标</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ENode</span> *next;</span><br><span class="line">&#125;ENode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    ENode *first;</span><br><span class="line">&#125;g[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以i为起点进行BFS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    <span class="built_in">initQueue</span>(&amp;q);</span><br><span class="line">    <span class="built_in">enQueue</span>(&amp;q, i); <span class="comment">// 入队</span></span><br><span class="line">    flag[i] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 保存队首结点下标</span></span><br><span class="line">    ENode *p; <span class="comment">// 保存队首结点指向边表的指针</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>(&amp;q)) &#123;</span><br><span class="line">        <span class="built_in">deQueue</span>(&amp;q, &amp;x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, g[x].data);</span><br><span class="line">        p = g[x].first;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! flag[p-&gt;adj]) &#123;</span><br><span class="line">                <span class="built_in">enQueue</span>(&amp;q, p-&gt;adj);</span><br><span class="line">                flag[p-&gt;adj] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;g[i].data);</span><br><span class="line">        g[i].first = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="type">char</span> x, y;</span><br><span class="line">    <span class="type">int</span> xi, yi;</span><br><span class="line">    <span class="comment">// O(m * n)时间复杂度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">1</span>; i &lt;= m; i ++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将yi结点头插到xi结点的邻接表中</span></span><br><span class="line">        ENode *s = (ENode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ENode));</span><br><span class="line">        s-&gt;adj = yi;</span><br><span class="line">        s-&gt;next = g[xi].first;</span><br><span class="line">        g[xi].first = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无向边，反过来同理</span></span><br><span class="line">        ENode *s2 = (ENode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ENode));</span><br><span class="line">        s2-&gt;adj = xi;</span><br><span class="line">        s2-&gt;next = g[yi].first;</span><br><span class="line">        g[yi].first = s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 时间复杂度O(n + m)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8 9</span></span><br><span class="line"><span class="comment">ABCDEFGH</span></span><br><span class="line"><span class="comment">A B</span></span><br><span class="line"><span class="comment">A C</span></span><br><span class="line"><span class="comment">B D</span></span><br><span class="line"><span class="comment">B E</span></span><br><span class="line"><span class="comment">C F</span></span><br><span class="line"><span class="comment">C G</span></span><br><span class="line"><span class="comment">D H</span></span><br><span class="line"><span class="comment">E H</span></span><br><span class="line"><span class="comment">F G</span></span><br><span class="line"><span class="comment">A B C D E F G H </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="5-4-最小生成树"><a href="#5-4-最小生成树" class="headerlink" title="5.4 最小生成树"></a>5.4 最小生成树</h2><ul>
<li><code>生成树</code>：图的极小联通子图（n个顶点，包含n-1条边使得该子图联通）<ul>
<li>生成树要求：无向图 连通图 无权图</li>
<li>Cayley公式：对于包含n个顶点的无向完全图包含n^(n-2)颗生成树（证明用到prufer序列）</li>
</ul>
</li>
<li><code>最小生成树</code>：无向带权连通图中若干生成树中，边权和最小的生成树就是最小生成树（在有向强连通图中是最小树形图，较复杂）</li>
</ul>
<h3 id="5-4-1-Kruskal（边少-稀疏图）"><a href="#5-4-1-Kruskal（边少-稀疏图）" class="headerlink" title="5.4.1 Kruskal（边少 稀疏图）"></a>5.4.1 Kruskal（边少 稀疏图）</h3><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241118210717340.png" alt="image-20241118210717340" style="zoom:67%;" />	

<img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241118210704513.png" alt="image-20241118210704513" style="zoom: 67%;" />	

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给定带权无向连通图，该图包含n个点，m（&gt;=n-1）条边，n &lt;= 100，默认n个点的编号从0-n-1</span></span><br><span class="line"><span class="comment">求解该图的最小生成树，即需要选出n个点，n-1条边，组成生成树且使得n-1条边的权值和最小，Kruskal算法步骤如下（主要解决两个问题）：</span></span><br><span class="line"><span class="comment">1. n-1条边的权值和最小（把边按照排序从小到大排序 ---&gt; 为了方便表示边 使用边集数组存图，这里使用选择排序）</span></span><br><span class="line"><span class="comment">    选n-1条边，每次选择一条没被选过的权值最小的边---&gt;贪心算法</span></span><br><span class="line"><span class="comment">2. n-1条边使得n个点联通 ---&gt; 有无形成环</span></span><br><span class="line"><span class="comment">    加上一条边后，需要判断是否形成环（即对当前所选的边判断是否已经联通）， 通过并查集来判断：</span></span><br><span class="line"><span class="comment">        初始：认为每个点相互独立，n个点各自看成一棵树</span></span><br><span class="line"><span class="comment">        选边：选中一条边x--y，判断x和y是否属于同一个并查集</span></span><br><span class="line"><span class="comment">            如果x y不属于同一颗树，表示已经选中的边没有使得x和y联通，则可以选中该边，合并x和y，维护并查集</span></span><br><span class="line"><span class="comment">            如果x,y属于同一颗树，表示已经选中的边使得x和y联通，不可以选该边</span></span><br><span class="line"><span class="comment">总的时间复杂度：取决于排序的时间复杂度O(m^2)，而Kruskal算法的时间复杂度O(m)，所以总的时间复杂度为O(m^2)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">&#125;Edge;</span><br><span class="line">Edge e[<span class="number">50005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Edge* a, Edge* b)</span> </span>&#123;</span><br><span class="line">    Edge tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="comment">// O(m^2)</span></span><br><span class="line">    <span class="type">int</span> minn;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt; r; i ++) &#123;</span><br><span class="line">        minn = e[i].w;</span><br><span class="line">        k = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; r; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e[j].w &lt; minn) &#123;</span><br><span class="line">                minn = e[j].w;</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(&amp;e[i], &amp;e[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;排序后：\n&quot;);</span></span><br><span class="line">    <span class="comment">// for (int i = l; i &lt; r; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;(%d %d) %d\n&quot;, e[i].u, e[i].v, e[i].w);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> f[], <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="comment">// 将y合并到x所在的并查集</span></span><br><span class="line">    f[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> f[], <span class="type">int</span> x)</span> </span>&#123; <span class="comment">// 路径压缩</span></span><br><span class="line">    <span class="keyword">if</span> (f[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x] = <span class="built_in">find</span>(f, f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 记录选中的边数</span></span><br><span class="line">    <span class="type">int</span> f[<span class="number">105</span>];</span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">105</span>; i ++) &#123;</span><br><span class="line">        f[i] = i; <span class="comment">// 初始化并查集</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最小生成树的边：\n&quot;</span>);</span><br><span class="line">    <span class="comment">// O(m)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123; <span class="comment">// 选中第i+1条边，判断是否构成环</span></span><br><span class="line">        <span class="type">int</span> fu = <span class="built_in">find</span>(f, e[i].u);</span><br><span class="line">        <span class="type">int</span> fv = <span class="built_in">find</span>(f, e[i].v);</span><br><span class="line">        <span class="keyword">if</span> (fu != fv) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d %d) %d\n&quot;</span>, e[i].u, e[i].v, e[i].w);</span><br><span class="line">            cnt ++;</span><br><span class="line">            <span class="built_in">merge</span>(f, fu, fv); <span class="comment">// 合并并查集</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;e[i].u, &amp;e[i].v, &amp;e[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序 O(m^2)</span></span><br><span class="line">    <span class="built_in">Sort</span>(<span class="number">0</span>, m);</span><br><span class="line">    <span class="comment">// O(n + m) --&gt; O(m)</span></span><br><span class="line">    <span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">9 15</span></span><br><span class="line"><span class="comment">0 1 3</span></span><br><span class="line"><span class="comment">0 5 4</span></span><br><span class="line"><span class="comment">1 6 6</span></span><br><span class="line"><span class="comment">6 5 7</span></span><br><span class="line"><span class="comment">1 2 8</span></span><br><span class="line"><span class="comment">1 8 5</span></span><br><span class="line"><span class="comment">2 8 2</span></span><br><span class="line"><span class="comment">2 3 12</span></span><br><span class="line"><span class="comment">8 3 11</span></span><br><span class="line"><span class="comment">6 3 14</span></span><br><span class="line"><span class="comment">6 7 9</span></span><br><span class="line"><span class="comment">5 4 18</span></span><br><span class="line"><span class="comment">3 7 6</span></span><br><span class="line"><span class="comment">7 4 1</span></span><br><span class="line"><span class="comment">3 4 10</span></span><br><span class="line"><span class="comment">最小生成树的边：</span></span><br><span class="line"><span class="comment">(7 4) 1</span></span><br><span class="line"><span class="comment">(2 8) 2</span></span><br><span class="line"><span class="comment">(0 1) 3</span></span><br><span class="line"><span class="comment">(0 5) 4</span></span><br><span class="line"><span class="comment">(1 8) 5</span></span><br><span class="line"><span class="comment">(3 7) 6</span></span><br><span class="line"><span class="comment">(1 6) 6</span></span><br><span class="line"><span class="comment">(6 7) 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="5-4-2-Prim（点少-稠密图）"><a href="#5-4-2-Prim（点少-稠密图）" class="headerlink" title="5.4.2 Prim（点少 稠密图）"></a>5.4.2 Prim（点少 稠密图）</h3><img src="/img/loading.gif" data-original="file:///D:\Tencent Files\1477500338\nt_qq\nt_data\Pic\2024-11\Ori\b70a1ff4f41bb5abc844225bd64378d0.png" alt="img" style="zoom: 50%;" />	

<img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241130201938480.png" alt="image-20241130201938480" style="zoom: 80%;" />	

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 10005</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给定带权无向连通图，该图包含n个点，m（&gt;=n-1）条边，n &lt;= 100，默认n个点的编号从0-n-1，边权最大10000</span></span><br><span class="line"><span class="comment">求解该图的最小生成树，即需要选出n个点，n-1条边，组成生成树且使得n-1条边的权值和最小，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">选点的角度考虑：</span></span><br><span class="line"><span class="comment">执行过程中，将所有的点分为两类：</span></span><br><span class="line"><span class="comment">    A类：已经加入到生成树的点</span></span><br><span class="line"><span class="comment">    B类：还未加入到生成树的点</span></span><br><span class="line"><span class="comment">    （通过一个标记数组维护每个点的类别）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    点x与生成树中某个点的边的权值(距离)——点x到生成树的距离</span></span><br><span class="line"><span class="comment">    点x到生成树的最小距离dist：对于点x到生成树中多个相连的边，边中最小的权值就是点x到生成树的最小距离dist</span></span><br><span class="line"><span class="comment">    而如果一个点和生成树中的每个点都没有直接相连的边，认为该点到生成树的距离为无穷大</span></span><br><span class="line"><span class="comment">    （通过一维数组维护dist数组来表示每个点到生成树的最小距离）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    怎么选点：</span></span><br><span class="line"><span class="comment">    1. 第一个点选谁？任选一个点X，作为A类点</span></span><br><span class="line"><span class="comment">    2. 循环n-1次，每次在B类点中选择一个dist值的点，连到生成树中（成为A类点），并通过该点去更新该点 B类邻接点的dist</span></span><br><span class="line"><span class="comment">        选中一个点加入到生成树后，该点的B类邻接点到生成树的距离可能会变小 ---&gt; 生成树的距离要更新</span></span><br><span class="line"><span class="comment">        如此循环，每一步都是选取权值最小的边，最后得到的总体就是最小生成树</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">代码思路：</span></span><br><span class="line"><span class="comment">    维护一个dist[]数组，dist[i]=x，表示i点到生成树的最小距离为x，初始化为无穷大</span></span><br><span class="line"><span class="comment">    维护一个flag[]标记数组，flag[i]=0，表示i点未被加入到生成树， = 1 则表示已经加入到生成树中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1. 定义一个起点s，该点加入到生成树中，flag[s]=1，更新s邻接点中flag[]=0的邻接点的dist值</span></span><br><span class="line"><span class="comment">    2. 循环n-1次：</span></span><br><span class="line"><span class="comment">        （1）选中一个flag=0，并且dist最小的点x</span></span><br><span class="line"><span class="comment">        （2）将x加入到生成树中，flag[x]=1</span></span><br><span class="line"><span class="comment">        （3）如果dist值能变小的话，更新x点邻接点中flag[]=0的邻接点的dist值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注：需额外定义adj[i]=j 表示i点到生成树中j点的距离为最小距离(初始化为i)</span></span><br><span class="line"><span class="comment">    作业：邻接表怎么写？</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// n是点数，m是边数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[<span class="number">105</span>][<span class="number">105</span>]; <span class="comment">// 使用邻接矩阵存图</span></span><br><span class="line"><span class="type">int</span> dist[<span class="number">105</span>]; <span class="comment">// 定义顶点到生成树最小距离</span></span><br><span class="line"><span class="type">int</span> adj[<span class="number">105</span>]; <span class="comment">// 定义顶点到生成树最小距离对应的端点</span></span><br><span class="line"><span class="type">int</span> flag[<span class="number">105</span>]; <span class="comment">// 定义该点是否加入到生成树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度O(n^2)，如果是邻接表存图（只有找邻接边的代码有区别） ——  仍然是O(n^2)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 起点加到生成树</span></span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    flag[s] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新s邻接点中flag为0的dist —— O(n)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[s][i] &lt; INF &amp;&amp; flag[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[s][i] &lt; dist[i]) &#123;</span><br><span class="line">                adj[i] = s;</span><br><span class="line">                dist[i] = g[s][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> minn; <span class="comment">// 最小的dist值</span></span><br><span class="line">    <span class="type">int</span> t; <span class="comment">// t点的dist最小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选剩下的n-1个点 —— O(n^2)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">        minn = INF;</span><br><span class="line">        t = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 寻找到生成树最近的点t</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[j] == <span class="number">0</span> &amp;&amp; dist[j] &lt; minn) &#123;</span><br><span class="line">                minn = dist[j];</span><br><span class="line">                t = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 到生成树最近的点t加入到生成树中</span></span><br><span class="line">        flag[t] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d) %d\n&quot;</span>, t, adj[t], minn);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 寻找t的邻接点中flag为0的dist</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[j] == <span class="number">0</span> &amp;&amp; g[t][j] &lt; dist[j]) &#123;</span><br><span class="line">                adj[j] = t;</span><br><span class="line">                dist[j] = g[t][j]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        dist[i] = INF;</span><br><span class="line">        adj[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            g[i][j] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x, y, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line">        g[x][y] = g[y][x] = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Prim</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">9 15</span></span><br><span class="line"><span class="comment">0 1 3</span></span><br><span class="line"><span class="comment">0 5 4</span></span><br><span class="line"><span class="comment">1 6 6</span></span><br><span class="line"><span class="comment">6 5 7</span></span><br><span class="line"><span class="comment">1 2 8</span></span><br><span class="line"><span class="comment">1 8 5</span></span><br><span class="line"><span class="comment">2 8 2</span></span><br><span class="line"><span class="comment">2 3 12</span></span><br><span class="line"><span class="comment">8 3 11</span></span><br><span class="line"><span class="comment">6 3 14</span></span><br><span class="line"><span class="comment">6 7 9</span></span><br><span class="line"><span class="comment">5 4 18</span></span><br><span class="line"><span class="comment">3 7 6</span></span><br><span class="line"><span class="comment">7 4 1</span></span><br><span class="line"><span class="comment">3 4 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(1, 0) 3</span></span><br><span class="line"><span class="comment">(5, 0) 4</span></span><br><span class="line"><span class="comment">(8, 1) 5</span></span><br><span class="line"><span class="comment">(2, 8) 2</span></span><br><span class="line"><span class="comment">(6, 1) 6</span></span><br><span class="line"><span class="comment">(7, 6) 9</span></span><br><span class="line"><span class="comment">(4, 7) 1</span></span><br><span class="line"><span class="comment">(3, 7) 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="5-5-最短路径"><a href="#5-5-最短路径" class="headerlink" title="5.5 最短路径"></a>5.5 最短路径</h2><ul>
<li><p><code>最短路径</code>：给定一个图，确定一个点为起点，求该点到其他点的最短路径（最短距离）</p>
<ul>
<li>如果该图是无权图，两点间的距离就是两点之间路径上的边的数目，如果有多条路径，边数最少的就是最短路径，对应的距离就是最小距离（可以看成每条边权值一样的带权图）</li>
<li>如果该图是带权图，两点间的距离就是两点之间路径上的边的权值之和，如果有多条路径，权值和最小的就是最短路径，对应的距离就是最小距离</li>
</ul>
</li>
<li><p><code>单源最短路径</code>：起点固定，求该起点到其他任意一点的最短路径，输出其长度</p>
</li>
<li><p><code>多源最短路径</code>：起点不固定，任意一个点都可以做起点，图中任意两点之间的最短路径（举一反三，可看成n个点 分别以每个点为起点执行单源路径算法）</p>
</li>
</ul>
<hr>
<ul>
<li><code>BFS</code> 可以求无权图的单源最短路径问题（后续DFS BFS可以用于解的搜索）</li>
<li>dijkstra算法  —&gt; 贪心 –&gt; 单源最短路径</li>
<li>Floyd算法  –&gt; 动态规划 —&gt; 多源最短路径 —&gt; 动态规划讲完说</li>
</ul>
<h3 id="5-5-1-dijkstra"><a href="#5-5-1-dijkstra" class="headerlink" title="5.5.1 dijkstra"></a>5.5.1 dijkstra</h3><ul>
<li>给定无向带权图，n个点（n&lt;100），m条边（m &lt; 5000），以点s为起点，求s到其他n-1个点的最短路径，输出最短路径的长度 和 路径所经过的点</li>
<li>解决问题的思路：不断引入中转点，如果走这个中转点是否能减少路径长度<ul>
<li>对每个点维护 dist[i] &#x3D; x：起点到i点的最短路径是x</li>
<li>初始化：dist[s] &#x3D; 0，dist[i] &#x3D; g[s][i]  &#x2F; INF （如果是s点的邻接点，就是g[s][i]，否则就是INF），flag[s] &#x3D; 1  其他的点flag[i] &#x3D; 0</li>
<li>逐渐更新起点到每个点的最短路径的长度，直到起点到每个点的最短路径都确定为止。<ul>
<li>1.已经确定最短路径的点，起点到该点的最短距离已找到，不能再缩小</li>
<li>2.没有确定最短路径的点，起点到该点的最短路径还未找到，还有缩小的空间</li>
<li>初始时，s点是1类点，其他点是2类点（2类点中dist最小的点可以确定，反证法证明，无法经过中转点过来的路径长度比其更小）</li>
<li>引入dist数组、flag数组和path数组，循环n-1次（每次将一个2类点确定为1类点）<ul>
<li>path[i]&#x3D;j：在起点到i点的最短路径中，i点的上一个点是j点<ul>
<li>如path[i] &#x3D; j, path[j] &#x3D; k，path[k] &#x3D; z （z —-&gt; k  —-&gt; j —&gt; i）</li>
</ul>
</li>
<li>每次确定2类点中dist值最小的最短路径，长度就是该点的dist</li>
<li>并以该点作为中转点，去更新该点邻接点的dist<ul>
<li>如果dist[k] + g[k][j] &lt; dist[j]  –&gt; dist[j] &#x3D; dist[k]  + g[k][j] , path[j] &#x3D; k</li>
<li>大体和prim类似，那个dist是计算点到生成树的距离，而这个是单源路径的距离</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：带负边权的图，不适用于用dijkstra算法，因为此时使用dist值最小的顶点无法确定最短路径的点（此时错误的把0到2的最短路径确定为7了）</p>
<img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241201123909696.png" alt="image-20241201123909696" style="zoom: 80%;" />	</blockquote>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241201123151010.png" alt="image-20241201123151010">	</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 10005</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵存图，无向带权图为例，默认从0开始</span></span><br><span class="line"><span class="type">int</span> g[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dist[<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> flag[<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> path[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以s为起点，执行dijsktra</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    flag[s] = <span class="number">1</span>;</span><br><span class="line">    path[s] = s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用起点更新起点的邻接点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[s][i] &lt; INF) &#123;</span><br><span class="line">            dist[i] = g[s][i];</span><br><span class="line">            path[i] = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认剩下n-1个点的最短路径</span></span><br><span class="line">    <span class="type">int</span> minn = <span class="number">0</span>; <span class="comment">// dist最小的值</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>; <span class="comment">// dist最小编号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">        minn = INF;</span><br><span class="line">        k = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未确定最短路径的点中，找dist最小的点k</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[j] == <span class="number">0</span> &amp;&amp; dist[j] &lt; minn) &#123;</span><br><span class="line">                minn = dist[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是非连通图，此时极大联通子图已经查找完毕</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flag[k] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以k点更新k的邻接点的dist</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[j] == <span class="number">0</span> &amp;&amp; dist[k] + g[k][j] &lt; dist[j]) &#123;</span><br><span class="line">                dist[j] = dist[k] + g[k][j];</span><br><span class="line">                path[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        dist[i] = INF;</span><br><span class="line">        flag[i] = <span class="number">0</span>;</span><br><span class="line">        path[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) g[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                g[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x, y, w, s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line">        g[x][y] = g[y][x] = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s);</span><br><span class="line">    <span class="built_in">dijkstra</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n起点到%d点的最短路径距离是%d，&quot;</span>, i, dist[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最短路径是（逆序）：&quot;</span>);</span><br><span class="line">        p = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p);</span><br><span class="line">        <span class="keyword">while</span> (path[p] != p) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[p]);</span><br><span class="line">            p = path[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">9 16</span></span><br><span class="line"><span class="comment">0 1 1</span></span><br><span class="line"><span class="comment">0 2 5</span></span><br><span class="line"><span class="comment">1 2 3</span></span><br><span class="line"><span class="comment">1 3 7</span></span><br><span class="line"><span class="comment">1 4 5</span></span><br><span class="line"><span class="comment">2 4 1</span></span><br><span class="line"><span class="comment">2 5 7</span></span><br><span class="line"><span class="comment">3 4 2</span></span><br><span class="line"><span class="comment">3 6 3</span></span><br><span class="line"><span class="comment">4 5 3</span></span><br><span class="line"><span class="comment">4 6 6</span></span><br><span class="line"><span class="comment">4 7 9</span></span><br><span class="line"><span class="comment">5 7 5</span></span><br><span class="line"><span class="comment">6 7 2</span></span><br><span class="line"><span class="comment">6 8 7</span></span><br><span class="line"><span class="comment">7 8 4</span></span><br><span class="line"><span class="comment">0 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">起点到0点的最短路径距离是0，最短路径是（逆序）：0</span></span><br><span class="line"><span class="comment">起点到1点的最短路径距离是1，最短路径是（逆序）：1 0</span></span><br><span class="line"><span class="comment">起点到2点的最短路径距离是4，最短路径是（逆序）：2 1 0</span></span><br><span class="line"><span class="comment">起点到3点的最短路径距离是7，最短路径是（逆序）：3 4 2 1 0</span></span><br><span class="line"><span class="comment">起点到4点的最短路径距离是5，最短路径是（逆序）：4 2 1 0</span></span><br><span class="line"><span class="comment">起点到5点的最短路径距离是8，最短路径是（逆序）：5 4 2 1 0</span></span><br><span class="line"><span class="comment">起点到6点的最短路径距离是10，最短路径是（逆序）：6 3 4 2 1 0</span></span><br><span class="line"><span class="comment">起点到7点的最短路径距离是12，最短路径是（逆序）：7 6 3 4 2 1 0</span></span><br><span class="line"><span class="comment">起点到8点的最短路径距离是16，最短路径是（逆序）：8 7 6 3 4 2 1 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="5-6-DAG图应用"><a href="#5-6-DAG图应用" class="headerlink" title="5.6 DAG图应用"></a>5.6 DAG图应用</h2><h3 id="5-6-1-拓扑排序（AOV网）"><a href="#5-6-1-拓扑排序（AOV网）" class="headerlink" title="5.6.1 拓扑排序（AOV网）"></a>5.6.1 拓扑排序（AOV网）</h3><ul>
<li>DAG图：有项无环图（用于工程项目&#x2F;流程管理）</li>
<li>活动：一个工程或者项目或者某种流程，可以分为若干个小的工程或阶段，把小的工程&#x2F;阶段称为活动</li>
<li>AOV网：用于表示项目&#x2F;工程的有向五环图，在这个有向图中，用顶点表示活动，拥有向边表示活动之间的先后次序&#x2F;依赖关系<ul>
<li>AOV网一定是DAG图</li>
</ul>
</li>
<li>拓扑序列：通过AOV网得到的一个活动之间的先后次序&#x2F;序列，就叫拓扑序列<ul>
<li>有向无环图一定有拓扑序列</li>
<li>有向带环图不能得到拓扑序列</li>
</ul>
</li>
<li>拓扑排序：根据有向图构造拓扑序列的过程</li>
</ul>
<p>给出n个顶点的有环图，如果该图无环，求出该图的拓扑序列，如果有环，输出-1。</p>
<ul>
<li>选出一个没有前驱结点的点输出  —&gt;  选一个入度为0的点x输出（通过栈维护入度为0的结点）</li>
<li>删除点x的所有出边（即x邻接点的入边） —&gt;  点x的邻接点的入度-1</li>
<li>重复上述两个步骤 n - 1次</li>
</ul>
<p>算法实现</p>
<ul>
<li>引入入度数组ind[]，栈s</li>
<li>（1）建图，维护每个点的入度</li>
<li>（2）遍历所有点，将入度为0的点入栈（下标入栈）</li>
<li>（3）循环：栈非空（有入度为0的点），该点出栈，加入到拓扑序列中，将该点邻接点的入度-1，如果减为0了，将该邻接点加入到栈中</li>
<li>（4）栈空时，循环结束，此时找到拓扑序列</li>
</ul>
<blockquote>
<p>注：拓扑排序本身可以判环，根据拓扑序列的个数是否为n个来判断</p>
</blockquote>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241202163629997.png" alt="image-20241202163629997">	</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 10001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stackNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stackNode</span> *next;</span><br><span class="line">&#125;SNode, *Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个栈</span></span><br><span class="line"><span class="function">Stack <span class="title">InitStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack s = (SNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SNode));</span><br><span class="line">    <span class="comment">// if s == NULL</span></span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="function">Stack <span class="title">Push</span><span class="params">(Stack s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    Stack p = (SNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SNode));</span><br><span class="line">    <span class="comment">// if p == NULL</span></span><br><span class="line">    p-&gt;data = k;</span><br><span class="line">    p-&gt;next = s-&gt;next;</span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmpty</span><span class="params">(Stack s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;next == <span class="literal">NULL</span> ? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getTop</span><span class="params">(Stack s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(s) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;next-&gt;data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="function">Stack <span class="title">Pop</span><span class="params">(Stack s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(s) == <span class="number">0</span>) &#123;</span><br><span class="line">        SNode *p = s-&gt;next;</span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  -------------图的代码----------------------</span></span><br><span class="line"><span class="comment">// 使用邻接表存图</span></span><br><span class="line"><span class="comment">// 边表结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ENode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data; <span class="comment">// 邻接点的下标</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ENode</span> *next;</span><br><span class="line">&#125;ENode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">table</span> &#123;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">    ENode *first;</span><br><span class="line">&#125;g[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// 顶点和边的数量</span></span><br><span class="line"><span class="type">int</span> ind[<span class="number">105</span>]; <span class="comment">// 入度</span></span><br><span class="line"><span class="type">char</span> topo[<span class="number">105</span>]; <span class="comment">// 拓扑序列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[i].d == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度，邻接表存图等价于遍历的时间复杂度，为O(n + m)</span></span><br><span class="line"><span class="comment">// 如果是邻接矩阵，则为O(n^2)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TopoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack s = <span class="built_in">InitStack</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123; <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">if</span> (ind[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="built_in">Push</span>(s, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>; <span class="comment">// 拓扑数组的下标</span></span><br><span class="line">    <span class="type">int</span> top; <span class="comment">// 栈顶元素</span></span><br><span class="line">    <span class="type">int</span> tmp; <span class="comment">// 遍历过程中，边表的元素</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isEmpty</span>(s) == <span class="number">0</span>) &#123; <span class="comment">// O(n + m)</span></span><br><span class="line">        top = <span class="built_in">getTop</span>(s);</span><br><span class="line">        s = <span class="built_in">Pop</span>(s);</span><br><span class="line">        topo[k ++] = g[top].d; <span class="comment">// 栈顶元素加入到序列中</span></span><br><span class="line">        ENode *p = g[top].first;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tmp = p-&gt;data;</span><br><span class="line">            ind[tmp] --;</span><br><span class="line">            <span class="keyword">if</span> (ind[tmp] == <span class="number">0</span>) &#123;</span><br><span class="line">                s = <span class="built_in">Push</span>(s, tmp);</span><br><span class="line">            &#125; </span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k == n ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 无环返回1，有环返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;g[i].d);</span><br><span class="line">        g[i].first = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> x, y;</span><br><span class="line">    <span class="type">int</span> xi, yi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) &#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        xi = <span class="built_in">find</span>(x);</span><br><span class="line">        yi = <span class="built_in">find</span>(y);</span><br><span class="line">        ind[yi] ++; <span class="comment">// 统计入度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建图</span></span><br><span class="line">        ENode *p = (ENode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ENode));</span><br><span class="line">        p-&gt;data = yi;</span><br><span class="line">        p-&gt;next = g[xi].first;</span><br><span class="line">        g[xi].first = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求拓扑序列（结果返回是否存在环）</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="built_in">TopoSort</span>();</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i ++ ) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, topo[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6 8</span></span><br><span class="line"><span class="comment">ABCDEF</span></span><br><span class="line"><span class="comment">A B</span></span><br><span class="line"><span class="comment">A C</span></span><br><span class="line"><span class="comment">A D</span></span><br><span class="line"><span class="comment">C B</span></span><br><span class="line"><span class="comment">C E</span></span><br><span class="line"><span class="comment">F D</span></span><br><span class="line"><span class="comment">F E</span></span><br><span class="line"><span class="comment">D E</span></span><br><span class="line"><span class="comment">F A C B D E</span></span><br><span class="line"><span class="comment">(F E 改成 E F 应该输出-1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-2-关键路径（AOE网）"><a href="#3-6-2-关键路径（AOE网）" class="headerlink" title="3.6.2 关键路径（AOE网）"></a>3.6.2 关键路径（AOE网）</h3><ul>
<li><p><code>AOV网</code>：顶点表示活动的有向图，用于工程&#x2F;项目的管理，用户有向边表示活动之间的先后次序</p>
</li>
<li><p><code>AOE网</code>：用边表示活动的有向图，边的权值是活动所需时间，顶点表示事件，事件的发生标志活动可以开始或者结束</p>
<ul>
<li>活动：是一个完整的流程，可能由多个事件组成（活动的开始、活动的结束）</li>
<li>事件：瞬时间发生的一个动作</li>
<li>关键路径：在AOE网中，有些活动可以并行执行，从起点到终点就有多条路径，每条路径的边权之和，就是各条路径上所有活动的总工期，其中最长的路径（边权和最大）就是关键路径，关键路径的总时间就是该工程的工期，关键路径上的活动就是关键活动</li>
</ul>
<blockquote>
<p>注：关键路径不唯一</p>
</blockquote>
</li>
</ul>
<p>相关术语</p>
<ul>
<li>ETV：事件最早发生时间</li>
<li>LTV：事件最晚发生时间</li>
<li>ETE：活动的最早开始时间</li>
<li>LTE：活动的最晚开始时间</li>
</ul>
<blockquote>
<p>对于关键活动来说，ETE &#x3D; LTE，而非关键活动，则存有余量，ETE !&#x3D; LTE</p>
</blockquote>
<hr>
<p>问：给定一个AOE网，如何找关键路径？ </p>
<ul>
<li>找到所有的关键活动</li>
<li>计算所有活动的ETE和ETE  &#x3D; LTE<ul>
<li>如果相等就是关键活动，否则就不是关键活动</li>
</ul>
</li>
</ul>
<p>计算方式（事件的发生标志着活动的开始和结束）</p>
<ul>
<li><p>活动最早开始时间 ETE &#x3D;  该边起点事件的最早时间时间 ETV</p>
</li>
<li><p>活动最晚开始时间 LTE &#x3D; 该边终点事件最晚开始时间 -  该活动的时长 &#x3D; LTV -  w</p>
</li>
</ul>
<blockquote>
<p>注：一个事件的最晚开始时间并不是其出边活动的最晚开始时间（因为事件的最晚开始时间取决于多个活动）</p>
</blockquote>
<p>根据上述计算公式计算所有事件（顶点）的ETV 和 LTV，假设有n个顶点</p>
<ul>
<li><p>（1）计算ETV[i] &#x3D; x，表示事件i的最早发生时间，假设起点顶点是s，则ETV[s] &#x3D; 0 </p>
<ul>
<li>基于拓扑序列，求其他点的最早发生时间：ETV[i] &#x3D; max(ETV[i], ETV[j] + w)  （因为要确保最早发生的情况下，前置活动全部完成）</li>
</ul>
</li>
<li><p>（2）计算LTV[i] &#x3D; x，表示事件i的最晚发生事件，假设终点是e，则LTV[e] &#x3D; ETV[e]（因为起终点一定是关键路径上的事件）</p>
<ul>
<li>基于逆拓扑序列，求其他点的最晚发生事件，LTV[i] &#x3D; min(LTV[i], LTV[j] + w)（因为要确保所有后置任务在最晚的情况下来得及做）</li>
</ul>
</li>
<li><p>（3）求解得到的ETV和LTV，得到ETE和LTE，根据ETE &#x3D; LTE得到是否为关键路径</p>
</li>
</ul>
<p>关键路径的作用：求解关键活动，工期时间</p>
<p>应用：工程项目管理方法</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241204151010545.png" alt="image-20241204151010545">	</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 10001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链栈的声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stackNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stackNode</span> *next;</span><br><span class="line">&#125;SNode, *Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个栈</span></span><br><span class="line"><span class="function">Stack <span class="title">InitStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack s = (SNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SNode));</span><br><span class="line">    <span class="comment">// if s == NULL</span></span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="function">Stack <span class="title">Push</span><span class="params">(Stack s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    Stack p = (SNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SNode));</span><br><span class="line">    <span class="comment">// if p == NULL</span></span><br><span class="line">    p-&gt;data = k;</span><br><span class="line">    p-&gt;next = s-&gt;next;</span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmpty</span><span class="params">(Stack s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;next == <span class="literal">NULL</span> ? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getTop</span><span class="params">(Stack s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(s) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;next-&gt;data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="function">Stack <span class="title">Pop</span><span class="params">(Stack s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(s) == <span class="number">0</span>) &#123;</span><br><span class="line">        SNode *p = s-&gt;next;</span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  -------------图的代码----------------------</span></span><br><span class="line"><span class="comment">// AOE网，保证是DAG图</span></span><br><span class="line"><span class="comment">// 使用邻接表存图：时间复杂度O(|V|+|E|)，邻接矩阵存图O(|V|^2)</span></span><br><span class="line"><span class="comment">// 边表结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ENode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data; <span class="comment">// 邻接点的下标</span></span><br><span class="line">    <span class="type">int</span> w; <span class="comment">// 边的权值</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ENode</span> *next;</span><br><span class="line">&#125;ENode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">table</span> &#123;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">    ENode *first;</span><br><span class="line">&#125;g[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// 顶点和边的数量</span></span><br><span class="line"><span class="type">int</span> ind[<span class="number">105</span>]; <span class="comment">// 入度</span></span><br><span class="line"><span class="type">int</span> topo[<span class="number">105</span>]; <span class="comment">// 拓扑序列（存放顶点的下标）</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> etv[<span class="number">105</span>]; <span class="comment">// 事件的最早发生时间</span></span><br><span class="line"><span class="type">int</span> ltv[<span class="number">105</span>]; <span class="comment">// 事件的最晚发生时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxx</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minn</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[i].d == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TopoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack s = <span class="built_in">InitStack</span>(); <span class="comment">// 初始化栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        etv[i] = <span class="number">0</span>; <span class="comment">// 起点的最早发生时间顺带赋值为0了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ind[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="built_in">Push</span>(s, i); <span class="comment">// 将起点入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="comment">// 出栈的数据</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>; <span class="comment">// 拓扑数组的下标</span></span><br><span class="line">    ENode *p = <span class="literal">NULL</span>; <span class="comment">// 遍历边表指针</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isEmpty</span>(s) == <span class="number">0</span>) &#123;</span><br><span class="line">        i = <span class="built_in">getTop</span>(s);</span><br><span class="line">        s = <span class="built_in">Pop</span>(s);</span><br><span class="line">        topo[k++] = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历出边邻接点</span></span><br><span class="line">        p = g[i].first;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            j = p-&gt;data; <span class="comment">// i---w---&gt;j</span></span><br><span class="line">            <span class="comment">// 更新etv[j]</span></span><br><span class="line">            etv[j] = <span class="built_in">maxx</span>(etv[j], etv[i] + p-&gt;w);</span><br><span class="line"></span><br><span class="line">            ind[j]--;</span><br><span class="line">            <span class="keyword">if</span> (ind[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                s = <span class="built_in">Push</span>(s, j);</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CriticalPath</span><span class="params">()</span> </span>&#123; <span class="comment">// O(|V|+|E|)</span></span><br><span class="line">    <span class="type">int</span> end = topo[n - <span class="number">1</span>]; <span class="comment">// 通过拓扑数组得到终点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        ltv[i] = etv[end]; <span class="comment">// 初始化事件最晚发生时间，终点的ltv此时确定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举逆拓扑序列，求得每个点的最晚发生时间</span></span><br><span class="line">    <span class="comment">// 时间复杂度O(|V|+|E|)</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    ENode *p = <span class="literal">NULL</span>; <span class="comment">// 遍历边表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = n - <span class="number">1</span>; k &gt;= <span class="number">1</span>; k -- ) &#123;</span><br><span class="line">        i = topo[k];</span><br><span class="line">        p = g[i].first;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            j = p-&gt;data; <span class="comment">// i-&gt;j，此时ltv[j]已求出</span></span><br><span class="line">            ltv[i] = <span class="built_in">minn</span>(ltv[i], ltv[j] - p-&gt;w);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的边，根据etv和ltv计算ete和lte找关键活动</span></span><br><span class="line">    <span class="comment">// 时间复杂度O(|V|+|E|)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;以下是所有的关键活动\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ete, lte;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        p = g[i].first;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            j = p-&gt;data; <span class="comment">// i --&gt; j</span></span><br><span class="line">            ete = etv[i];</span><br><span class="line">            lte = ltv[j] - p-&gt;w;</span><br><span class="line">            <span class="keyword">if</span> (ete == lte) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c %c\n&quot;</span>, g[i].d, g[j].d);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;g[i].d);</span><br><span class="line">        g[i].first = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> x, y;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="type">int</span> xi, yi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) &#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %c %d&quot;</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line">        xi = <span class="built_in">find</span>(x);</span><br><span class="line">        yi = <span class="built_in">find</span>(y);</span><br><span class="line">        ind[yi] ++; <span class="comment">// 统计入度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建图</span></span><br><span class="line">        ENode *p = (ENode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ENode));</span><br><span class="line">        p-&gt;data = yi;</span><br><span class="line">        p-&gt;w = w;</span><br><span class="line">        p-&gt;next = g[xi].first;</span><br><span class="line">        g[xi].first = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先执行拓扑排序：得到拓扑序列，并得到ETV</span></span><br><span class="line">    <span class="built_in">TopoSort</span>(); <span class="comment">// O(|V|+|E|)</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 根据逆拓扑序，得到ltv，以及关键活动</span></span><br><span class="line">    <span class="built_in">CriticalPath</span>(); <span class="comment">// O(|V|+|E|)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">9 11</span></span><br><span class="line"><span class="comment">ABCDEFGHY</span></span><br><span class="line"><span class="comment">A B 6</span></span><br><span class="line"><span class="comment">A C 4</span></span><br><span class="line"><span class="comment">A D 5</span></span><br><span class="line"><span class="comment">B E 1</span></span><br><span class="line"><span class="comment">C E 1</span></span><br><span class="line"><span class="comment">D F 2</span></span><br><span class="line"><span class="comment">E G 9</span></span><br><span class="line"><span class="comment">E H 7</span></span><br><span class="line"><span class="comment">F H 4</span></span><br><span class="line"><span class="comment">G Y 2</span></span><br><span class="line"><span class="comment">H Y 4</span></span><br><span class="line"><span class="comment">以下是所有的关键活动</span></span><br><span class="line"><span class="comment">A B</span></span><br><span class="line"><span class="comment">B E</span></span><br><span class="line"><span class="comment">E H</span></span><br><span class="line"><span class="comment">E G</span></span><br><span class="line"><span class="comment">G Y</span></span><br><span class="line"><span class="comment">H Y</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>图：非线性逻辑结构</p>
<ul>
<li>基本概念</li>
<li>图的存储结构：边集数组、邻接矩阵、邻接表、十字链表、多重邻接表</li>
<li>遍历：BFS DFS</li>
<li>最小生成树：Kruskal、Prim</li>
<li>最短路算法：Dijkstra、Floyd（动态规划）</li>
<li>关键路径：拓扑排序</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yuezi2048.github.io">yuezi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yuezi2048.github.io/2025/04/07/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E5%9B%BE/">https://yuezi2048.github.io/2025/04/07/2.Areas🌐/basic-408/数据结构/5.图/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://yuezi2048.github.io" target="_blank">yuezi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post-share"><div class="social-share" data-image="/img/touxiang.jpg" data-sites="qq,wechat"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/25/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E6%A0%91/" title="4.树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">4.树</div></div><div class="info-2"><div class="info-item-1">〇、前置知识——递归 递归：某个函数直接或间接的调用自身（递进 回归）  （基于栈实现）   递归的本质：函数调用（创建副本）  如何理解递归代码：画出递归调用图  递归函数组成  递归出口 &#x2F; 终止条件 &#x2F; 边界条件：停止递归调用的条件（避免栈溢出 &#x2F; 爆内存） 特别注意：这里往往出问题（条件找错 &#x2F; 没找全条件）   递归体   解决的问题  如果一个问题能分成若干个小问题，并且小问题的解决思路和大问题一样 大问题和小问题的数据规模不一样   开发中怎么写递归函数  写的时候不要往深层次想执行过程，只需要知道函数解决什么问题的（一次递归的结果），该怎么分配子问题 即编码的时候更多的看成是黑盒问题而不是白盒问题，验证和复盘的时候可以追究白盒      #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;// 累加问题 1 + 2 + 3 + ... + n/*	5	15*/int add(int n) &#123;    if (n == 1) &#123; // 递归出口       ...</div></div></div></a><a class="pagination-related" href="/2025/04/07/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="8. 动态规划"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">8. 动态规划</div></div><div class="info-2"><div class="info-item-1">动态规划初探动态规划两个性质：最优子结构、重叠子问题  最优子结构： 将待求解的问题分解成若干小问题，小问题的求解过程和原问题是一致的，通过小问题可以求得原问题的解 并且各个小问题之间不是相互独立的   重叠子问题：  代码实现：  基于递归，备忘录写法（自上而下） 非递归，DPtable（自下而上）   分析问题用递归，写代码用非递归  解题的思路  确定是不是动态规划问题（实际上很难看出来，可以积累各种类型来解题） 确定状态数组（状态就是描述小问题的参数） 方法：经验 + 天赋 技巧：问句改成陈述句：第n项是几？第n项是x—&gt;状态数组的下标 f[n] &#x3D; x 初始状态 f[0] &#x3D; 0，f[1] &#x3D; 1 中间状态 f[i] &#x3D; x 最终状态 f[n] &#x3D; ?   技巧2：状态数组是记忆化数组，用备忘录的方法来自上而下分析问题   状态转移方程：描述数据关系 方法：经验 + 天赋 求中间状态法： 假设从第1个状态到第i-1个状态都知道，来看第i个状态是几   备忘录写法：隐含了状态转移方程   写代码：备忘录...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/10/05/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%20C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" title="1. C语言基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-05</div><div class="info-item-2">1. C语言基础</div></div><div class="info-2"><div class="info-item-1">一、基础语法1.1 编译过程程序为什么要被编译器编译之后才能运行？  机器识别的只有机器语言（由二进制的0和1组成） 因此我们必须将高级语言翻译为能让机器识别的机器语言程序  转换成机器语言的过程是怎么样的？  预处理：展开头文件&#x2F;宏替换&#x2F;去注释&#x2F;条件编译 编译：检查语法，生成汇编代码 汇编：将汇编代码转化为二进制的机器码 链接合成可执行的程序，并在声明的文件找相关的定义  1.2 宏定义和typedef关键字define  使用一个标识符来表示一个字符串，这就是宏，标识符叫宏名 替换文本可以是常数、表达式、字符串、基本数据类型、简单函数  typedef  为数据类型定义新名称，常用于结构体（对struct {} 起一个别名）  #include &lt;stdio.h&gt;#define ll long long#define Max 20#define MAX(x, y) ((x) &gt; (y) ? (x) : (y))typedef long long lll;ll a;lll b;int aa[Max];    typedef...</div></div></div></a><a class="pagination-related" href="/2024/09/12/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.DS%E6%A6%82%E8%BF%B0%E5%92%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/" title="2.DS概述和顺序表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-12</div><div class="info-item-2">2.DS概述和顺序表</div></div><div class="info-2"><div class="info-item-1">一、数据结构基本概念1.1 抽象数据类型我们现在有基本数据类型：  int表示2^32个数字：[-2^31, 2^31-1]  为了表示更多的数据类型表示实际复杂的业务，我们需要一个抽象数据类型 抽象数据类型（可自定义）：静态的数据 + 动态的操作（函数） 引出数据结构Data Structure：数据（data）和数据之间的关系（structure） 我们使用抽象数据类型来定义一个数据结构  分析问题：找到数据之间逻辑的关系（逻辑结构） 解决问题：如何把数据和数据之间的关系存入存储器（存储结构&#x2F;物理结构&#x2F;映像） 关系：存储结构是用计算机语言实现的逻辑结构  1.2 逻辑结构和存储结构数据结构可分为两块：逻辑结构和存储结构 逻辑结构  线性逻辑结构：一对一（线性表 栈 队列） 非线性逻辑结构：一对多（树形结构）、多对多（图型结构）  存储结构  顺序存储：逻辑上相邻的元素，在存储中位置也相邻（数组） 链式存储：逻辑上相邻的元素，存储器的位置可以不相邻，但需要实现逻辑上的相邻（链表） 索引存储，散列存储（Hash）...</div></div></div></a><a class="pagination-related" href="/2024/10/15/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" title="3.栈和队列"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-15</div><div class="info-item-2">3.栈和队列</div></div><div class="info-2"><div class="info-item-1">一、栈1.1 受限逻辑结构栈：受限的线性表（逻辑结构）—&gt; 顺序表和链表是物理结构 线性表：可以在任意位置进行操作 对线性表的操作进行约束：只允许在一端进行添加或者删除，另一端及中间位置不能操作：栈（Stack），生活例子：弹夹  允许操作的一端：栈顶 不允许操作的一段：栈底 如果没有元素：空栈  栈相关方法：  操作 入栈 出栈   判断 判满 判空  性质：先进后出 应用场景：  函数调用的实现（递归） 倒着走的业务逻辑（历史记录 撤销） 内存的堆栈：物理 STL库：stack容器  –&gt; 栈  1.2 顺序存储实现存储结构 顺序存储实现栈：顺序栈 —-&gt; 数组a[MAX_SIZE] 初始化栈：栈底固定不动，在下标0位置。栈顶是活动的，需要变量（int）标记栈顶：top —&gt; 为了描述方便，通常借用指针称呼top变量：栈顶指针  top &#x3D; -1 —&gt; top指向栈顶元素真正的位置 入栈：需判满，top++，指向新的栈顶位置，再在top下标位置放入元素  –&gt; a[++top] &#x3D;...</div></div></div></a><a class="pagination-related" href="/2024/12/10/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.%20%E6%8E%92%E5%BA%8F/" title="6. 排序"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-10</div><div class="info-item-2">6. 排序</div></div><div class="info-2"><div class="info-item-1">六、排序（默认升序）  就地排序、非就地排序 –&gt; 空间复杂度 内部排序、外部排序（只能拿一部分数据在内存中排，其他的存在外存中）—&gt; 基本上是内部排序 稳定性：重复数据的相对位置如果不发生变化，那么就是稳定交换 时间复杂度  排序算法包括：  插入：直接插入排序、shell排序（缩小增量排序） 交换：冒泡排序、快速排序 选择：简单选择排序、堆排序（堆） 归并排序：2-路归并 计数排序：桶排序、基数排序  约定  上课案例：a[1] - a[n] 数组分成两部分：乱序区、有序区 初始：整个数组是乱序区 乱序区不断缩小，有序区不断增大 最终：整个数组是有序区    6.1 插入6.1.1 插入排序 初始：a[1]是有序区、a[2]-a[n]是乱序区 每次把乱序区的一个数据插入到有序区中的合适位置，有序区长度+1，乱序区长度-1，执行n-1次为止   如何把数据插入到有序区的合适位置，即对于a[1]~a[i-1]的有序区，如何将a[i]加入到有序区中   找位置：a[i]从后往前比，直到遇到第一个小于等于a[i]的数a[k]，则 k+1...</div></div></div></a><a class="pagination-related" href="/2025/03/25/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E6%A0%91/" title="4.树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-25</div><div class="info-item-2">4.树</div></div><div class="info-2"><div class="info-item-1">〇、前置知识——递归 递归：某个函数直接或间接的调用自身（递进 回归）  （基于栈实现）   递归的本质：函数调用（创建副本）  如何理解递归代码：画出递归调用图  递归函数组成  递归出口 &#x2F; 终止条件 &#x2F; 边界条件：停止递归调用的条件（避免栈溢出 &#x2F; 爆内存） 特别注意：这里往往出问题（条件找错 &#x2F; 没找全条件）   递归体   解决的问题  如果一个问题能分成若干个小问题，并且小问题的解决思路和大问题一样 大问题和小问题的数据规模不一样   开发中怎么写递归函数  写的时候不要往深层次想执行过程，只需要知道函数解决什么问题的（一次递归的结果），该怎么分配子问题 即编码的时候更多的看成是黑盒问题而不是白盒问题，验证和复盘的时候可以追究白盒      #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;// 累加问题 1 + 2 + 3 + ... + n/*	5	15*/int add(int n) &#123;    if (n == 1) &#123; // 递归出口       ...</div></div></div></a><a class="pagination-related" href="/2025/01/02/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.%20%E6%9F%A5%E6%89%BE/" title="7. 查找"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-02</div><div class="info-item-2">7. 查找</div></div><div class="info-2"><div class="info-item-1">连地址法链地址法（拉链法 链接法）：一个地址处只能存放同义词，不存放非同义词，将同义词组成链表，存在对应的地址处即可 不同情况下的ASL：查找一个数据的比较次数 ASL平均查找长度：查找n个数查找长度和 &#x2F; n 开放地址法  ASL成功查找长度 ASL失败查找长度  链地址法  ASL成功查找长度  #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define size 13// 链表的节点结构typedef struct Node &#123;    int data;    struct Node *next;&#125;HNode, *HLink;int Hash(int k) &#123;    return k % 13;&#125;void Insert(HLink hash[], int k) &#123;    int i = Hash(k);        // 申请链表节点    HNode* p = (HNode*)malloc(sizeof(HNode));    p-&gt;data = k; ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yuezi</div><div class="author-info-description">积微者速成</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">603</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuezi2048"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">积微者速成</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%9B%BE"><span class="toc-text">五、图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">5.1 基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">5.2 图的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E8%BE%B9%E9%9B%86%E6%95%B0%E7%BB%84"><span class="toc-text">5.2.1 边集数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-text">5.2.2 邻接矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-text">5.2.3 邻接表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="toc-text">5.2.4 十字链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-5-%E5%A4%9A%E9%87%8D%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-text">5.2.5 多重邻接表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">5.3 图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-DFS"><span class="toc-text">5.3.1 深度优先遍历 DFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-BFS"><span class="toc-text">5.3.2 广度优先遍历 BFS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">5.4 最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-Kruskal%EF%BC%88%E8%BE%B9%E5%B0%91-%E7%A8%80%E7%96%8F%E5%9B%BE%EF%BC%89"><span class="toc-text">5.4.1 Kruskal（边少 稀疏图）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-Prim%EF%BC%88%E7%82%B9%E5%B0%91-%E7%A8%A0%E5%AF%86%E5%9B%BE%EF%BC%89"><span class="toc-text">5.4.2 Prim（点少 稠密图）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-text">5.5 最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1-dijkstra"><span class="toc-text">5.5.1 dijkstra</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-DAG%E5%9B%BE%E5%BA%94%E7%94%A8"><span class="toc-text">5.6 DAG图应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-1-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%88AOV%E7%BD%91%EF%BC%89"><span class="toc-text">5.6.1 拓扑排序（AOV网）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%EF%BC%88AOE%E7%BD%91%EF%BC%89"><span class="toc-text">3.6.2 关键路径（AOE网）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/Excalidraw/Drawing%202024-11-01%2015.37.37.excalidraw/" title="Drawing 2024-11-01 15.37.37.excalidraw">Drawing 2024-11-01 15.37.37.excalidraw</a><time datetime="2025-10-31T04:19:26.621Z" title="发表于 2025-10-31 12:19:26">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/01.project/condefather/yupao/back-end/7.%E4%BC%98%E5%8C%96%E4%B8%BB%E9%A1%B5%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/" title="7.优化主页性能-优化批量导入数据">7.优化主页性能-优化批量导入数据</a><time datetime="2025-10-31T04:19:26.102Z" title="发表于 2025-10-31 12:19:26">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/81.%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B8%E6%A0%87Cursor%E5%88%86%E9%A1%B5_%E5%AF%B9%E6%AF%94%E4%BC%A0%E7%BB%9FLIMIT_OFFSET%E5%88%86%E9%A1%B5%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88/" title="81.什么是游标Cursor分页_对比传统LIMIT_OFFSET分页的优势是什么">81.什么是游标Cursor分页_对比传统LIMIT_OFFSET分页的优势是什么</a><time datetime="2025-10-31T04:14:27.000Z" title="发表于 2025-10-31 12:14:27">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/80.%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E5%90%84%E8%87%AA%E4%BC%98%E7%BC%BA%E7%82%B9/" title="80.全量同步和增量同步各自优缺点">80.全量同步和增量同步各自优缺点</a><time datetime="2025-10-31T04:13:32.000Z" title="发表于 2025-10-31 12:13:32">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/79.%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93_%E7%9B%B8%E6%AF%94%E5%8D%95%E6%9D%A1%E6%8F%92%E5%85%A5%E4%BC%98%E5%8A%BF/" title="79.什么是批量数据入库_相比单条插入优势">79.什么是批量数据入库_相比单条插入优势</a><time datetime="2025-10-31T04:03:26.000Z" title="发表于 2025-10-31 12:03:26">2025-10-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/default.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By yuezi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>