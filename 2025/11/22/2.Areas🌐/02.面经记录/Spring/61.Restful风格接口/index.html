<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>61.Restful风格接口 | yuezi</title><meta name="author" content="yuezi"><meta name="copyright" content="yuezi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Restful 风格接口是基于资源的设计风格 ，面向WEB的API。 REST（Representational State Transfer）表示无状态的风格，在HTTP协议基础上定义资源和标准的操作方法来阻止接口，从而简化客户端-服务器的交互  无状态：服务器不保存客户端的状态（包括凭证信息等内容），响应码描述操作结果：201 created: 资源创建成功 400 bad request，请">
<meta property="og:type" content="article">
<meta property="og:title" content="61.Restful风格接口">
<meta property="og:url" content="https://yuezi2048.github.io/2025/11/22/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/61.Restful%E9%A3%8E%E6%A0%BC%E6%8E%A5%E5%8F%A3/index.html">
<meta property="og:site_name" content="yuezi">
<meta property="og:description" content="Restful 风格接口是基于资源的设计风格 ，面向WEB的API。 REST（Representational State Transfer）表示无状态的风格，在HTTP协议基础上定义资源和标准的操作方法来阻止接口，从而简化客户端-服务器的交互  无状态：服务器不保存客户端的状态（包括凭证信息等内容），响应码描述操作结果：201 created: 资源创建成功 400 bad request，请">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuezi2048.github.io/img/touxiang.jpg">
<meta property="article:published_time" content="2025-11-22T10:59:08.000Z">
<meta property="article:modified_time" content="2025-11-22T10:59:08.000Z">
<meta property="article:author" content="yuezi">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuezi2048.github.io/img/touxiang.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "61.Restful风格接口",
  "url": "https://yuezi2048.github.io/2025/11/22/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/61.Restful%E9%A3%8E%E6%A0%BC%E6%8E%A5%E5%8F%A3/",
  "image": "https://yuezi2048.github.io/img/touxiang.jpg",
  "datePublished": "2025-11-22T10:59:08.000Z",
  "dateModified": "2025-11-22T10:59:08.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "yuezi",
      "url": "https://yuezi2048.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuezi2048.github.io/2025/11/22/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/61.Restful%E9%A3%8E%E6%A0%BC%E6%8E%A5%E5%8F%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?bfb48b678d82bea9f9cc9d59227767e4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"FPH6F2TOJL","apiKey":"06d9ea26c803ba912b4d8e13404ed34d","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '61.Restful风格接口',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/backgound.css"><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">785</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">91</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yuezi</span></a><a class="nav-page-title" href="/"><span class="site-name">61.Restful风格接口</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">61.Restful风格接口</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-22T10:59:08.000Z" title="发表于 2025-11-22 18:59:08">2025-11-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-22T10:59:08.000Z" title="更新于 2025-11-22 18:59:08">2025-11-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/">02.面经记录</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/02-%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/">Spring</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><strong>Restful 风格接口</strong>是基于<code>资源</code>的设计风格 ，面向WEB的API。</p>
<p>REST（Representational State Transfer）表示<strong>无状态</strong>的风格，在HTTP协议基础上定义<strong>资源和标准的操作方法</strong>来阻止接口，从而简化客户端-服务器的交互</p>
<blockquote>
<p>无状态：服务器不保存客户端的状态（包括凭证信息等内容），响应码描述操作结果：201 created: 资源创建成功 400 bad request，请求参数错误 401 unauthorized 用户未授权 404 not found 500 internal server error 服务器内部错误</p>
</blockquote>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>假设有一个用户资源，URI 为 <code>/users</code>，RESTful API 设计如下：</p>
<ul>
<li><code>GET /users</code>：获取所有用户。幂等</li>
<li><code>GET /users/{id}</code>：获取指定 ID 的用户。</li>
<li><code>POST /users</code>：创建新用户。非幂等</li>
<li><code>PUT /users/{id}</code>：更新指定 ID 的用户。幂等</li>
<li><code>DELETE /users/{id}</code>：删除指定 ID 的用户。幂等</li>
</ul>
<h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><h3 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h3><p>实际上 RESTful 就是要求我们不要在 URL 上表现出动作，而是用 HTTP 动词代表动作，URL 上只做资源。</p>
<p>比如获取一个 user。</p>
<p>非 RESTful ：GET &#x2F;getUserById?userId&#x3D;1</p>
<p>RESTful ：GET &#x2F;users&#x2F;1</p>
<p>对应到 SpringMVC 代码就是 url 不写什么 get 之类的动词，而是通过 HTTP 请求（如 GET、POST、PUT、DELETE）访问服务端资源。</p>
<h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p>REST 不是一个单词，是 <strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer 的缩写。</p>
<p>直译过来就是表述性状态转移，其实它还有个主语 Resource，所以是<strong>资源的表述性状态转移</strong>。</p>
<p>知道 REST 之后 RESTful 就不难解释了，加 ful 就是变形容词了。</p>
<p>核心就是资源，<strong>用 URL 定位资源，用 HTTP 动词来描述所要做的操作</strong>，这就是 REST 的核心</p>
<p>HTTP的提供了很多动词：GET、PUT、POST、DELETE……</p>
<p>这些动词都是有含义的。</p>
<p>比如 GET 就是获取资源，是查询请求。</p>
<p>PUT 指的是修改资源，是幂等的。</p>
<p>POST 也是修改(新增也是一种修改)，指的是不幂等的操作。</p>
<p>所以根据这些规范我们都能得知这次交互的一些动作，所以 RESTful 风格正确的使用姿势如下：</p>
<p>比如获取一个 user。</p>
<p>错误姿势：<code>GET /getUserById?userId=1</code>。</p>
<p>正确姿势：<code>GET /users/1</code>。</p>
<p>再比如新增 user。</p>
<p>错误姿势：<code>POST /addUser （省略body）</code>。</p>
<p>正确姿势：<code>POST /users （省略body）</code>。</p>
<p>可以看到 <strong>HTTP 的动词其实就能指代你要对资源做的操作</strong>，所以不需要在 URL 上做一些东西，就把 URL 表明的东西看作一个资源即可。</p>
<p>这里注意要<strong>用对 HTTP 动词</strong>，比如一个获取资源的请求用 PUT，用了也能获取资源但是这不合适。</p>
<p>其实更深一步的理解是 <strong>HTTP 是一个协议</strong>。</p>
<p>协议其实就是约定好的一个东西，协议就规定 GET 是获取资源，那你非得在 URL 上再重复一遍或者所有请求不论增删改都用 GET 这个动作，这其实就是没有完全遵循这个协议。</p>
<p>可以说只是把 HTTP 当成一个传输管道，而不是约定好的协议。</p>
<p>这其实是对 HTTP 更深一层的认识，我认为也是 RESTful 被推出的原因。</p>
<p>当然理想很丰满，现实很骨感，还是有很多人就 getUserById。</p>
<p>不过我个人觉得问题不大，公司统一就行。</p>
<h3 id="RESTful-风格的核心原则"><a href="#RESTful-风格的核心原则" class="headerlink" title="RESTful 风格的核心原则"></a><strong>RESTful 风格的核心原则</strong></h3><h4 id="资源和-URI"><a href="#资源和-URI" class="headerlink" title="资源和 URI"></a><strong>资源和 URI</strong></h4><p>RESTful 接口围绕资源进行设计，资源通过 URI（统一资源标识符）来表示。URI 应该简单、明了、符合资源的结构层次。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>资源集合：<code>/users</code> 表示用户集合。</li>
<li>资源实例：<code>/users/1</code> 表示 ID 为 1 的用户。</li>
</ul>
<h4 id="HTTP-方法的语义化使用"><a href="#HTTP-方法的语义化使用" class="headerlink" title="HTTP 方法的语义化使用"></a><strong>HTTP 方法的语义化使用</strong></h4><p>在 RESTful 风格中，HTTP 方法应该遵循其语义：</p>
<ul>
<li><strong>GET</strong>：用于获取资源，不会修改资源的状态。是幂等的（多次请求返回结果相同）。</li>
<li><strong>POST</strong>：用于创建资源，向服务器发送新数据，可能改变服务器端的状态。非幂等的。</li>
<li><strong>PUT</strong>：用于更新资源（如果资源不存在，则可以根据需要创建），是幂等的。</li>
<li><strong>DELETE</strong>：用于删除资源，是幂等的。</li>
</ul>
<h4 id="无状态通信"><a href="#无状态通信" class="headerlink" title="无状态通信"></a><strong>无状态通信</strong></h4><p>REST 强调无状态的通信模型，即每个请求必须独立完成，不依赖于服务器保存的上下文信息。这意味着客户端在每次请求时需要发送所有必要的信息，如认证凭证等。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>简化了服务器的设计，服务器不会保存客户端的状态，增加了系统的可扩展性。</li>
<li>更容易实现分布式系统，任何节点都可以处理请求。</li>
</ul>
<h4 id="标准化的-HTTP-响应状态码"><a href="#标准化的-HTTP-响应状态码" class="headerlink" title="标准化的 HTTP 响应状态码"></a><strong>标准化的 HTTP 响应状态码</strong></h4><p>RESTful 风格的接口应使用标准的 HTTP 状态码来描述操作结果，常见的状态码包括：</p>
<ul>
<li><strong>200 OK</strong>：请求成功，返回所需的资源。</li>
<li><strong>201 Created</strong>：资源创建成功。</li>
<li><strong>204 No Content</strong>：请求成功，但不返回任何内容（如删除操作）。</li>
<li><strong>400 Bad Request</strong>：请求参数错误。</li>
<li><strong>401 Unauthorized</strong>：用户未授权。</li>
<li><strong>404 Not Found</strong>：资源未找到。</li>
<li><strong>500 Internal Server Error</strong>：服务器内部错误。</li>
</ul>
<h3 id="RESTful-风格的设计规范"><a href="#RESTful-风格的设计规范" class="headerlink" title="RESTful 风格的设计规范"></a><strong>RESTful 风格的设计规范</strong></h3><h4 id="URI-设计规范"><a href="#URI-设计规范" class="headerlink" title="URI 设计规范"></a><strong>URI 设计规范</strong></h4><p>1）<strong>资源命名采用名词</strong>：URI 应该使用名词，而不是动词，且采用复数形式。</p>
<ul>
<li><strong>正确</strong>：<code>/users</code>（表示用户资源集合）</li>
<li><strong>错误</strong>：<code>/getUsers</code>、<code>/createUser</code></li>
</ul>
<p>2）<strong>层次结构清晰</strong>：URI 应该体现资源之间的层次关系。</p>
<ul>
<li><strong>示例</strong>：<code>/users/{userId}/orders</code>，表示用户的订单。</li>
</ul>
<p>3）<strong>避免使用文件扩展名</strong>：不要在 URI 中显式使用扩展名，如 <code>.json</code>、<code>.xml</code>，应使用 <code>Accept</code> 头来确定返回的内容类型。</p>
<ul>
<li><strong>正确</strong>：<code>/users/1</code></li>
<li><strong>错误</strong>：<code>/users/1.json</code></li>
</ul>
<h4 id="使用合适的-HTTP-方法"><a href="#使用合适的-HTTP-方法" class="headerlink" title="使用合适的 HTTP 方法"></a><strong>使用合适的 HTTP 方法</strong></h4><p>HTTP 方法应该严格按照其语义使用：</p>
<ul>
<li><strong>GET</strong>：只用于读取数据，不会影响服务器状态。</li>
<li><strong>POST</strong>：用于提交新的数据，创建新的资源。</li>
<li><strong>PUT</strong>：用于更新或替换现有资源。</li>
<li><strong>DELETE</strong>：用于删除资源。</li>
<li><strong>PATCH</strong>：用于部分更新资源。</li>
</ul>
<h4 id="返回合适的响应格式"><a href="#返回合适的响应格式" class="headerlink" title="返回合适的响应格式"></a><strong>返回合适的响应格式</strong></h4><p>RESTful API 常使用 JSON 或 XML 作为响应格式。可以通过客户端发送的 <code>Accept</code> 头来决定返回的格式：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json</span><br></pre></td></tr></table></figure>

<p>服务器会根据 <code>Accept</code> 头返回相应的内容。</p>
<h4 id="HATEOAS（超媒体驱动的应用状态）"><a href="#HATEOAS（超媒体驱动的应用状态）" class="headerlink" title="HATEOAS（超媒体驱动的应用状态）"></a><strong>HATEOAS（超媒体驱动的应用状态）</strong></h4><p>HATEOAS 即 Hypermedia as the Engine of Application State 的缩写，翻译过来就是作为应用状态引擎的超媒体。</p>
<p>这也是 REST 提出的设计， REST 的一种扩展，它通过在响应中提供链接，使得客户端可以轻松发现相关操作。</p>
<p>是不是不太好理解？来看下 stackoverflow 回答上的例子。</p>
<p>比如你请求获取用户列表：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="built_in">GET</span> <span class="built_in">/users</span></span><br><span class="line"><span class="built_in"></span>Accept: application/json+userdb</span><br></pre></td></tr></table></figure>

<p>此时的返回应该是：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">200</span> OK</span><br><span class="line">Content-<span class="keyword">Type</span>: application/<span class="type">json</span>+userdb</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;users&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: <span class="number">1</span>,</span><br><span class="line">            &quot;name&quot;: &quot;Emil&quot;,</span><br><span class="line">            &quot;country: &quot;Sweden&quot;,</span><br><span class="line">            &quot;links&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;href&quot;: &quot;/<span class="keyword">user</span>/<span class="number">1</span>&quot;,</span><br><span class="line">                    &quot;rel&quot;: &quot;self&quot;,</span><br><span class="line">                    &quot;<span class="keyword">method</span>&quot;: &quot;<span class="keyword">GET</span>&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;href&quot;: &quot;/<span class="keyword">user</span>/<span class="number">1</span>&quot;,</span><br><span class="line">                    &quot;rel&quot;: &quot;edit&quot;,</span><br><span class="line">                    &quot;<span class="keyword">method</span>&quot;: &quot;PUT&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;href&quot;: &quot;/<span class="keyword">user</span>/<span class="number">1</span>&quot;,</span><br><span class="line">                    &quot;rel&quot;: &quot;<span class="keyword">delete</span>&quot;,</span><br><span class="line">                    &quot;<span class="keyword">method</span>&quot;: &quot;<span class="keyword">DELETE</span>&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 2,</span><br><span class="line">           ....省略.....</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;links&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;/<span class="keyword">user</span>&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;<span class="keyword">create</span>&quot;,</span><br><span class="line">            &quot;<span class="keyword">method</span>&quot;: &quot;POST&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点就是这个 links，结果会返回你能对这个资源所做的操作。</p>
<p>比如对于 userId 是 1 的，你调用<code>PUT /user/1</code>就是做修改这个用户，<code>DELETE /user/1</code>就是删除这个用户。</p>
<p>最外层的 links 告诉你用 <code>POST /user</code> 就能再创建一个用户。</p>
<p>这里还有个隐藏信息，可以看到外层的 links 没有返回 DELETE 的信息，<strong>说明此时客户端无法删除用户！</strong></p>
<p>所以说 <strong>RESTful API 还需要再返回此时能对资源做的操作</strong>，这样客户端就知道它能做什么。</p>
<p>它也不需要管具体怎么做，反正返回里面会告诉它 DELETE 就这样这样，POST 就这样这样。</p>
<p>没告诉它的就是不能做的。</p>
<p>然后这个时候再去理解下<strong>资源的表述性状态转移</strong>，是不是感觉来了？</p>
<p>如果说上一 part 提到用 HTTP 的动词来指代动作， URL 仅表示资源的现实是骨感的。</p>
<p>那么 HATEOAS 的现实就是骨灰。</p>
<p>基本上没几家公司会这么做。</p>
<p>它的出发点是让客户端从响应就能得知对资源操作的入口，并且通过响应得知哪些动作能执行。</p>
<p>听起来好像有点用，但是能看到响应变得十分冗余。</p>
<h4 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a><strong>幂等性</strong></h4><p>RESTful API 中的操作应尽量遵循幂等性原则。幂等操作的含义是，无论请求执行多少次，其结果应该相同。</p>
<ul>
<li><strong>GET</strong>、<strong>PUT</strong>、<strong>DELETE</strong>：这些操作应该是幂等的。</li>
<li><strong>POST</strong>：通常是非幂等的，因为每次调用 POST 可能都会创建新的资源。</li>
</ul>
<h3 id="RESTful-与其他风格的比较"><a href="#RESTful-与其他风格的比较" class="headerlink" title="RESTful 与其他风格的比较"></a><strong>RESTful 与其他风格的比较</strong></h3><h4 id="与-SOAP-的区别"><a href="#与-SOAP-的区别" class="headerlink" title="与 SOAP 的区别"></a><strong>与 SOAP 的区别</strong></h4><ul>
<li><strong>REST</strong>：轻量级，无状态，资源导向，使用标准的 HTTP 方法和状态码，常见于 Web API。</li>
<li><strong>SOAP</strong>：协议复杂，依赖 XML，使用 WS-* 标准，适用于企业级应用和需要高安全性的场景。</li>
</ul>
<h4 id="与-GraphQL-的区别"><a href="#与-GraphQL-的区别" class="headerlink" title="与 GraphQL 的区别"></a><strong>与 GraphQL 的区别</strong></h4><ul>
<li><strong>REST</strong>：每个资源都有固定的 URI，适合层次化的资源访问。</li>
<li><strong>GraphQL</strong>：客户端可以灵活定义请求的数据结构，减少了不必要的数据传输，适合复杂查询场景。</li>
</ul>
<h3 id="RESTful-的优势与局限"><a href="#RESTful-的优势与局限" class="headerlink" title="RESTful 的优势与局限"></a><strong>RESTful 的优势与局限</strong></h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h4><ul>
<li><strong>简单性</strong>：基于 HTTP 标准，易于理解和实现。</li>
<li><strong>松耦合</strong>：客户端与服务器之间的依赖性较低。</li>
<li><strong>可扩展性</strong>：由于无状态特性，系统容易扩展，支持水平扩展。</li>
</ul>
<h4 id="局限"><a href="#局限" class="headerlink" title="局限"></a><strong>局限</strong></h4><ul>
<li><strong>对于复杂查询的局限性</strong>：REST 对复杂查询支持不如 GraphQL，可能需要创建多层次的资源路径。</li>
<li><strong>无状态的局限</strong>：虽然无状态可以提升扩展性，但有时需要额外处理用户状态管理。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yuezi2048.github.io">yuezi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yuezi2048.github.io/2025/11/22/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/61.Restful%E9%A3%8E%E6%A0%BC%E6%8E%A5%E5%8F%A3/">https://yuezi2048.github.io/2025/11/22/2.Areas🌐/02.面经记录/Spring/61.Restful风格接口/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://yuezi2048.github.io" target="_blank">yuezi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post-share"><div class="social-share" data-image="/img/touxiang.jpg" data-sites="qq,wechat"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/11/18/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/60.SPringMVC%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/" title="60.SPringMVC核心组件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">60.SPringMVC核心组件</div></div><div class="info-2"><div class="info-item-1">回答重点 DispatcherServlet：Spring MVC 的前端控制器，所有请求都会先由它接收并分发到相应的处理器。它是整个 Spring MVC 流程的入口，也是处理请求的调度中心。 HandlerMapping：根据请求 URL 查找对应的处理器（Controller）。HandlerMapping 用于将客户端的请求映射到具体的控制器方法。 Controller（控制器）：负责处理用户请求的核心组件。Controller 接收请求后，调用业务逻辑处理，返回数据给前端。 ModelAndView：Controller 返回的对象，包含模型数据和视图信息，表示返回给用户的页面或 API 响应。 ViewResolver：用于解析视图名称并找到实际的视图（如 JSP、Thymeleaf 等），然后将处理结果渲染为 HTML 或其他格式，发送给客户端。 HandlerInterceptor（拦截器）：在请求处理的各个阶段拦截 HTTP...</div></div></div></a><a class="pagination-related" href="/2025/11/22/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/62.Controller%E6%98%AF%E4%BB%80%E4%B9%88_%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89/" title="62.Controller是什么_如何定义"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">62.Controller是什么_如何定义</div></div><div class="info-2"><div class="info-item-1">Controller 是MVC架构的C层，对应控制层：  接收客户端请求（@ModelAttribute &#x2F; @RequestBody） 调用业务逻辑层Servcie 数据返回给视图层（Model &amp; View或者String） &#x2F; 返回JSON或XML数据响应（@ResponseEntity）  定义 Controller 的步骤：1）使用 @Controller 或 @RestController 注解：类上标记 @Controller 注解，表示这是一个控制器，Spring 会将其注册为一个 Spring MVC 的 Bean。如果是用于 RESTful API 的开发，可以使用 @RestController，它是 @Controller 和 @ResponseBody 的组合注解，默认返回 JSON 数据。 2）使用 @RequestMapping 注解映射请求路径：在方法上使用 @RequestMapping 或其衍生注解（如 @GetMapping、@PostMapping 等）来映射 HTTP...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/11/14/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/1.%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" title="1.循环依赖"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-14</div><div class="info-item-2">1.循环依赖</div></div><div class="info-2"><div class="info-item-1">循环依赖（Circular Dependency）是说多个模块，组件之间相互依赖，形成闭环（A依赖B，B依赖A），从而无法确定加载&#x2F;初始化的顺序 扩展知识简单示例看下方的代码就知晓了 @Servicepublic class A &#123;    @Autowired    private B b;&#125;@Servicepublic class B &#123;    @Autowired    private A a;&#125;//或者自己依赖自己@Servicepublic class A &#123;    @Autowired    private A a;&#125;  上面这两种方式都是循环依赖，应该很好理解，当然也可以是三个 Bean 甚至更多 Bean 相互依赖，原理都是一样的。 	 这种循环依赖可能会产生问题，例如 A 要依赖 B，发现 B 还没创建，于是开始创建 B ，创建的过程发现 B 要依赖 A， 而 A 还没创建好呀，因为它要等 B 创建好，就这样它们俩就搁这卡 bug 了。 关联面试题 578. Spring...</div></div></div></a><a class="pagination-related" href="/2025/11/14/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/10.FactoryBean/" title="10.FactoryBean"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-14</div><div class="info-item-2">10.FactoryBean</div></div><div class="info-2"><div class="info-item-1">FactoryBean是Spring的特殊接口，允许开发者通过实现接口来创建复杂的Bean实例（通过FactoryBean创建的Bean除了FactoryBean本身，也可以是他生产的对象）  核心概念：FactoryBean 是一个实现了 FactoryBean&lt;T&gt; 接口的 Bean，通过它可以自定义复杂对象的创建逻辑。Spring 容器会调用 getObject() 方法来获取实际的 Bean 实例。 使用场景： 通常用于需要创建复杂对象或需要使用代理模式生成 Bean 的场景。  扩展知识FactoryBean 的主要方法 getObject()：这是 FactoryBean 最重要的方法，返回实际的 Bean 实例。Spring 容器会调用这个方法来获取 Bean。 getObjectType()：返回由 getObject() 方法所返回的对象类型，Spring 可以根据这个类型进行 Bean 的类型检查。 isSingleton()：用于确定 getObject() 返回的 Bean 是否为单例。如果返回 true，那么 Spring...</div></div></div></a><a class="pagination-related" href="/2025/11/14/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/11.ObjectFactory/" title="11.ObjectFactory"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-14</div><div class="info-item-2">11.ObjectFactory</div></div><div class="info-2"><div class="info-item-1">ObjectFactory是 Spring 框架中的一个接口，主要用于延迟获取 Bean 实例。 ObjectFactory 提供了一种延迟加载的机制，它通过 getObject() 方法返回一个 Bean 的实例。使用 ObjectFactory 可以避免在容器启动时立即创建所有 Bean，即只有在真正需要使用 Bean 时才会从 Spring 容器中获取该 Bean 实例，有助于优化性能。 扩展知识ObjectFactory 的使用场景 懒加载 Bean：当某个 Bean 的创建过程可能耗时较长或依赖的资源较重时，可以通过 ObjectFactory 进行懒加载，避免容器启动时不必要的 Bean 创建。这能有效提升系统的启动速度。 避免循环依赖：在某些情况下，两个 Bean 可能相互依赖，导致循环依赖问题。通过使用 ObjectFactory，可以延迟其中一个 Bean 的创建，避免循环依赖。  在 Spring 的循环依赖里就用到它了，三级缓存的 map 里面存储的就是 ObjectFactory，用于延迟代理对象的创建。 并且在某些需要在运行时决定动态 Bean...</div></div></div></a><a class="pagination-related" href="/2025/11/14/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/12.ApplicationContext/" title="12.ApplicationContext"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-14</div><div class="info-item-2">12.ApplicationContext</div></div><div class="info-2"><div class="info-item-1">ApplicationContext 是多个底层接口组合后的接口。从类图中我们可以看到，它主要提供了五大功能。  核心容器 BeanFactory 国际化 MessageSource 资源获取 ResourceLoader 环境信息 EnvironmentCapable 事件发布 ApplicationEventPublisher   ApplicationContext有多个实现类，如ClassPathXmlApplicationContext和FileSystemXmlApplicationContext等，适用于不同的应用场景。通过这些实现类，开发者可以根据具体需求选择合适的ApplicationContext来实现Spring应用程序的各种功能‌。   扩展知识下面，我们使用 SpringBoot 返回的 ConfigurableApplicationContext 来进行讲解。 @SpringBootApplicationpublic class Main &#123;    public static void main(String[] args) throws...</div></div></div></a><a class="pagination-related" href="/2025/11/14/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/13.Bean%E4%BD%9C%E7%94%A8%E5%9F%9F/" title="13.Bean作用域"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-14</div><div class="info-item-2">13.Bean作用域</div></div><div class="info-2"><div class="info-item-1">一共有六种作用域：  整体作用  singleton：默认是单例，含义不用解释了吧，一个 IOC 容器内部仅此一个 prototype：原型，多实例   分块作用  request：每个请求都会新建一个属于自己的 Bean 实例，这种作用域仅存在 Spring Web 应用中 session：一个 http session 中有一个 bean 的实例，这种作用域仅存在 Spring Web 应用中 application：整个 ServletContext 生命周期里，只有一个 bean，这种作用域仅存在 Spring Web 应用中 websocket：一个 WebSocket 生命周期内一个 bean 实例，这种作用域仅存在 Spring Web 应用中    官网最新截图：  </div></div></div></a><a class="pagination-related" href="/2025/11/14/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/Spring/14.spring%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/" title="14.spring注入方式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-14</div><div class="info-item-2">14.spring注入方式</div></div><div class="info-2"><div class="info-item-1"> 推荐方式  构造器注入，Spring 倡导构造函数注入，因为构造器注入返回给客户端使用的时候一定是完整的。 setter 注入，可选的注入方式，好处是在有变更的情况下，可以重新注入。   其他  字段注入，就是平日我们用 @Autowired 标记字段 方法注入，就是平日我们用 @Autowired 标记方法 接口回调注入，就是实现 Spring 定义的一些内建接口，例如 BeanFactoryAware，会进行 BeanFactory 的注入    其实官网上关于注入就写了构造器和setter ： 	 像字段注入其实官方是不推荐的使用的，因为依赖注解，后没有控制注入顺序且无法注入静态字段。 </div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yuezi</div><div class="author-info-description">积微者速成</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">785</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">91</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuezi2048"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">积微者速成</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86"><span class="toc-text">扩展知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%97%E8%A7%A3%E9%87%8A"><span class="toc-text">通俗解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#REST"><span class="toc-text">REST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RESTful-%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%88%99"><span class="toc-text">RESTful 风格的核心原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%92%8C-URI"><span class="toc-text">资源和 URI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%AD%E4%B9%89%E5%8C%96%E4%BD%BF%E7%94%A8"><span class="toc-text">HTTP 方法的语义化使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E9%80%9A%E4%BF%A1"><span class="toc-text">无状态通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%8C%96%E7%9A%84-HTTP-%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">标准化的 HTTP 响应状态码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RESTful-%E9%A3%8E%E6%A0%BC%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-text">RESTful 风格的设计规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#URI-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-text">URI 设计规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84-HTTP-%E6%96%B9%E6%B3%95"><span class="toc-text">使用合适的 HTTP 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%90%88%E9%80%82%E7%9A%84%E5%93%8D%E5%BA%94%E6%A0%BC%E5%BC%8F"><span class="toc-text">返回合适的响应格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HATEOAS%EF%BC%88%E8%B6%85%E5%AA%92%E4%BD%93%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%BA%94%E7%94%A8%E7%8A%B6%E6%80%81%EF%BC%89"><span class="toc-text">HATEOAS（超媒体驱动的应用状态）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-text">幂等性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RESTful-%E4%B8%8E%E5%85%B6%E4%BB%96%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">RESTful 与其他风格的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E-SOAP-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与 SOAP 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E-GraphQL-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与 GraphQL 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RESTful-%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%B1%80%E9%99%90"><span class="toc-text">RESTful 的优势与局限</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-text">优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%99%90"><span class="toc-text">局限</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/22/Excalidraw/Drawing%202024-11-01%2015.37.37.excalidraw/" title="Drawing 2024-11-01 15.37.37.excalidraw">Drawing 2024-11-01 15.37.37.excalidraw</a><time datetime="2026-02-22T05:56:41.839Z" title="发表于 2026-02-22 13:56:41">2026-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/22/2.Areas%F0%9F%8C%90/01.project/condefather/yupao/back-end/7.%E4%BC%98%E5%8C%96%E4%B8%BB%E9%A1%B5%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/" title="7.优化主页性能-优化批量导入数据">7.优化主页性能-优化批量导入数据</a><time datetime="2026-02-22T05:56:41.257Z" title="发表于 2026-02-22 13:56:41">2026-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/31/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/5.%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8/" title="5.工具调用">5.工具调用</a><time datetime="2026-01-31T03:54:22.000Z" title="发表于 2026-01-31 11:54:22">2026-01-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/30/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/4.RAG%E8%BF%9B%E9%98%B6/" title="4.RAG进阶">4.RAG进阶</a><time datetime="2026-01-30T13:23:42.000Z" title="发表于 2026-01-30 21:23:42">2026-01-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/3.RAG/" title="3.RAG">3.RAG</a><time datetime="2026-01-27T09:06:56.000Z" title="发表于 2026-01-27 17:06:56">2026-01-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/default.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2026 By yuezi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>