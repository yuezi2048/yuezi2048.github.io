<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>07.面向对象编程（基础部分） | yuezi</title><meta name="author" content="yuezi"><meta name="copyright" content="yuezi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="七、面向对象编程（基础部分）	  7.1 类与对象7.1.1 为什么要类与对象为什么要有对象？ 给出需求，需要输出两只猫的名字、颜色和年龄。之前的方法解决有两种思路  每只猫每个属性单独定义一个变量 很明显，如果有100只猫，就完不成该需求了   使用String[][]类型的二维数组存储，即用String类型每只猫的每个属性 数组的类型必须一样，如果都用String存储，年龄int变量无法体现">
<meta property="og:type" content="article">
<meta property="og:title" content="07.面向对象编程（基础部分）">
<meta property="og:url" content="https://yuezi2048.github.io/2024/06/07/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/07.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89/index.html">
<meta property="og:site_name" content="yuezi">
<meta property="og:description" content="七、面向对象编程（基础部分）	  7.1 类与对象7.1.1 为什么要类与对象为什么要有对象？ 给出需求，需要输出两只猫的名字、颜色和年龄。之前的方法解决有两种思路  每只猫每个属性单独定义一个变量 很明显，如果有100只猫，就完不成该需求了   使用String[][]类型的二维数组存储，即用String类型每只猫的每个属性 数组的类型必须一样，如果都用String存储，年龄int变量无法体现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuezi2048.github.io/img/touxiang.jpg">
<meta property="article:published_time" content="2024-06-07T00:43:18.000Z">
<meta property="article:modified_time" content="2024-06-07T00:43:18.000Z">
<meta property="article:author" content="yuezi">
<meta property="article:tag" content="基础篇——韩顺平">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuezi2048.github.io/img/touxiang.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "07.面向对象编程（基础部分）",
  "url": "https://yuezi2048.github.io/2024/06/07/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/07.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89/",
  "image": "https://yuezi2048.github.io/img/touxiang.jpg",
  "datePublished": "2024-06-07T00:43:18.000Z",
  "dateModified": "2024-06-07T00:43:18.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "yuezi",
      "url": "https://yuezi2048.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuezi2048.github.io/2024/06/07/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/07.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?bfb48b678d82bea9f9cc9d59227767e4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"FPH6F2TOJL","apiKey":"06d9ea26c803ba912b4d8e13404ed34d","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '07.面向对象编程（基础部分）',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/backgound.css"><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">785</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">91</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yuezi</span></a><a class="nav-page-title" href="/"><span class="site-name">07.面向对象编程（基础部分）</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">07.面向对象编程（基础部分）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-07T00:43:18.000Z" title="发表于 2024-06-07 08:43:18">2024-06-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-07T00:43:18.000Z" title="更新于 2024-06-07 08:43:18">2024-06-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/back-end-java/">back-end-java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/back-end-java/1-JavaSE/">1.JavaSE</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/back-end-java/1-JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/">基础篇——韩顺平</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="七、面向对象编程（基础部分）"><a href="#七、面向对象编程（基础部分）" class="headerlink" title="七、面向对象编程（基础部分）"></a>七、面向对象编程（基础部分）</h1><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240607082106359.png" alt="image-20240607082106359" style="zoom:67%;" />	

<h2 id="7-1-类与对象"><a href="#7-1-类与对象" class="headerlink" title="7.1 类与对象"></a>7.1 类与对象</h2><h3 id="7-1-1-为什么要类与对象"><a href="#7-1-1-为什么要类与对象" class="headerlink" title="7.1.1 为什么要类与对象"></a>7.1.1 为什么要类与对象</h3><p>为什么要有对象？</p>
<p>给出需求，需要输出两只猫的名字、颜色和年龄。之前的方法解决有两种思路</p>
<ul>
<li>每只猫每个属性单独定义一个变量<ul>
<li>很明显，<code>如果有100只猫</code>，就完不成该需求了</li>
</ul>
</li>
<li>使用String[][]类型的二维数组存储，即用String类型每只猫的每个属性<ul>
<li>数组的类型必须一样，如果都用String存储，<code>年龄int变量无法体现</code></li>
<li>后续访问年龄必须通过下标获取，失去<code>变量名和功能的对应关系</code></li>
<li>后续无法体现<code>猫的行为</code></li>
<li>数据的增删效率低，<code>不利于数据管理</code>等等</li>
</ul>
</li>
</ul>
<p>给出使用String[][]解决业务需求的coding，只能说能跑通，但后续如果业务发生变化了，那么就不是很友好了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object01</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			a.需求分析</span></span><br><span class="line"><span class="comment">			 	有两只猫，小白,3岁,白色;小花,100岁,花色。用户输入名字，如果找到，则输出猫的3个信息，否则提示没有</span></span><br><span class="line"><span class="comment">			b.思路分析</span></span><br><span class="line"><span class="comment">				首先韩老师刻意对每个信息都用单独一个变量存储，很明显，数据大了以后是没办法存的，又或者说属性加了几条，变量也麻烦</span></span><br><span class="line"><span class="comment">				如果不使用类的话，用前置的方法 我能想到的办法应该是用二维数组String[][]存储信息，然后逐个遍历即可</span></span><br><span class="line"><span class="comment">				但是这里老韩指出了缺陷</span></span><br><span class="line"><span class="comment">					1)数组的数据类型必须一样，年龄没法用int体现</span></span><br><span class="line"><span class="comment">					2)后续访问年龄只能用下标取，失去了变量名和实际功能的对应关系</span></span><br><span class="line"><span class="comment">					3)猫的一些特殊行为无法体现</span></span><br><span class="line"><span class="comment">				以上，数据处理效率低，不利于数据管理，而引入类的概念就可以改善上述问题，oop编程。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		String[][] msg = &#123;&#123;<span class="string">&quot;小白&quot;</span>, <span class="string">&quot;3岁&quot;</span>, <span class="string">&quot;白色&quot;</span>&#125;, &#123;<span class="string">&quot;小花&quot;</span>, <span class="string">&quot;100岁&quot;</span>, <span class="string">&quot;花色&quot;</span>&#125;&#125;;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">String</span> <span class="variable">catName</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 是否找到</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; msg.length; i ++ ) &#123;</span><br><span class="line">			<span class="keyword">if</span> (msg[i][<span class="number">0</span>].equals(catName)) &#123;</span><br><span class="line">				System.out.print(<span class="string">&quot;Find.The message:&quot;</span>);</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; msg[i].length; j ++ ) &#123;</span><br><span class="line">					System.out.print(msg[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) System.out.println(<span class="string">&quot;Not Found.&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为了后续的问题，我们引出<code>面向对象编程(oop)</code>，引入<code>类与对象</code>的概念。</p>
<h3 id="7-1-2-快速入门"><a href="#7-1-2-快速入门" class="headerlink" title="7.1.2 快速入门"></a>7.1.2 快速入门</h3><ul>
<li><p>一个程序就是一个世界， 有很多事物<code>(对象[属性, 行为])</code>  都可以用对象表示</p>
</li>
<li><p>cat1是<code>对象名（对象引用</code>），真正的对象和数据是<code>new Cat()</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object02</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 1. 通过cat1可以获取到名字等信息 一个对象可以管理多个属性</span></span><br><span class="line">		<span class="comment">// 2. 后期可以拓展对象的行为</span></span><br><span class="line">		<span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); <span class="comment">// cat1:对象名，对象引用；真正的对象是new Cat()</span></span><br><span class="line">		cat1.name = <span class="string">&quot;小白&quot;</span>;</span><br><span class="line">		cat1.age = <span class="number">3</span>;</span><br><span class="line">		cat1.color = <span class="string">&quot;白色&quot;</span>;</span><br><span class="line">		System.out.println(cat1.age);</span><br><span class="line">		<span class="type">Cat</span> <span class="variable">cat2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">		cat1.name = <span class="string">&quot;小花&quot;</span>;</span><br><span class="line">		cat1.age = <span class="number">100</span>;</span><br><span class="line">		cat1.color = <span class="string">&quot;花色&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">	<span class="comment">// 属性</span></span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	String color;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 行为</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606165147094.png" alt="image-20240606165147094" style="zoom:67%;" />	





<h3 id="7-1-3-细节-类到对象的实例化过程"><a href="#7-1-3-细节-类到对象的实例化过程" class="headerlink" title="7.1.3 细节-类到对象的实例化过程"></a>7.1.3 细节-类到对象的实例化过程</h3><p><strong>类到对象的过程</strong>（<code>创建对象、实例化对象、把类实例化</code>）</p>
<img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606165014672.png" alt="image-20240606165014672" style="zoom:67%;" />	

<ul>
<li>类是<code>抽象</code>的，<code>概念</code>的，代表了一类事物，比如人类，看成是一种<code>数据类型</code></li>
<li>对象是<code>具体</code>的，<code>实际</code>的，代表具体的事物，比如hsp就是一个<code>人类的实例</code>，从人类当中创建了hsp对象</li>
<li>类是对象的<code>模板</code>，对象是类的<code>实例</code></li>
</ul>
<p><strong>内存分析</strong></p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606165455132.png" alt="image-20240606165455132">	</p>
<ul>
<li><p>首先在<code>方法区</code>载入Cat类，包括<code>属性</code>与<code>方法</code></p>
<ul>
<li>属性&#x3D;成员变量&#x3D;field(字段)，可以是<strong>基本数据类型</strong>，也可以是<strong>引用数据类型</strong></li>
</ul>
</li>
<li><p>主类中执行 new Cat() 在<code>堆中创建相应对象</code>，并赋上<code>默认值</code></p>
<ul>
<li>默认值规则同数组，即int 0， short 0, byte 0, long 0, float 0.0,double 0.0， char \u0000，boolean false， String null</li>
</ul>
</li>
<li><p>将该对象地址0x11赋给<code>引用变量(变量名)</code>cat</p>
</li>
<li><p>修改对象值，其中字符串类型的存储的是常量的地址，指向<code>方法区常量池的地址</code></p>
<ul>
<li>访问属性用<code>&quot;对象名.属性名&quot;</code>访问</li>
</ul>
</li>
</ul>
<p>回答一下这个问题，脑海中快速过一下内存过程</p>
<img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606170142442.png" alt="image-20240606170142442" style="zoom:67%;" />	



<h3 id="7-1-4-细节-类和对象的内存分配机制"><a href="#7-1-4-细节-类和对象的内存分配机制" class="headerlink" title="7.1.4 细节-类和对象的内存分配机制*"></a>7.1.4 细节-类和对象的内存分配机制*</h3><p>JVM有以下部分，可见Cat的内存图</p>
<ul>
<li>堆：存放基本数据类型（局部变量）</li>
<li>堆：存放<code>对象</code>（Cat cat，数组）</li>
<li>方法区：<code>常量池</code>（字符串），<code>类加载</code>信息</li>
</ul>
<p>我们在以上基础上，再给出一道例题加深印象</p>
<blockquote>
<p>关键理解：我们修改b &#x3D; null，只是修改了引用变量，不影响整个对象</p>
</blockquote>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606170531812.png" alt="image-20240606170531812">	</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606170537640.png" alt="image-20240606170537640">	</p>
<h2 id="7-2-成员方法"><a href="#7-2-成员方法" class="headerlink" title="7.2 成员方法*"></a>7.2 成员方法*</h2><h3 id="7-2-1-为什么要成员方法"><a href="#7-2-1-为什么要成员方法" class="headerlink" title="7.2.1 为什么要成员方法"></a>7.2.1 为什么要成员方法</h3><p>我们定义猫类的时候，除了定义猫属性外，由于猫还会唱跳rap，那我们为<strong>了描述这些行为</strong>，需要引入<code>成员方法</code>来完善对Cat类的描述。</p>
<p>接下来给出需求，让你遍历一个数组。</p>
<ul>
<li>传统的方式直接for循环就可以了<ul>
<li>假设我们实现某个需求需要频繁遍历数组，每次要重新写一遍，<code>重用性</code>差</li>
<li>假设现在在团队开发，我想要遍历这个数组，其他人也需要遍历数组，这导致我们每个队友都需要想怎么遍历数组，遇到难一点的就骂街了</li>
</ul>
</li>
<li>但是如果我们编写一个MyTools工具类，后续只需要通过该类的实例就能使用遍历数组的成员方法，这无疑增加了代码的优雅性。<ul>
<li>你的队友也不用考虑实现数组遍历内部的实现机制，更加专心考虑<code>业务逻辑</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method02</span> &#123;</span><br><span class="line"><span class="comment">//编写一个 main 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//请遍历一个数组 , 输出数组的各个元素值</span></span><br><span class="line">    <span class="type">int</span> [][] map = &#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//使用方法完成输出, 创建 MyTools 对象</span></span><br><span class="line">    <span class="type">MyTools</span> <span class="variable">tool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTools</span>();</span><br><span class="line">    tool.printArr(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把输出的功能， 写到一个类的方法中,然后调用该方法即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTools</span> &#123;</span><br><span class="line">	<span class="comment">//方法， 接收一个二维数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printArr</span><span class="params">(<span class="type">int</span>[][] map)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======&quot;</span>);</span><br><span class="line">        <span class="comment">//对传入的 map 数组进行遍历输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; map[i].length; j++) &#123;</span><br><span class="line">            System.out.print(map[i][j] + <span class="string">&quot;_&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结，两个好处</p>
<ol>
<li>提高代码的复用性</li>
<li>可以将实现的细节封装起来， 然后供其他用户来调用即可</li>
</ol>
<h3 id="7-2-2-快速入门"><a href="#7-2-2-快速入门" class="headerlink" title="7.2.2 快速入门"></a>7.2.2 快速入门</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method01</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			a.问题分析</span></span><br><span class="line"><span class="comment">				AA类编写方法，判断奇数还是偶数，根据行列打印对应的字符</span></span><br><span class="line"><span class="comment">			b.思路分析</span></span><br><span class="line"><span class="comment">				1.创建AA类，属性写行列字符，并加入判断奇偶的方法和打印字符的方法</span></span><br><span class="line"><span class="comment">					写方法的要素：修饰符 返回类型 驼峰法名称 形参 方法体 （返回值）</span></span><br><span class="line"><span class="comment">				2.main类 创建AA类对象，调用checkOdd方法和print方法</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">		System.out.println(aa.checkOdd(<span class="number">213213</span>));  <span class="comment">// 判断整数是否为奇数</span></span><br><span class="line">		aa.print(<span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;#&#x27;</span>);  <span class="comment">// 3行4列 行列式</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> &#123;</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">checkOdd</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. public 表示方法是公开</span></span><br><span class="line">    <span class="comment">//2. void ： 表示方法没有返回值</span></span><br><span class="line">    <span class="comment">//3. print() : print 是方法名， () 形参列表</span></span><br><span class="line">    <span class="comment">//4. &#123;&#125; 方法体， 可以写我们要执行的代码</span></span><br><span class="line">    <span class="comment">//5. System.out.println(&quot;&quot;); 表示我们的方法就是输出一句话</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;====print_start====&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; row; i ++ ) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col; j ++ ) &#123;</span><br><span class="line">				System.out.print(c);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;====print_end====&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-2-3-细节-方法调用时内存分析"><a href="#7-2-3-细节-方法调用时内存分析" class="headerlink" title="7.2.3 细节-方法调用时内存分析*"></a>7.2.3 细节-方法调用时内存分析*</h3><p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606171508682.png" alt="image-20240606171508682">	</p>
<h3 id="7-2-4-细节-成员方法的使用"><a href="#7-2-4-细节-成员方法的使用" class="headerlink" title="7.2.4 细节-成员方法的使用"></a>7.2.4 细节-成员方法的使用</h3><p>提示：结合内存使用图理解</p>
<p>定义格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问修饰符 返回数据类型 方法名（形参列表..） &#123;<span class="comment">//方法体</span></span><br><span class="line">    语句；</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>细节</p>
<ul>
<li>访问修饰符<ul>
<li>不写默认访问， [有四种: public, protected, 默认, private]</li>
</ul>
</li>
<li><code>返回数据类型</code>： 表示成员方法输出, void 表示没有返回值<ul>
<li>一个方法<code>最多有一个返回值</code> ，但是多个返回值可以用一个 数组等存储类型返回</li>
<li>返回值也可以是<code>引用数据类型</code>，如字符串，类（提示：包括Integer类、Double类）</li>
</ul>
</li>
<li>方法名<ul>
<li>驼峰命名法，做到<strong>看名知意</strong>，例如getSum 得到数字的和</li>
</ul>
</li>
<li><code>形参</code>列表： 表示成员方法输入 cal(int n) ， getSum(int num1, int num2)  <ul>
<li>形参可以也可以是<code>引用数据类型</code></li>
<li>调用的时候对应着参数列表传入<strong>相同类型或兼容类型</strong> 的参数  </li>
<li>实参和形参的<strong>类型要一致或兼容</strong>， <strong>个数、 顺序必须一致</strong>  <ul>
<li><code>实参</code>：方法调用时实际传入的参数，<code>形参</code>：方法定义时的形式参数</li>
</ul>
</li>
</ul>
</li>
<li>方法主体： 表示为了实现某一功能代码块<ul>
<li>成员方法<strong>不能嵌套定义</strong></li>
</ul>
</li>
<li><code>return</code> 语句不是必须的。 <ul>
<li>void<strong>可以没有return</strong> 或者只写 return ;</li>
<li>返回值类型必须和 return 的值<strong>类型一致或兼容</strong></li>
</ul>
</li>
</ul>
<h4 id="补充：使用成员方法更改-访问属性"><a href="#补充：使用成员方法更改-访问属性" class="headerlink" title="补充：使用成员方法更改 访问属性"></a>补充：使用成员方法更改 访问属性</h4><p>需求：编写类Book，定义方法updatePrice，实现更改某本书的价格，具体:如果价格 &gt; 150,则更改为150，如果价格 &gt; 100,更改为100，否则不变 Homework03.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeWork03</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">160</span>);</span><br><span class="line">		book.updatePrice();</span><br><span class="line">		book.getPrice();</span><br><span class="line">		book.updatePrice();</span><br><span class="line">		book.getPrice();</span><br><span class="line">		book.updatePrice();</span><br><span class="line">		book.getPrice();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">	<span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.price = price;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatePrice</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.price &gt; <span class="number">150</span>) <span class="built_in">this</span>.price = <span class="number">150</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.price &gt; <span class="number">100</span>) <span class="built_in">this</span>.price = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="built_in">this</span>.price);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="7-3-基本数据类型传参机制"><a href="#7-3-基本数据类型传参机制" class="headerlink" title="7.3 基本数据类型传参机制*"></a>7.3 基本数据类型传参机制*</h2><h3 id="7-3-1-基本数据类型传参"><a href="#7-3-1-基本数据类型传参" class="headerlink" title="7.3.1 基本数据类型传参"></a>7.3.1 基本数据类型传参</h3><ul>
<li>方法的值拷贝</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606213404839.png" alt="image-20240606213404839">	</p>
<h3 id="7-3-2-引用数据类型传参"><a href="#7-3-2-引用数据类型传参" class="headerlink" title="7.3.2 引用数据类型传参"></a>7.3.2 引用数据类型传参</h3><ul>
<li>当调用B类里的test100方法时，首先在<strong>栈里新建一块内存</strong></li>
<li>在test100方法中，对引用地址对应的堆空间<code>对象</code>的元素进行<strong>修改</strong></li>
<li><strong>执行完后pop该内存</strong>，继续执行主栈的语句块</li>
</ul>
<blockquote>
<p>结论：引用拷贝，形参的变换会影响实参，本质上是：main主类将地址传递给BB了，BB也指向了引用地址，所以会影响，执行完pop，执行main类之后的语句。</p>
</blockquote>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606213624303.png" alt="image-20240606213624303">	</p>
<p>进一步思考：</p>
<ul>
<li>如果在test100方法中，对传递过来的<code>引用变量 置为 null</code>，是否会影响主类的引用变量arr?<ul>
<li>栈中BB类该语句块准备将指向Person对象的引用变量p赋值为null，但这并不会使得main方法的p指针为空指针执行完后，main正常执行，换句话说，该语句<strong>并没有改变main函数中的引用变量</strong>，因此没有改变堆中对象的值</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606214230930.png" alt="image-20240606214230930">	</p>
<ul>
<li>如果在test100方法中，<code>新建一个类B的对象</code>，再对其修改，主类中的引用变量arr 的 成员变量是否发生变化？<ul>
<li>BB类中的p指向了一块新的person对象，并将该对象的age属性修改为了123执行完后，main应当依旧正常执行，因为<strong>本质上该语句修改的只是在我这个BB类上的引用变量p</strong>，main函数上的引用变量p并没有影响的。</li>
<li>补充：当执行完test200后，该语句块会从栈中弹出，而此时将没有引用变量指向最新的对象（局部变量），<strong>该对象将会被回收</strong>。</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606214241462.png" alt="image-20240606214241462">	</p>
<p>完整的coding测试如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    执行结果：</span></span><br><span class="line"><span class="comment">        a = 10 b = 20</span></span><br><span class="line"><span class="comment">        1 2 3</span></span><br><span class="line"><span class="comment">        0 1 2</span></span><br><span class="line"><span class="comment">        执行方法前：人的年龄是0</span></span><br><span class="line"><span class="comment">        执行方法后：人的年龄是100</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodParameter</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 值传递 基本数据类型test</span></span><br><span class="line">		<span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">		aa.swap(a, b);</span><br><span class="line">		System.out.println(<span class="string">&quot;a = &quot;</span> + a + <span class="string">&quot; b = &quot;</span> + b);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 引用传递1 数组test</span></span><br><span class="line">		<span class="type">BB</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">		<span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">		bb.test100(arr);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length; i ++ ) &#123;</span><br><span class="line">			System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 引用传递2 类test</span></span><br><span class="line">		<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();  <span class="comment">// 默认 0, 0</span></span><br><span class="line">		System.out.println(<span class="string">&quot;\n执行方法前：人的年龄是&quot;</span> + p.age);</span><br><span class="line">		bb.test200(p);</span><br><span class="line">		System.out.println(<span class="string">&quot;执行方法后：人的年龄是&quot;</span> + p.age);  <span class="comment">// 可以看到，既没有报空指针异常，也没有修改为123</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> &#123;</span><br><span class="line">	<span class="comment">// 值拷贝 形参不影响实参</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> &#123;</span><br><span class="line">	<span class="comment">// BB类主要负责接收数组参数，测试main类中的实参是否会随着形参的变化而发生变化</span></span><br><span class="line">	<span class="comment">// 结论：引用拷贝，形参的变换会影响实参，本质上是：main主类将地址传递给BB了，BB也指向了引用地址，所以会影响，执行完pop，执行main类之后的语句。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test100</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length; i ++ ) &#123;</span><br><span class="line">			System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			arr[i] --;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test200</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">		p.age = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			分析1：此时栈中BB类该语句块准备将指向Person对象的引用变量p赋值为null，但这并不会使得main方法的p指针为空指针</span></span><br><span class="line"><span class="comment">			执行完后，main正常执行，换句话说，该语句并没有改变main函数中的引用变量，更没有改变引用对象的值</span></span><br><span class="line"><span class="comment">		*/</span>	</span><br><span class="line">		p = <span class="literal">null</span>;  	</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			分析2：此时在栈中，BB类中的p指向了一块新的person对象，并将该对象的age属性修改为了123</span></span><br><span class="line"><span class="comment">			执行完后，main应当依旧正常执行，因为本质上该语句修改的只是在我这个BB类上的引用变量p，main函数上的引用变量p并没有影响的。</span></span><br><span class="line"><span class="comment">			补充：当执行完test200后，该语句块会从栈中弹出，而此时将没有引用变量指向最新的对象（局部变量），该对象将会被回收。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		p.age = <span class="number">123</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> sal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-3-3-成员方法返回值为引用数据类型"><a href="#7-3-3-成员方法返回值为引用数据类型" class="headerlink" title="7.3.3 成员方法返回值为引用数据类型"></a>7.3.3 成员方法返回值为引用数据类型</h3><ul>
<li>在方法体内新建了一个对象</li>
<li>最终返回该对象的引用</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606214842615.png" alt="image-20240606214842615">	</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyPerson</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			a.需求分析</span></span><br><span class="line"><span class="comment">				要求编写copyPerson方法，用于复制Person对象，并返回该对象，需要两个独立空间的对象但属性相同</span></span><br><span class="line"><span class="comment">			b.思路分析</span></span><br><span class="line"><span class="comment">				在MyTool类中编写该方法，传入被复制的Person对象，返回类型是Person类型，具体代码块只需要new一个新的Person对象，并予以返回即可完成需求</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		p1.age = <span class="number">111</span>;</span><br><span class="line">		p1.sal = <span class="number">1500</span>;</span><br><span class="line"></span><br><span class="line">		<span class="type">MyTools</span> <span class="variable">myTools</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTools</span>();</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> myTools.copyPerson(p1);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;p1.age: &quot;</span> + p1.age + <span class="string">&quot;, p2.age: &quot;</span> + p2.age);</span><br><span class="line">		<span class="comment">// 通过对象的HashCode检查是否是同一空间，或者直接比较</span></span><br><span class="line">		System.out.println(p1 == p2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> sal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTools</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> Person <span class="title function_">copyPerson</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		p1.age = p.age;</span><br><span class="line">		p1.sal = p.sal;</span><br><span class="line">		<span class="keyword">return</span> p1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="补充：返回Double类解决空指针异常"><a href="#补充：返回Double类解决空指针异常" class="headerlink" title="补充：返回Double类解决空指针异常"></a>补充：返回Double类解决空指针异常</h4><ul>
<li>需求：返回数组最大值，基本业务已经实现，现在要考虑代码的<code>健壮性</code>，即解决空数组和空指针的情况<ul>
<li>思路：<strong>此时不能返回任何一个double类型来表示不合法的情况，所以只能用<code>null</code>来接收</strong><ul>
<li>但是又引出了新的问题，null和double类型如何合并数据类型，从而能让成员方法返回呢？答案是返回封装类。</li>
</ul>
</li>
</ul>
</li>
<li>1.<code>空数组</code>解决：加入arr.length判断，如果不合法，<code>返回空指针</code><ul>
<li>由于<strong>又需要返回空指针，又需要返回double数据类型</strong>，所以需要将返回类型设置成<code>Double封装类</code></li>
</ul>
</li>
<li>2.<code>空指针</code>解决：加入arr !&#x3D; 0 特判即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeWork01</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">A01</span> <span class="variable">a01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A01</span>();</span><br><span class="line">		<span class="type">Double</span> <span class="variable">res1</span> <span class="operator">=</span> a01.max(<span class="keyword">new</span> <span class="title class_">double</span>[]&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>&#125;);</span><br><span class="line">		<span class="keyword">if</span> (res1 != <span class="literal">null</span>) System.out.println(res1);</span><br><span class="line">		<span class="keyword">else</span> System.out.println(<span class="string">&quot;输入有误&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">Double</span> <span class="variable">res2</span> <span class="operator">=</span> a01.max(<span class="literal">null</span>); <span class="comment">// 会报空指针异常，加上特判</span></span><br><span class="line"><span class="comment">//		Double res2 = a01.max(new double[]&#123;&#125;); // 默认元素赋值</span></span><br><span class="line">		<span class="keyword">if</span> (res2 != <span class="literal">null</span>) System.out.println(res2);</span><br><span class="line">		<span class="keyword">else</span> System.out.println(<span class="string">&quot;输入有误&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A01</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> Double <span class="title function_">max</span><span class="params">(<span class="type">double</span>[] arr)</span> &#123;</span><br><span class="line">		<span class="comment">// 保证arr至少有一个元素，做完业务以后再考虑健壮性</span></span><br><span class="line">		<span class="keyword">if</span> (arr != <span class="literal">null</span> &amp;&amp; arr.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; arr.length; i ++ ) &#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[i] &gt; res) res = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 该方法改为返回空对象</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>又比如说，我要做除法操作，但是除数为0时，我们依旧可以通过返回空指针的方法来实现对异常的特判</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer <span class="title function_">div</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.b == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.a / <span class="built_in">this</span>.b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="7-4-方法的递归调用"><a href="#7-4-方法的递归调用" class="headerlink" title="7.4 方法的递归调用**"></a>7.4 方法的递归调用**</h2><h3 id="7-4-1-为什么要递归"><a href="#7-4-1-为什么要递归" class="headerlink" title="7.4.1 为什么要递归"></a>7.4.1 为什么要递归</h3><p>递归就是<strong>自己调用自己</strong>，每次传入不同的变量</p>
<p>两个好处</p>
<ul>
<li>有助于解决复杂问题<ul>
<li>各种<code>数学问题</code>如: <strong>8皇后问题</strong>，<strong>汉诺塔,阶乘问题,迷宫问题, 球和篮子的问题</strong>(google编程大赛)</li>
<li>各种<code>算法</code>中也会使用到递归，比如<strong>快排，归并排序，二分查找，分治算法</strong>等</li>
</ul>
</li>
<li>代码<code>简洁</code></li>
</ul>
<h3 id="7-4-2-快速入门"><a href="#7-4-2-快速入门" class="headerlink" title="7.4.2 快速入门"></a>7.4.2 快速入门</h3><p>接下来，给出简单实例来体现递归解决复杂问题。</p>
<ul>
<li>以输出1，2，3，4为例，可以看到栈空间内存的变化和传递</li>
</ul>
<img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606215851401.png" alt="image-20240606215851401" style="zoom:67%;" />	

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">		t1.test2(<span class="number">4</span>);</span><br><span class="line">		System.out.println(t1.factrial(<span class="number">5</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">	<span class="comment">// 每一个栈都是完整的执行方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		<span class="comment">// 注意递归要向条件不断逼近，不然会栈溢出</span></span><br><span class="line">		<span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">			test(n - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;n = &quot;</span> + n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">			test2(n - <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;n = &quot;</span> + n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">factrial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> factrial(n - <span class="number">1</span>) * n;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-4-3-细节-递归保护栈的规则"><a href="#7-4-3-细节-递归保护栈的规则" class="headerlink" title="7.4.3 细节-递归保护栈的规则"></a>7.4.3 细节-递归保护栈的规则</h3><ul>
<li>每一次执行一个方法，就会创建一个受保护的空间（<code>栈空间</code>）</li>
<li>各个方法的**<code>局部变量</code>是独立**的，不会相互影响（体现出受保护）</li>
<li>同样地，遵循方法的传参机制，如果是<code>引用类型变量</code>，那么会共享对应的对象数据</li>
<li>递归<strong>必须向递归条件逼近</strong>，否则无限递归造成<code>栈溢出</code></li>
<li>方法执行完成后，遵守该原则：谁调用，就将结果<code>返回</code>给谁。</li>
</ul>
<p>以阶层的内存数据传递图为例，快速过一下上述规则</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606220310657.png" alt="image-20240606220310657">	</p>
<h3 id="7-4-4-递归解决较难问题实例"><a href="#7-4-4-递归解决较难问题实例" class="headerlink" title="7.4.4 递归解决较难问题实例"></a>7.4.4 递归解决较难问题实例</h3><h4 id="斐波那契和猴子吃桃（数学问题）"><a href="#斐波那契和猴子吃桃（数学问题）" class="headerlink" title="斐波那契和猴子吃桃（数学问题）"></a>斐波那契和猴子吃桃（数学问题）</h4><ul>
<li><p>请使用递归的方式求出<code>斐波那契数</code>1,1,2,3,5,8,13…给你一个整数n，求出它的值是多</p>
</li>
<li><p><code>猴子吃桃子</code>问题:有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个!以后每天猴子都吃其中的一半，然后再多吃一个。当到第10天时，想再吃时(即还没吃)发现只有1个桃子了。问题:最初共多少个桃子?</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionExercise</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">fibNum</span> <span class="operator">=</span> t1.getFib(i);  <span class="comment">// 注意命名要能看懂</span></span><br><span class="line">			<span class="keyword">if</span> (fibNum != -<span class="number">1</span>) &#123;</span><br><span class="line">				System.out.print(fibNum + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.print(<span class="string">&quot;error &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">0</span>; day &lt; <span class="number">10</span>; day ++ ) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">peachNum</span> <span class="operator">=</span> t1.getPeach(day);</span><br><span class="line">			<span class="keyword">if</span> (peachNum != -<span class="number">1</span>) System.out.println(<span class="string">&quot;猴子第&quot;</span> + day + <span class="string">&quot;天有&quot;</span> + peachNum + <span class="string">&quot;个桃子&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;猴子第&quot;</span> + day + <span class="string">&quot;天不合法！合法范围：[1, 10]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">	<span class="comment">// 斐波那契，注意非法输入</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> getFib(n - <span class="number">1</span>) + getFib(n - <span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPeach</span><span class="params">(<span class="type">int</span> day)</span> &#123;</span><br><span class="line">		<span class="comment">// 递推关系：前一天桃子数 = (后一天桃子数 + 1) * 2</span></span><br><span class="line">		<span class="keyword">if</span> (day == <span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (day &gt;= <span class="number">1</span> &amp;&amp; day &lt;= <span class="number">9</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> (getPeach(day + <span class="number">1</span>) + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="迷宫问题（图论-回溯）"><a href="#迷宫问题（图论-回溯）" class="headerlink" title="迷宫问题（图论&amp;回溯）"></a>迷宫问题（图论&amp;回溯）</h4><p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606220537814.png" alt="image-20240606220537814">	</p>
<ul>
<li>a.问题分析<ul>
<li>寻找一条路径 从map[1][1]到map[6][5]的一条路径</li>
</ul>
</li>
<li>b.思路分析<ul>
<li>1.定义：map[][]值为0时，默认可走，<strong>1是障碍物，2是可以走，3是走过了发现不能走</strong></li>
<li>2.如果终点map[7][6]为2，直接返回true</li>
<li>3.如果该点的值为0：上右下左可以走，就返回true，否则发现走过以后不能走 设置为3 返回false</li>
<li>4.如果为1,2,3,4则表示不能走，返回false</li>
</ul>
</li>
<li>c.深入分析<ul>
<li>如果map[2][2]设置为1，即在第3行第2列放上障碍物</li>
<li>上左下右的策略递归执行，以第一步为例<ul>
<li>首先在map[1][1]处上左发现直接跑不通，因为他们有障碍物，不为0</li>
<li>然后在map[2][1]处通过上左下右的策略 发现跑不通，将其设置为3</li>
<li>接下来<code>回溯</code>到map[1][1]，发现往下走由于该处为3，不为0，跑不通，接着走右边的策略</li>
<li>接着在map[1][2]处继续递归</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>执行结果：</p>
<blockquote>
<p>1 1 1 1 1 1 1<br>1 0 0 0 0 0 1<br>1 0 1 0 0 0 1<br>1 1 0 0 0 0 1<br>1 0 0 0 0 0 1<br>1 0 0 0 0 0 1<br>1 0 0 0 0 0 1<br>1 1 1 1 1 1 1</p>
<p>----------------</p>
<p>1 1 1 1 1 1 1<br>1 2 2 2 2 2 1<br>1 3 1 2 2 2 1<br>1 1 2 2 2 2 1<br>1 2 2 2 2 2 1<br>1 2 2 2 2 2 1<br>1 2 2 3 2 2 1<br>1 1 1 1 1 1 1</p>
</blockquote>
<p>完整coding</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MiGong</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">		 <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">		 <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">		 <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">		 <span class="comment">// 四周围墙&#123;</span></span><br><span class="line"> 		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len2; i ++) &#123;</span><br><span class="line"> 			map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line"> 			map[len1 - <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len1 - <span class="number">1</span>; i ++ ) &#123;</span><br><span class="line"> 			map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"> 			map[i][len2 - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"> 		map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"> 		<span class="comment">// map[1][2] = 1;</span></span><br><span class="line"> 		map[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> 		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; map.length; i ++ ) &#123;</span><br><span class="line"> 			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; map[i].length; j ++ ) &#123;</span><br><span class="line"> 				System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line"> 			&#125;</span><br><span class="line"> 			System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"></span><br><span class="line"> 		<span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line"> 		t.getRoute(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"> 		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; map.length; i ++ ) &#123;</span><br><span class="line"> 			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; map[i].length; j ++ ) &#123;</span><br><span class="line"> 				System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line"> 			&#125;</span><br><span class="line"> 			System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		a.问题分析</span></span><br><span class="line"><span class="comment">			寻找一条路径 从map[1][1]到map[6][5]的一条路径</span></span><br><span class="line"><span class="comment">		b.思路分析</span></span><br><span class="line"><span class="comment">			1.定义：map[][]值为0时，默认可走，1是障碍物，2是可以走，3是走过了发现不能走</span></span><br><span class="line"><span class="comment">			2.如果终点map[7][6]为2，直接返回true</span></span><br><span class="line"><span class="comment">			3.如果该点的值为0：上右下左可以走，就返回true，否则发现走过以后不能走 设置为3 返回false</span></span><br><span class="line"><span class="comment">			4.如果为1,2,3,4则表示不能走，返回false</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> Boolean <span class="title function_">getRoute</span><span class="params">(<span class="type">int</span>[][] map, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">			map[i][j] = <span class="number">2</span>;</span><br><span class="line">			<span class="comment">// 上左下右的策略</span></span><br><span class="line">			<span class="keyword">if</span> (getRoute(map, i - <span class="number">1</span>, j)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (getRoute(map, i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (getRoute(map, i + <span class="number">1</span>, j)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (getRoute(map, i, j + <span class="number">1</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				map[i][j] = <span class="number">3</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="汉诺塔（数学问题）"><a href="#汉诺塔（数学问题）" class="headerlink" title="汉诺塔（数学问题）"></a>汉诺塔（数学问题）</h4><p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606221414437.png" alt="image-20240606221414437">	</p>
<p>要完成从A塔 借助B塔 到C塔移动n个元素【move(int num, char a, char b, char c) 】完成该问题，且每一个保证上面比下面小</p>
<p>按照以下方式<code>递归</code>：</p>
<ul>
<li>A塔的前n-1个 借助C塔 放到B塔完成：<strong>move(num - 1, a, c, b);</strong></li>
<li>A塔的最下面的一个 借助B塔 放到C塔完成 <strong>move(1, a, b, c);  或者直接  System.out.println(a + “ &#x3D;&gt; “ + c);</strong></li>
<li>B塔的那n-1个借助A塔 放到C塔完成 <strong>move(num - 1, b, a, c);</strong></li>
</ul>
<p><code>递归终止条件</code>（以A塔放到C塔借助B塔为例）：</p>
<ul>
<li>如果A塔只需要放1个到C塔，那么就直接输出 A &#x3D;&#x3D;&gt; C</li>
<li>该栈退出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HonoiTower</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Tower</span> <span class="variable">tower</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tower</span>();</span><br><span class="line">		tower.move(<span class="number">5</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tower</span> &#123;</span><br><span class="line">	<span class="comment">// a的num个元素根据汉诺塔规则 借助b 移动到c</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> num, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(a + <span class="string">&quot; =&gt; &quot;</span> + c);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			move(num - <span class="number">1</span>, a, c, b);</span><br><span class="line">			System.out.println(a + <span class="string">&quot; =&gt; &quot;</span> + c);</span><br><span class="line">			move(num - <span class="number">1</span>, b, a, c);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="八皇后问题（数学问题）"><a href="#八皇后问题（数学问题）" class="headerlink" title="八皇后问题（数学问题）"></a>八皇后问题（数学问题）</h4><p>需求分析：在 8× 8 格的国际象棋上摆放八个皇后， 使其不能互相攻击， 即： 任意两个皇后都不能处于同一行、 同一列或同一斜线上， 问有多少种摆法  </p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606222130514.png" alt="image-20240606222130514">	</p>
<p>思路分析：</p>
<ul>
<li>第一个皇后先放第一行第一列</li>
<li>第二个皇后放在第二行第一列、然后判断是否OK，如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</li>
<li>继续第三个皇后，还是第一列、第二列…直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解</li>
<li>当得到一个正确解时，在栈回退到上一个栈时，就会开始回湖，即将第一个皇后，放到第一列的所有正确解，全部得到.然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 【示意图】</li>
<li>说明:理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题.<ul>
<li>arr[8]&#x3D;{0，4,7.5,2.6，13} &#x2F;&#x2F;对应arr 下标 表示第几行，即第几个皇后，arr[i]&#x3D; val，val 表示第i+1个皇后，放在第i+1行的第val+1列</li>
</ul>
</li>
</ul>
<h2 id="7-5-方法重载-Overload"><a href="#7-5-方法重载-Overload" class="headerlink" title="7.5 方法重载(Overload)"></a>7.5 方法重载(Overload)</h2><h3 id="7-5-1-为什么要重载"><a href="#7-5-1-为什么要重载" class="headerlink" title="7.5.1 为什么要重载"></a>7.5.1 为什么要重载</h3><ul>
<li><p>在实际需求中，我们需要在同一个类中，有多个<code>同名方法的存在， 但要求 形参列表不一致！  </code></p>
<ul>
<li>比如System.out.println(?)，里面可以是int类型，也可以是String类型</li>
</ul>
</li>
<li><p>要解决上述问题并且又不想重复定义，那么就需要<code>方法的重载(Overload)</code></p>
<ul>
<li><p>减轻了起名的麻烦</p>
</li>
<li><p>减轻了记名的麻烦</p>
</li>
</ul>
</li>
</ul>
<p>以System.out.println为例，out是在System包下的PrintStream类，在该类下定义了如下的方法</p>
<img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606223249873.png" alt="image-20240606223249873" style="zoom: 67%;" />	



<h3 id="7-5-2-快速入门"><a href="#7-5-2-快速入门" class="headerlink" title="7.5.2 快速入门"></a>7.5.2 快速入门</h3><p>加法计算器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类： MyCalculator 方法： calculate</span></span><br><span class="line"><span class="comment">// 1) calculate(int n1, int n2) //两个整数的和</span></span><br><span class="line"><span class="comment">// 2) calculate(int n1, double n2) //一个整数， 一个 double 的和</span></span><br><span class="line"><span class="comment">// 3) calculate(double n2, int n1)//一个 double ,一个 Int 和</span></span><br><span class="line"><span class="comment">// 4) calculate(int n1, int n2,int n3)//三个 int 的和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Overload01</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">MyCalculator</span> <span class="variable">myCalculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCalculator</span>();</span><br><span class="line">		<span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> myCalculator.calculate(<span class="number">1</span>, <span class="number">1.1</span>);</span><br><span class="line">		<span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> myCalculator.calculate(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;a = &quot;</span> + a + <span class="string">&quot;, b = &quot;</span> + b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCalculator</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> <span class="title function_">calculate</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b + c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-5-3-细节-是否构成重载"><a href="#7-5-3-细节-是否构成重载" class="headerlink" title="7.5.3 细节-是否构成重载"></a>7.5.3 细节-是否构成重载</h3><ul>
<li><code>方法名</code>：<strong>必须一致</strong></li>
<li><code>形参列表</code>：<strong>必须不一样</strong><ul>
<li>形参类型，个数，顺序，至少有一样不同</li>
<li>与参数名无关</li>
</ul>
</li>
<li><code>返回类型</code>：没要求</li>
</ul>
<img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240606223658762.png" alt="image-20240606223658762" style="zoom:67%;" />	



<p>coding实例1</p>
<p>说明：<strong>重载先写参数个数少的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverloadExercise</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			编写程序，类Methods中定义三个重载方法并调用。方法名为m。三个方法分</span></span><br><span class="line"><span class="comment">			别接收一个int参数、两个int参数、一个字符串参数。分别执行平方运算并输出</span></span><br><span class="line"><span class="comment">			结果，相乘并输出结果，输出字符串信息。在主类的main()方法中分别用参数</span></span><br><span class="line"><span class="comment">			区别调用三个方法。OverLoadExercise.java</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">Methods</span> <span class="variable">methods</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Methods</span>();</span><br><span class="line">		methods.m(<span class="number">2</span>);</span><br><span class="line">		methods.m(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">		methods.m(<span class="string">&quot;You are right&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			在Methods类，定义三个重载方法max()，第一个方法，返回两个int值中的最</span></span><br><span class="line"><span class="comment">			大值，第二个方法，返回两个double值中的最大值，第三个方法，返回三个</span></span><br><span class="line"><span class="comment">			double值中的最大值，并分别调用三个方法。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		System.out.println(methods.max(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">		System.out.println(methods.max(<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">30</span>));</span><br><span class="line">		System.out.println(methods.max(<span class="number">1.1</span>, <span class="number">3.3</span>, (<span class="type">byte</span>)<span class="number">30</span>));  <span class="comment">// 可以执行第三种max方法，允许精度提升 自动类型转换</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Methods</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">		System.out.println(x * x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">		System.out.println(a * b);</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(String s)</span> &#123;</span><br><span class="line">		System.out.println(s);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用了int的 没有自动类型转换&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用了double的 发生了自动类型转换&quot;</span>);</span><br><span class="line">		<span class="type">double</span> <span class="variable">max1</span> <span class="operator">=</span> a &gt; b ? a : b;</span><br><span class="line">		<span class="keyword">return</span> max1 &gt; c ? max1 : c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-6-可变参数"><a href="#7-6-可变参数" class="headerlink" title="7.6 可变参数"></a>7.6 可变参数</h2><h3 id="7-6-1-为什么要可变参数"><a href="#7-6-1-为什么要可变参数" class="headerlink" title="7.6.1 为什么要可变参数"></a>7.6.1 为什么要可变参数</h3><ul>
<li>需求：将同一个类中<strong>多个同名同功能但参数个数不同</strong>的方法， 封装成一个方法。</li>
<li>可以使用可变参数<ul>
<li>如果使用数组接收，那么由于<code>不确定个数</code>会显得比较拉跨</li>
<li>如果使用多个方法重载，还是会由于不确定个数显得很呆</li>
<li>所以可变参数就引出来了</li>
</ul>
</li>
<li>可变参数本质上还是可以当作一个<code>数组</code>来处理</li>
</ul>
<h3 id="7-6-2-快速入门"><a href="#7-6-2-快速入门" class="headerlink" title="7.6.2 快速入门"></a>7.6.2 快速入门</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarParameter</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">LjyMethod</span> <span class="variable">ljyMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LjyMethod</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;sum:&quot;</span> + ljyMethod.sum(<span class="number">0</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;sum:&quot;</span> + ljyMethod.sum(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">		<span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">		System.out.println(<span class="string">&quot;sum:&quot;</span> + ljyMethod.sum(<span class="number">5</span>, array));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LjyMethod</span> &#123;</span><br><span class="line">	<span class="comment">// 计数：2个和 3个和 4个和.... 重载==&gt; 可变变量 优化</span></span><br><span class="line">	<span class="comment">// int...就表示接收可变参数（0-多个参数）</span></span><br><span class="line">	<span class="comment">// 使用时，可以当作数组使用</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span>... nums)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;parameter&#x27;s number:&quot;</span> + nums.length);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length; i ++ ) &#123;</span><br><span class="line">			sum += nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-6-3-细节-可变参数的使用"><a href="#7-6-3-细节-可变参数的使用" class="headerlink" title="7.6.3 细节-可变参数的使用"></a>7.6.3 细节-可变参数的使用</h3><ul>
<li>可变参数实参范围是 <code>0 - 多个参数</code></li>
<li>可变参数的实参可以是<code>数组</code></li>
<li>可变参数的本质就是<code>数组</code></li>
<li>可变参数可以和普通类型的参数一起放在形参列表中，但<code>可变参数必须在最后</code></li>
<li>可变参数只能有<code>1个</code></li>
</ul>
<p>实例说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarParameter</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			有三个方法，分别实现返回姓名和两门课成绩(总分)，返回姓名和三门课成绩(总</span></span><br><span class="line"><span class="comment">			分)，返回姓名和五门课成绩(总分)。封装成一个可变参数的方法</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">		<span class="type">double</span>[] score1 = &#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;;</span><br><span class="line">		String[] res1 = ljyMethod.showScore(<span class="string">&quot;zsh&quot;</span>, score1);</span><br><span class="line">		System.out.println(res1[<span class="number">0</span>] + <span class="string">&quot; &quot;</span> + res1[<span class="number">1</span>]);</span><br><span class="line">		<span class="type">double</span>[] score2 = &#123;<span class="number">50</span>, <span class="number">60</span>, <span class="number">75</span>, <span class="number">99</span>, <span class="number">48</span>&#125;;</span><br><span class="line">		String[] res2 = ljyMethod.showScore(<span class="string">&quot;ymq&quot;</span>, score2);</span><br><span class="line">		System.out.println(res2[<span class="number">0</span>] + <span class="string">&quot; &quot;</span> + res2[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LjyMethod</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String[] showScore(String name, <span class="type">double</span>... score) &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">totalScore</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; score.length; i ++) &#123;</span><br><span class="line">			totalScore += score[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;name, totalScore + <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-7-作用域"><a href="#7-7-作用域" class="headerlink" title="7.7 作用域"></a>7.7 作用域</h2><h3 id="7-7-1-全局变量与局部变量"><a href="#7-7-1-全局变量与局部变量" class="headerlink" title="7.7.1 全局变量与局部变量"></a>7.7.1 全局变量与局部变量</h3><p>根据作用域的区分，我们对变量有<code>全局变量</code>和<code>局部变量</code></p>
<ul>
<li>全局变量：<code>属性</code>，作用域为整个Cat类中</li>
<li>局部变量：<code>成员方法</code>中的变量，作用域只在该方法的代码块中</li>
<li><strong>全局变量可以不赋值（默认值），局部变量必须赋值</strong></li>
</ul>
<h3 id="7-7-2-细节-作用域的使用"><a href="#7-7-2-细节-作用域的使用" class="headerlink" title="7.7.2 细节-作用域的使用"></a>7.7.2 细节-作用域的使用</h3><ul>
<li><code>重名</code>：属性和局部变量可以重名，直接用名称访问时遵循<code>就近原则</code><ul>
<li>但同一个成员方法中的变量是不可以重名的</li>
</ul>
</li>
<li><code>生命周期</code>：由于作用域不同，<strong>属性的生命周期长</strong>，伴随着对象的销毁而销毁，而<strong>局部变量生命周期短</strong>，伴随着代码块的结束而结束</li>
<li><code>作用域</code>：属性可以被本类或其他类使用（创建对象），而局部变量只能在代码块中使用</li>
<li><code>修饰符</code>：属性可以加修饰符，局部变量不可以加修饰符</li>
</ul>
<p>代码为例</p>
<ul>
<li>Person类中的getString方法中的 double age展示了可以能和属性重名</li>
<li>T类的test方法展示了属性的变量随着对象的销毁而销毁，T类的test2方法 展示了作为对象传递参数过程中，对象还没有被销毁</li>
<li>person.name展示了属性可以被其他类使用，Person类中的return name展示了属性可以被本类使用</li>
<li>protected douuble age展示了修饰符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarScope</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		System.out.println(person.getString(<span class="string">&quot;hsp&quot;</span>));</span><br><span class="line">		<span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">		t.test();</span><br><span class="line">		t.test2(person);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		System.out.println(person.name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">		System.out.println(p.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="comment">// 属性生命周期长，随着对象的死亡而死亡</span></span><br><span class="line">	<span class="comment">// 局部变量生命周期短，在一次调用方法的过程中</span></span><br><span class="line">	<span class="comment">// 全局变量可以加修饰符，局部变量不能加</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;ljy&quot;</span>;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">double</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getString</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="comment">// 同一个作用域不能重名</span></span><br><span class="line">		<span class="type">char</span> <span class="variable">age</span> <span class="operator">=</span> <span class="string">&#x27;7&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-8-构造方法-构造器"><a href="#7-8-构造方法-构造器" class="headerlink" title="7.8 构造方法&#x2F;构造器*"></a>7.8 构造方法&#x2F;构造器*</h2><h3 id="7-8-1-为什么要构造器"><a href="#7-8-1-为什么要构造器" class="headerlink" title="7.8.1 为什么要构造器"></a>7.8.1 为什么要构造器</h3><ul>
<li>我们之前在创建对象时，每次赋值都需要访问其对象的属性，对其赋值修改</li>
<li>但是如果现在要求：<code>创建对象后</code>，在创建对象语句中直接 通过传递对象的属性参数 来对其进行初始化，那么就需要<code>构造器</code>这个技术来方便我们进行赋值。</li>
</ul>
<h3 id="7-8-2-快速入门"><a href="#7-8-2-快速入门" class="headerlink" title="7.8.2 快速入门"></a>7.8.2 快速入门</h3><blockquote>
<p>[修饰符] 方法名(形参列表){<br>	方法体;<br>}  </p>
</blockquote>
<ul>
<li><code>修饰符</code>可以默认，也可以public protected private</li>
<li>构造器<strong>没有返回值</strong></li>
<li><code>方法名</code><strong>必须和类名一样</strong></li>
<li><code>参数列表</code>规则同成员方法的规则（见7.2.4）</li>
<li>构造器的调用，由<strong>系统自动完成</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constructor</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;ljy&quot;</span>, <span class="number">18</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;name &quot;</span> + person1.name + <span class="string">&quot;,age &quot;</span> + person1.age);</span><br><span class="line">		<span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;hsp&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;name &quot;</span> + person2.name + <span class="string">&quot;,age &quot;</span> + person2.age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器没有返回值 不能写void</span></span><br><span class="line">	<span class="comment">// 构造器名必须是类名</span></span><br><span class="line">	<span class="comment">// 形参列表规则同成员方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String pName, <span class="type">int</span> pAge)</span> &#123;</span><br><span class="line">		<span class="comment">// 完成属性的初始化（不是创建），请注意，构造器系统调用时不包括创建对象，此时对象已经创建完成了</span></span><br><span class="line">		<span class="comment">// 系统自动调用，用户不需要自行调用 person.Person</span></span><br><span class="line">		name = pName;</span><br><span class="line">		age = pAge;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器允许重载</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String pName)</span> &#123;</span><br><span class="line">		name = pName;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-8-3-细节-构造器的使用"><a href="#7-8-3-细节-构造器的使用" class="headerlink" title="7.8.3 细节-构造器的使用"></a>7.8.3 细节-构造器的使用</h3><ul>
<li>类可以进行<code>构造器的重载</code>。例如，创建人类对象的时候，只指定人名</li>
<li>构造器的名称要与<code>类名</code>相同</li>
<li>构造器<code>没有返回值</code></li>
<li>构造器在创建对象后完成<code>对象的初始化</code>，注意<strong>此时已经完成了创建对象</strong></li>
<li>如果没有<code>定义构造器</code>，则系统会默认定义无参构造器Cat() {}，使用javap反编译可以查看<ul>
<li>但是一旦定义了一个构造器，默认定义的将会被覆盖，<code>无参构造器需要重新定义一下</code>（重要）</li>
</ul>
</li>
</ul>
<p>给出实例</p>
<ul>
<li>注意：用户定义了两个参数的构造方法，如果还需要无参构造方法，就需要再定义一个</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorExercise</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			在前面定义的Person类中添加两个构造器:</span></span><br><span class="line"><span class="comment">			第一个无参构造器:利用构造器设置所有人的age属性初始值都为18</span></span><br><span class="line"><span class="comment">			第二个带pName和pAge两个参数的构造器:使得每次创建Person对象的同</span></span><br><span class="line"><span class="comment">			时初始化对象的age属性值和name属性值。分别使用不同的构造器，创建对象.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		<span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;hsp&quot;</span>, <span class="number">20</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;name &quot;</span> + person1.name + <span class="string">&quot;,age &quot;</span> + person1.age);</span><br><span class="line">		System.out.println(<span class="string">&quot;name &quot;</span> + person2.name + <span class="string">&quot;,age &quot;</span> + person2.age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="comment">// 默认&#123;null, 0&#125;</span></span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">		age = <span class="number">18</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String pName, <span class="type">int</span> pAge)</span> &#123;</span><br><span class="line">		name = pName;</span><br><span class="line">		age = pAge;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-8-4-带有构造器的对象创建内存分析"><a href="#7-8-4-带有构造器的对象创建内存分析" class="headerlink" title="7.8.4 带有构造器的对象创建内存分析"></a>7.8.4 带有构造器的对象创建内存分析</h3><p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240607081733704.png" alt="image-20240607081733704">	</p>
<ul>
<li>首先在方法区加载Person类信息</li>
<li>接下来在堆空间创建Person对象<ul>
<li>赋值默认值 {age: 0, name: null}</li>
<li>显式赋值{age: 90, name: null}</li>
<li>构造器初始化定义{age:20, name:”小倩”}<ul>
<li>方法区定义常量，name的值赋值为该常量的地址，而age的更新直接值拷贝</li>
</ul>
</li>
</ul>
</li>
<li>将该对象的地址赋值给对象名p</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240607082021064.png" alt="image-20240607082021064">	</p>
<h2 id="7-9-this关键字"><a href="#7-9-this关键字" class="headerlink" title="7.9 this关键字"></a>7.9 this关键字</h2><h3 id="7-9-1-为什么要this关键字"><a href="#7-9-1-为什么要this关键字" class="headerlink" title="7.9.1 为什么要this关键字"></a>7.9.1 为什么要this关键字</h3><p>在上述构造器的代码中，发现构造器的参数不是特别的好，如果能和属性名一样就可以让代码更加易读简洁了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造器没有返回值 不能写void</span></span><br><span class="line"><span class="comment">// 构造器名必须是类名</span></span><br><span class="line"><span class="comment">// 形参列表规则同成员方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String pName, <span class="type">int</span> pAge)</span> &#123;</span><br><span class="line">	<span class="comment">// 完成属性的初始化（不是创建），请注意，构造器系统调用时不包括创建对象，此时对象已经创建完成了</span></span><br><span class="line">	<span class="comment">// 系统自动调用，用户不需要自行调用 person.Person</span></span><br><span class="line">	name = pName;</span><br><span class="line">	age = pAge;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>



<p>使用<code>this</code>可以实现该需求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">	<span class="comment">// 完成属性的初始化（不是创建），请注意，构造器系统调用时不包括创建对象，此时对象已经创建完成了</span></span><br><span class="line">	<span class="comment">// 系统自动调用，用户不需要自行调用 person.Person</span></span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>



<h3 id="7-9-2-深入理解this关键字"><a href="#7-9-2-深入理解this关键字" class="headerlink" title="7.9.2 深入理解this关键字"></a>7.9.2 深入理解this关键字</h3><ul>
<li>可以看到在创建对象的时候，this指向的就是当前对象的地址空间<ul>
<li>简单来说this是在哪个对象调用的，this就指向哪个对象</li>
</ul>
</li>
</ul>
<img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240607082656034.png" alt="image-20240607082656034" style="zoom:67%;" />	



<h3 id="7-9-3-细节-this关键字的使用"><a href="#7-9-3-细节-this关键字的使用" class="headerlink" title="7.9.3 细节-this关键字的使用"></a>7.9.3 细节-this关键字的使用</h3><ul>
<li>this可以访问本类的<code>属性、方法、构造器</code><ul>
<li>访问构造器时，必须在构造方法的第一句，且只能有一句，如this(“ljy”, 10)</li>
<li>访问方法：this.方法名(参数列表)</li>
</ul>
</li>
<li>通过this用来区分当前类的<code>属性</code>和<code>局部变量</code><ul>
<li>this只能在类定义的<strong>内部</strong>中使用</li>
</ul>
</li>
</ul>
<p>现解决下述需求：定义 Person 类， 里面有 name、age 属性， 并提供 compareTo 比较方法， 用于判断是否和另一个人相等， 提供测试类 TestPerson<br>用于测试, 名字和年龄完全一样， 就返回 true, 否则返回 false  </p>
<p>说明</p>
<ul>
<li>可以看到不同的对象 this指向的都是两个对象本身的地址<ul>
<li>同时对象名p1 p2的地址也是不同的，印证了细节部分的说法</li>
</ul>
</li>
<li><strong>优先写参数少的，第一句可以写this(参数列表)来在空参数列表中对属性进行赋值操作</strong></li>
<li>使用this.hashCode()，访问了当前对象的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	hashCode-this:366712642</span></span><br><span class="line"><span class="comment">    hashCode-this:1829164700</span></span><br><span class="line"><span class="comment">    false</span></span><br><span class="line"><span class="comment">    true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">This</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		<span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;ljy&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">TestPerson</span> <span class="variable">testPerson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestPerson</span>();</span><br><span class="line">		System.out.println(person1.compareTo(person2));</span><br><span class="line">		System.out.println(testPerson.compareValue(person1, person2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>(<span class="string">&quot;ljy&quot;</span>, <span class="number">18</span>);  <span class="comment">// 必须在构造方法的第一句使用，进一步解释在继承模块讲解</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;  <span class="comment">// name就近找，this.name直接定位到当前对象的成员变量/属性</span></span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">		System.out.println(<span class="string">&quot;hashCode-this:&quot;</span> + <span class="built_in">this</span>.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Boolean <span class="title function_">compareTo</span><span class="params">(Person p2)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.hashCode() == p2.hashCode();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestPerson</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> Boolean <span class="title function_">compareValue</span><span class="params">(Person p1, Person p2)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> p1.name.equals(p2.name) &amp;&amp; p1.age == p2.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yuezi2048.github.io">yuezi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yuezi2048.github.io/2024/06/07/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/07.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89/">https://yuezi2048.github.io/2024/06/07/2.Areas🌐/back-end-java/1.JavaSE/基础篇——韩顺平/07.面向对象编程（基础部分）/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://yuezi2048.github.io" target="_blank">yuezi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/">基础篇——韩顺平</a></div><div class="post-share"><div class="social-share" data-image="/img/touxiang.jpg" data-sites="qq,wechat"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/06/04/2.Areas%F0%9F%8C%90/03.algorithm/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%951/" title="基础算法1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">基础算法1</div></div><div class="info-2"><div class="info-item-1">课上要求：算法思想，为什么这样写 课后要求：理解代码模板并能快速打出来 以2-3题课后习题来检验 我们可以重复习题3-5次 来提高代码熟练度 一、排序1.1 快速排序基本思想：我们是用到了划分的思想  首先我们要确定分界的点 我们让x划分成两个部分，使得所有左边的区间全部小于等于x，右边的区间全部大于等于x 递归地处理两段，让左边 右边分别排好序，就完成了排序。  	    关键是如何划分，我们给出三个方案： 划分的暴力方法，时间一样，但是代价是：划分两个O(n)的数组空间  a数组存储比x小的，b数组存储比x大的，然后合并在一起作为一次划分。  	 双指针 一次划分的过程  指针i 从左到右遍历，指针j 从右到左遍历 遍历指针i，当其指向的元素比x大的时候，停 遍历指针j，档期指向的元素比x小的时候，停，然后交换，swap(q[i], q[j]) i++，j–   当i和j相遇的时候，一次划分完成。  原理：我保证了指针i的前面元素比x小，指针j后面的元素比x大，从而完成了划分。 	    我们会发现存在许多边界问题...</div></div></div></a><a class="pagination-related" href="/2024/07/06/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/06.%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/" title="06.数组、排序和查找"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">06.数组、排序和查找</div></div><div class="info-2"><div class="info-item-1">六、数组、排序和查找6.1 数组使用为什么要数组：6只鸡，每只鸡的体重3kg,5kg,1kg,3.4kg,2kg,50kg ，问你平均体重怎么算？  没有数组我们只能通过定义6个变量，引申到1w只鸡就不太合适了 引申出数组，用来存放多个相同类型的数据 注：数组是一种引用类型    public class Array01 &#123;	public static void main(String[] args) &#123;		double[] hens = &#123;1, 2, 3&#125;;		double totalWeight = 0;		for (int i = 0; i &lt; hens.length; i ++ ) &#123;			System.out.println(&quot;第&quot; + (i + 1) + &quot;个元素是&quot; + hens[i]);			totalWeight += hens[i];		&#125;		System.out.println(&quot;平均体重是&quot; + (totalWeight /...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/11/05/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/01.%E5%86%85%E5%AE%B9%E6%A1%86%E6%9E%B6/" title="01.内容框架"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-05</div><div class="info-item-2">01.内容框架</div></div><div class="info-2"><div class="info-item-1">一、JavaSE内容介绍三个阶段循序渐进学习JavaSE，每个章节课后有面试/联系题 + 讲解，每个阶段结束后用项目检验巩固学习成果。 第一阶段：编程思想(P001 - P373)  第01章 内容介绍(P001 - P006)第02章 Java概述(P007 - P034)第03章 变量(P035 - P062)第04章 运算符(P063 - P103)第05章 程序控制结构(P104 - P155)第06章 数组、排序和查找(P156 - P191)第07章 面向对象编程（基础部分）(P192 - P263)第08章 面向对象编程（中级部分）(P264 - P361)第09章 房屋出租系统(P362 - P373)  第二阶段：编程能力(P374 - P661)  第10章 面向对象编程（高级部分）(P374 - P424)第11章 枚举和注解(P425 - P443)第12章 异常(P444 - P459)第13章 常用类(P460 - P498)第14章 集合(P499 - P553)第15章 泛型(P554 - P568)第16章 坦克大战1(P569 -...</div></div></div></a><a class="pagination-related" href="/2024/05/30/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/02.Java%E6%A6%82%E8%BF%B0/" title="02.Java概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-30</div><div class="info-item-2">02.Java概述</div></div><div class="info-2"><div class="info-item-1">二、Java概述2.1 Java特点2.1.1 Java历史程序：计算机编写的一系列有序指令的集合 诞生历史 	   Java8、Java11为LTS（长久支持版本），重点学习  现使用Sublime感受Java语言学习，巩固一些基础的代码编写与规范，后续使用idea或Eclipse。   2.1.2 Java语言的特点 面向对象（oop） 健壮性（强类型机制、异常处理、垃圾回收） 跨平台（本质上是编译好的class字节码文件可以通过各个操作系统的JVM运行） 解释性语言（同js,php），区别于C&#x2F;C++编译性语言，java编译后的代码不能直接被机器执行，需要jvm来解释，而编译性语言可以。  	 2.1.3 JDK、JRE、JVM*JDK（Java Development kit 开发工具包）  **JDK &#x3D; JRE  + Java开发工具（**包括java、javac、javadoc、javap等） JDK提供给开发人员进行Java开发，JDK本身包含JRE运行环境  JRE（Java Runtime Environment 运行环境）  JRE...</div></div></div></a><a class="pagination-related" href="/2024/05/30/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/03.%E5%8F%98%E9%87%8F/" title="03.变量"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-30</div><div class="info-item-2">03.变量</div></div><div class="info-2"><div class="info-item-1">三、变量3.1 变量入门 为什么要变量 一个程序就是一个世界，每个元素需要由变量来表示   变量是什么 变量组成三要素：类型 + 名称 + 值 类型 - int，名称 - a，值 - 1    public class Test &#123;    public static void main(String[] args) &#123;        int a = 1;        int b = 89;        System.out.println(a + &quot;\n&quot; + b);    &#125;&#125;   变量原理（上述代码为例）：变量名a指向新开辟的4字节内存，内存值为1，b变量同理 变量相当于内存中一个数据存储空间，变量名就是访问这个空间的索引    	    变量demo public class Var02 &#123;	//编写一个 main 方法    public static void main(String[] args) &#123;        //记录人的信息        int age = 30;     ...</div></div></div></a><a class="pagination-related" href="/2024/05/30/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/04.%E8%BF%90%E7%AE%97%E7%AC%A6/" title="04.运算符"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-30</div><div class="info-item-2">04.运算符</div></div><div class="info-2"><div class="info-item-1">四、运算符 算数运算符 赋值运算符 关系运算符（比较运算符） 逻辑运算符 位运算符 三元运算符  4.1 算数运算符	 细节  &#x2F; 号在整数中不保留小数  Java中，a % b 等价于 a - (int) a / b * b  10 % -3 &#x3D; 10 - 10 &#x2F; (-3) * (-3) &#x3D; 10 - 9 &#x3D; 1   重点关注两道面试题（关键点：++是一种自增运算，&#x3D;是一种赋值运算，自增的本质是需要临时变量实现的，之后再赋值操作）  使用内存分析法进行分析，每一步操作对应一个内存中变量值的修改    int i = 1;  // i =&gt; 1i = i ++;  // temp = i = 1 ,i = i + 1 = 2, i =temp = 1System.out.println(i); // 输出1    int i = 1; // i = 1i = ++ i; // i = i + 1 = 2, temp = i = 2, i = temp = 2	System.out.println(i); //...</div></div></div></a><a class="pagination-related" href="/2024/06/01/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/05.%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/" title="05.程序控制结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-01</div><div class="info-item-2">05.程序控制结构</div></div><div class="info-2"><div class="info-item-1">五、程序控制结构5.1 顺序控制	  细节  顺序控制中的变量需要前向引用  5.2 分支控制5.2.1 if-else 单分支 if 双分支 If-else 多分支 if-else if -else  	 细节  每个条件表达式都会走，直到有一个满足的，才会执行后面的代码块 可以没有else，此时if-else没有执行入口 最多只有一个执行入口  关注一个代码 boolean b = true;if (b=false) System.out.println(&quot;a&quot;);else if (b) System.out.println(&quot;b&quot;);else if (!b) System.out.println(&quot;c&quot;);  // 输出此代码块else System.out.println(&quot;d&quot;);    5.2.2 嵌套分支 建议嵌套不要超过3层，否则可读性很差 判断好某个条件，需要进一步判断各种情况下使用  	 5.2.3 switch快速入门 switch(表达式) &#123;    case...</div></div></div></a><a class="pagination-related" href="/2024/07/06/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/06.%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/" title="06.数组、排序和查找"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-06</div><div class="info-item-2">06.数组、排序和查找</div></div><div class="info-2"><div class="info-item-1">六、数组、排序和查找6.1 数组使用为什么要数组：6只鸡，每只鸡的体重3kg,5kg,1kg,3.4kg,2kg,50kg ，问你平均体重怎么算？  没有数组我们只能通过定义6个变量，引申到1w只鸡就不太合适了 引申出数组，用来存放多个相同类型的数据 注：数组是一种引用类型    public class Array01 &#123;	public static void main(String[] args) &#123;		double[] hens = &#123;1, 2, 3&#125;;		double totalWeight = 0;		for (int i = 0; i &lt; hens.length; i ++ ) &#123;			System.out.println(&quot;第&quot; + (i + 1) + &quot;个元素是&quot; + hens[i]);			totalWeight += hens[i];		&#125;		System.out.println(&quot;平均体重是&quot; + (totalWeight /...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yuezi</div><div class="author-info-description">积微者速成</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">785</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">91</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuezi2048"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">积微者速成</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89"><span class="toc-text">七、面向对象编程（基础部分）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-text">7.1 类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-text">7.1.1 为什么要类与对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">7.1.2 快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3-%E7%BB%86%E8%8A%82-%E7%B1%BB%E5%88%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-text">7.1.3 细节-类到对象的实例化过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-4-%E7%BB%86%E8%8A%82-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="toc-text">7.1.4 细节-类和对象的内存分配机制*</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">7.2 成员方法*</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">7.2.1 为什么要成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">7.2.2 快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-%E7%BB%86%E8%8A%82-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-text">7.2.3 细节-方法调用时内存分析*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-4-%E7%BB%86%E8%8A%82-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">7.2.4 细节-成员方法的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E6%9B%B4%E6%94%B9-%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7"><span class="toc-text">补充：使用成员方法更改 访问属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6"><span class="toc-text">7.3 基本数据类型传参机制*</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82"><span class="toc-text">7.3.1 基本数据类型传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82"><span class="toc-text">7.3.2 引用数据类型传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-3-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%BA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">7.3.3 成员方法返回值为引用数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E8%BF%94%E5%9B%9EDouble%E7%B1%BB%E8%A7%A3%E5%86%B3%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8"><span class="toc-text">补充：返回Double类解决空指针异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E6%96%B9%E6%B3%95%E7%9A%84%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8"><span class="toc-text">7.4 方法的递归调用**</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%80%92%E5%BD%92"><span class="toc-text">7.4.1 为什么要递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">7.4.2 快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-3-%E7%BB%86%E8%8A%82-%E9%80%92%E5%BD%92%E4%BF%9D%E6%8A%A4%E6%A0%88%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text">7.4.3 细节-递归保护栈的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-4-%E9%80%92%E5%BD%92%E8%A7%A3%E5%86%B3%E8%BE%83%E9%9A%BE%E9%97%AE%E9%A2%98%E5%AE%9E%E4%BE%8B"><span class="toc-text">7.4.4 递归解决较难问题实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%92%8C%E7%8C%B4%E5%AD%90%E5%90%83%E6%A1%83%EF%BC%88%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-text">斐波那契和猴子吃桃（数学问题）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%EF%BC%88%E5%9B%BE%E8%AE%BA-%E5%9B%9E%E6%BA%AF%EF%BC%89"><span class="toc-text">迷宫问题（图论&amp;回溯）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%89%E8%AF%BA%E5%A1%94%EF%BC%88%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-text">汉诺塔（数学问题）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%EF%BC%88%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-text">八皇后问题（数学问题）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD-Overload"><span class="toc-text">7.5 方法重载(Overload)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E8%BD%BD"><span class="toc-text">7.5.1 为什么要重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">7.5.2 快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-3-%E7%BB%86%E8%8A%82-%E6%98%AF%E5%90%A6%E6%9E%84%E6%88%90%E9%87%8D%E8%BD%BD"><span class="toc-text">7.5.3 细节-是否构成重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-text">7.6 可变参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-text">7.6.1 为什么要可变参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">7.6.2 快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-3-%E7%BB%86%E8%8A%82-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">7.6.3 细节-可变参数的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">7.7 作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-1-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">7.7.1 全局变量与局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-2-%E7%BB%86%E8%8A%82-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">7.7.2 细节-作用域的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">7.8 构造方法&#x2F;构造器*</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">7.8.1 为什么要构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">7.8.2 快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-3-%E7%BB%86%E8%8A%82-%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">7.8.3 细节-构造器的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-4-%E5%B8%A6%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-text">7.8.4 带有构造器的对象创建内存分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-9-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">7.9 this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">7.9.1 为什么要this关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-2-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">7.9.2 深入理解this关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-3-%E7%BB%86%E8%8A%82-this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">7.9.3 细节-this关键字的使用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/22/Excalidraw/Drawing%202024-11-01%2015.37.37.excalidraw/" title="Drawing 2024-11-01 15.37.37.excalidraw">Drawing 2024-11-01 15.37.37.excalidraw</a><time datetime="2026-02-22T05:56:41.839Z" title="发表于 2026-02-22 13:56:41">2026-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/22/2.Areas%F0%9F%8C%90/01.project/condefather/yupao/back-end/7.%E4%BC%98%E5%8C%96%E4%B8%BB%E9%A1%B5%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/" title="7.优化主页性能-优化批量导入数据">7.优化主页性能-优化批量导入数据</a><time datetime="2026-02-22T05:56:41.257Z" title="发表于 2026-02-22 13:56:41">2026-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/31/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/5.%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8/" title="5.工具调用">5.工具调用</a><time datetime="2026-01-31T03:54:22.000Z" title="发表于 2026-01-31 11:54:22">2026-01-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/30/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/4.RAG%E8%BF%9B%E9%98%B6/" title="4.RAG进阶">4.RAG进阶</a><time datetime="2026-01-30T13:23:42.000Z" title="发表于 2026-01-30 21:23:42">2026-01-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/3.RAG/" title="3.RAG">3.RAG</a><time datetime="2026-01-27T09:06:56.000Z" title="发表于 2026-01-27 17:06:56">2026-01-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/default.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2026 By yuezi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>