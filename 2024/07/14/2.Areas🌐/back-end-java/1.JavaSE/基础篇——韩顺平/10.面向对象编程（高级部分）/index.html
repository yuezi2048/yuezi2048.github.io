<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>10.面向对象编程（高级部分） | yuezi</title><meta name="author" content="yuezi"><meta name="copyright" content="yuezi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="十、面向对象编程（高级部分）10.1 类变量10.1.1 为什么要类变量（公共访问）假设有一个需求，有一些小孩在堆雪人，后面也会加进来新的小孩，统计现在一共有多少个小孩。 	 传统的方法  我们就在main方法里定义一个count变量 每创建一个对象，就表示加进来了一个小孩，count++ 输出最后的count表示现在一共有多少个小孩在玩 存在以下问题 count变量与类分离开了 进一步说，我们要">
<meta property="og:type" content="article">
<meta property="og:title" content="10.面向对象编程（高级部分）">
<meta property="og:url" content="https://yuezi2048.github.io/2024/07/14/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/10.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86%EF%BC%89/index.html">
<meta property="og:site_name" content="yuezi">
<meta property="og:description" content="十、面向对象编程（高级部分）10.1 类变量10.1.1 为什么要类变量（公共访问）假设有一个需求，有一些小孩在堆雪人，后面也会加进来新的小孩，统计现在一共有多少个小孩。 	 传统的方法  我们就在main方法里定义一个count变量 每创建一个对象，就表示加进来了一个小孩，count++ 输出最后的count表示现在一共有多少个小孩在玩 存在以下问题 count变量与类分离开了 进一步说，我们要">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuezi2048.github.io/img/touxiang.jpg">
<meta property="article:published_time" content="2024-07-14T13:33:50.000Z">
<meta property="article:modified_time" content="2024-07-14T13:33:50.000Z">
<meta property="article:author" content="yuezi">
<meta property="article:tag" content="基础篇——韩顺平">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuezi2048.github.io/img/touxiang.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "10.面向对象编程（高级部分）",
  "url": "https://yuezi2048.github.io/2024/07/14/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/10.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86%EF%BC%89/",
  "image": "https://yuezi2048.github.io/img/touxiang.jpg",
  "datePublished": "2024-07-14T13:33:50.000Z",
  "dateModified": "2024-07-14T13:33:50.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "yuezi",
      "url": "https://yuezi2048.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuezi2048.github.io/2024/07/14/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/10.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?bfb48b678d82bea9f9cc9d59227767e4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"FPH6F2TOJL","apiKey":"06d9ea26c803ba912b4d8e13404ed34d","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '10.面向对象编程（高级部分）',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/backgound.css"><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">603</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yuezi</span></a><a class="nav-page-title" href="/"><span class="site-name">10.面向对象编程（高级部分）</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">10.面向对象编程（高级部分）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-14T13:33:50.000Z" title="发表于 2024-07-14 21:33:50">2024-07-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-14T13:33:50.000Z" title="更新于 2024-07-14 21:33:50">2024-07-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/back-end-java/">back-end-java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/back-end-java/1-JavaSE/">1.JavaSE</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/back-end-java/1-JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/">基础篇——韩顺平</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">16.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>65分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="十、面向对象编程（高级部分）"><a href="#十、面向对象编程（高级部分）" class="headerlink" title="十、面向对象编程（高级部分）"></a>十、面向对象编程（高级部分）</h1><h2 id="10-1-类变量"><a href="#10-1-类变量" class="headerlink" title="10.1 类变量"></a>10.1 类变量</h2><h3 id="10-1-1-为什么要类变量（公共访问）"><a href="#10-1-1-为什么要类变量（公共访问）" class="headerlink" title="10.1.1 为什么要类变量（公共访问）"></a>10.1.1 为什么要类变量（公共访问）</h3><p>假设有一个需求，有一些小孩在堆雪人，后面也会加进来新的小孩，统计现在一共有多少个小孩。</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240706203359948.png" alt="image-20240706203359948">	</p>
<p>传统的方法</p>
<ul>
<li>我们就在main方法里定义一个count变量</li>
<li>每创建一个对象，就表示加进来了一个小孩，count++</li>
<li>输出最后的count表示现在一共有多少个小孩在玩</li>
<li>存在以下问题<ul>
<li><code>count变量</code>与类分离开了</li>
<li>进一步说，我们要访问这个<code>count变量</code>就变得困难了，因为不能通过类来访问（OOP）</li>
<li>能不能把这个属性和Child类绑定在一起，并且可以通过这个类访问呢？答案–可以的，用类(static)变量</li>
</ul>
</li>
</ul>
<p>count 是所有对象共享的 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.static_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	白骨精 join.</span></span><br><span class="line"><span class="comment">    狐狸精 join.</span></span><br><span class="line"><span class="comment">    老鼠精 join.</span></span><br><span class="line"><span class="comment">    共有3个小孩加入了游戏</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildGame</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义一个变量 count 统计有多少个小孩加入了游戏</span></span><br><span class="line">        <span class="comment">// 1. count独立于对象定义，不属于Child对象的属性</span></span><br><span class="line">        <span class="comment">// 2. 访问count变量不方便，因为没有OOP</span></span><br><span class="line">        <span class="comment">// 3. 引出类变量（静态变量）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">child1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;白骨精&quot;</span>);</span><br><span class="line">        child1.join();</span><br><span class="line">        child1.count++;</span><br><span class="line">        <span class="comment">// count ++;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">child2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;狐狸精&quot;</span>);</span><br><span class="line">        child2.join();</span><br><span class="line">        child2.count++;</span><br><span class="line">        <span class="comment">// count ++;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">child3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;老鼠精&quot;</span>);</span><br><span class="line">        child3.join();</span><br><span class="line">        child3.count++;</span><br><span class="line">        <span class="comment">// count ++;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(&quot;共有&quot; + count + &quot;个小孩加入了游戏&quot;);</span></span><br><span class="line">        <span class="comment">// 类变量可通过类名直接访问（更加规范的写法）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;共有&quot;</span> + Child.count + <span class="string">&quot;个小孩加入了游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 定义一个类变量(static)</span></span><br><span class="line">    <span class="comment">// 该变量会被Child类的所有实例共享</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; join.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-1-2-快速入门"><a href="#10-1-2-快速入门" class="headerlink" title="10.1.2 快速入门"></a>10.1.2 快速入门</h3><p><code>类变量，静态变量/静态属性</code>：是该类所有对象共享的变量，任何一个该类对象访问的时候，取到的都是一个地址上的值</p>
<p>定义方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问修饰符 static 数据类型 变量名(推荐)</span></span><br><span class="line"><span class="comment">// static 访问修饰符 数据类型 变量名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p>访问类变量的方法：<code>类名.变量名</code>（满足访问修饰符的前提下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.static_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    hspedu</span></span><br><span class="line"><span class="comment">    hspedu</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitStatic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 类变量随着类加载而访问的，不依赖于创建对象实例</span></span><br><span class="line">        <span class="comment">// 因此可以通过类名.变量名 来访问 类变量【推荐】</span></span><br><span class="line">        System.out.println(A.name);</span><br><span class="line"><span class="comment">//        System.out.println(A.name2);</span></span><br><span class="line">        <span class="comment">// 当然也可以通过对象实例来访问类变量</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        System.out.println(a.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;hspedu&quot;</span>; <span class="comment">// 访问修饰符遵循一般变量的变量访问权限</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> <span class="string">&quot;nonono&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通变量/成员变量/非静态属性/非静态变量/实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-1-3-类变量内存布局"><a href="#10-1-3-类变量内存布局" class="headerlink" title="10.1.3 类变量内存布局"></a>10.1.3 类变量内存布局</h3><p>类变量在哪块内存布局有争议：</p>
<ul>
<li>一部分人认为静态变量存储在堆空间：</li>
<li>另一部分人认为静态变量存储在类加载的方法区内</li>
</ul>
<p>来自<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/59174759/answer/163207831">https://www.zhihu.com/question/59174759/answer/163207831</a></p>
<blockquote>
<p>先说结论：<strong>JDK7以上版本，<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E9%9D%99%E6%80%81%E5%9F%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:163207831%7D">静态域</a>存储于定义类型的Class对象中，Class对象如同堆中其他对象一样，存在于GC堆中</strong>。</p>
</blockquote>
<p>公认的结论我们需要明确：</p>
<ul>
<li>静态变量是该类所有对象共享的</li>
<li>static变量在类加载的时候完成</li>
</ul>
<p>内存布局图示意</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240706204608660.png" alt="image-20240706204608660">	</p>
<h3 id="10-1-4-细节——类变量的加载和访问"><a href="#10-1-4-细节——类变量的加载和访问" class="headerlink" title="10.1.4 细节——类变量的加载和访问"></a>10.1.4 细节——类变量的加载和访问</h3><ul>
<li><code>什么时候要用static</code>：我们要让类的对象共享一个变量时。比如学生类，学生一共要交多少钱</li>
<li><code>类变量和实例变量的区别</code>：类变量是类的所有对象<code>共享的</code>，而实例变量&#x2F;普通属性是每个对象<code>独享的</code></li>
<li>类变量推荐用<code>类名.类变量名访问</code>，虽然对象名也可以访问<ul>
<li><code>类变量</code>在<code>类加载</code>的时候初始化了，<code>不需要创建对象</code>就可以使用</li>
<li>而<code>实例变量</code>不像类变量那样，类加载的时候就已经初始化完成了，因此不能这样访问，<code>必须创建对象</code>访问</li>
</ul>
</li>
<li>类变量的生命周期是从<code>类加载开始</code>，从<code>类消亡结束</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.static_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	200</span></span><br><span class="line"><span class="comment">    北京</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticDetail</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"><span class="comment">//        System.out.println(B.n1);  // 实例变量无法通过类名访问</span></span><br><span class="line">        System.out.println(B.n2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态变量在类加载的时候就创建了，所以即使没有创建对象，也可以通过类名来访问</span></span><br><span class="line">        <span class="comment">// 静态变量声明周期随着类的加载开始，随着类的消亡而销毁</span></span><br><span class="line">        System.out.println(C.address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="string">&quot;北京&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10-2-类方法"><a href="#10-2-类方法" class="headerlink" title="10.2 类方法"></a>10.2 类方法</h2><h3 id="10-2-1-快速入门"><a href="#10-2-1-快速入门" class="headerlink" title="10.2.1 快速入门"></a>10.2.1 快速入门</h3><p>static修饰方法后的方法就是类方法</p>
<p>定义方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问修饰符 static 返回类型 方法名(推荐)</span></span><br><span class="line"><span class="comment">// static 访问修饰符 返回类型 方法名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>



<p>访问类方法的方法：<code>类名.类方法名</code>（满足访问修饰符的前提下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.static_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	总学费：300.0</span></span><br><span class="line"><span class="comment">    10.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建两个学生对象交学费</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        tom.payFee(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//        Student.payFee(100);  // ==&gt; 没问题</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">mary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Mary&quot;</span>);</span><br><span class="line">        mary.payFee(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        Student.showFee();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果我们不希望创建实例，也可以调用一个方法（当作utils使用）</span></span><br><span class="line">        <span class="comment">// 此时，可以将方法当作静态方法比较合适，他和我们的对象独立开来，提高开发效率</span></span><br><span class="line">        <span class="comment">// 比如Math，打印数组，冒泡排序等</span></span><br><span class="line">        System.out.println(MyTools.calSum(<span class="number">4.0</span>, <span class="number">6.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static经典应用场景：工具类 可以将方法作为static 方便调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTools</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">calSum</span><span class="params">(<span class="type">double</span> n1, <span class="type">double</span> n2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n1 + n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 普通成员：学生姓名</span></span><br><span class="line">    <span class="comment">// 定义静态变量，来累计学生们的学费</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">fee</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 说明：当方法使用static修饰后，该方法为类方法（静态方法）</span></span><br><span class="line">    <span class="comment">// 2. 静态方法可以访问静态属性/变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">payFee</span><span class="params">(<span class="type">double</span> fee)</span> &#123;</span><br><span class="line">        Student.fee += fee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showFee</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;总学费：&quot;</span> + Student.fee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="10-2-2-类方法两个经典使用场景"><a href="#10-2-2-类方法两个经典使用场景" class="headerlink" title="10.2.2 类方法两个经典使用场景"></a>10.2.2 类方法两个经典使用场景</h3><ul>
<li><code>工具类</code>–不希望创建实例直接调用</li>
<li><code>操控、访问各个对象共享的类变量</code></li>
</ul>
<h3 id="10-2-2-细节——类方法的加载和调用"><a href="#10-2-2-细节——类方法的加载和调用" class="headerlink" title="10.2.2 细节——类方法的加载和调用"></a>10.2.2 细节——类方法的加载和调用</h3><ul>
<li><code>类方法和普通方法都是随着类的加载而加载</code>，存储在方法区<ul>
<li>类方法没有<code>this</code>参数</li>
<li>普通方法隐含<code>this super</code>等 与OOP相关的参数</li>
</ul>
</li>
<li>类方法可以通过类名调用，也可以通过对象名调用<ul>
<li>普通方法不行，需要通过对象名调用</li>
</ul>
</li>
<li><strong><code>静态方法只能访问静态成员，非静态方法可以访问静态成员和非静态成员</code></strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.static_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticMethodDetail</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        D.hi(); <span class="comment">// ok</span></span><br><span class="line">        <span class="comment">// 非静态方法不能通过类名调用访问</span></span><br><span class="line"><span class="comment">//        D.say(); // nonono</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 类方法不允许与对象相关的关键字</span></span><br><span class="line">        <span class="comment">// 例如this super 而普通方法（成员方法可以）</span></span><br><span class="line"><span class="comment">//        this.n1;  // nonono</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法只能访问静态成员，类方法只能访问类成员（访问权限也要遵守）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非静态成员</span></span><br><span class="line"><span class="comment">//        System.out.println(this.n2); // nonono</span></span><br><span class="line"><span class="comment">//        System.out.println(n1);  // nonono</span></span><br><span class="line"><span class="comment">//        say(); // nonono</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态成员</span></span><br><span class="line">        System.out.println(n2);</span><br><span class="line">        System.out.println(D.n2);</span><br><span class="line">        hi(); <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 普通方法既能访问普通成员，也能访问静态成员</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非静态成员</span></span><br><span class="line">        System.out.println(n1);</span><br><span class="line">        hi();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态成员</span></span><br><span class="line">        System.out.println(n2);</span><br><span class="line">        System.out.println(D.n2);</span><br><span class="line">        say();</span><br><span class="line">        test01();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10-3-main类方法结构分析"><a href="#10-3-main类方法结构分析" class="headerlink" title="10.3 main类方法结构分析"></a>10.3 main类方法结构分析</h2><ul>
<li>public：JVM机直接调用main方法，因此必须是public</li>
<li>static：main方法不需要创建对象，因此必须是static</li>
<li>void：main方法不必返回值</li>
<li>String[] args：执行main方法的String类型的数组参数</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240706211258161.png" alt="image-20240706211258161">	</p>
<ul>
<li>main方法中，因为是静态方法（类方法），我们可以调用main方法所在类的静态成员</li>
<li>但是不能访问非静态成员，必须要通过创建对象来访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.main_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    hspedu</span></span><br><span class="line"><span class="comment">    hi()</span></span><br><span class="line"><span class="comment">    hspedu2</span></span><br><span class="line"><span class="comment">    hi2()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main01</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name01</span> <span class="operator">=</span> <span class="string">&quot;hspedu&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name02</span> <span class="operator">=</span> <span class="string">&quot;hspedu2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法可以访问静态成员</span></span><br><span class="line">        System.out.println(name01);</span><br><span class="line">        hi();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态方法不能访问非静态成员</span></span><br><span class="line"><span class="comment">//        System.out.println(name02);</span></span><br><span class="line"><span class="comment">//        hi2();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果要用非静态成员，需要创建类的实例调用</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Main01</span>().name02);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Main01</span>().hi2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>传递args参数</strong></p>
<p>运行那里编辑一下即可，或者java命令行后面跟上几个字符串参数</p>
<img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240706211723294.png" alt="image-20240706211723294" style="zoom: 67%;" />	

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.main_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;args[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="10-4-代码块"><a href="#10-4-代码块" class="headerlink" title="10.4 代码块"></a>10.4 代码块</h2><h3 id="10-4-1-为什么要代码块（构造器补充）"><a href="#10-4-1-为什么要代码块（构造器补充）" class="headerlink" title="10.4.1 为什么要代码块（构造器补充）"></a>10.4.1 为什么要代码块（构造器补充）</h3><p>针对于普通代码块：</p>
<ul>
<li>理解：是对<code>类构造器的补充机制</code>，做一些初始化的工作</li>
<li>场景：多个构造器有<code>重复的语句</code>，那么可以提取到代码块中，提高代码重用性</li>
</ul>
<p>而后续我们还会说明静态代码块：那么提到static，就肯定要和类加载绑定在一起的，我的理解 应该算是类变量类方法的补充机制吧</p>
<h3 id="10-4-2-快速入门"><a href="#10-4-2-快速入门" class="headerlink" title="10.4.2 快速入门"></a>10.4.2 快速入门</h3><p><code>代码块</code>也叫初始化块，属于类中的成员，类似于方法，将逻辑语句封装到方法体内，用{}包起来。</p>
<p>基本语法</p>
<ul>
<li>修饰符可选，只能写static<ul>
<li>分成两部分代码块，有static的是<code>静态代码块</code>，没有static修饰的是<code>非静态代码块/普通代码块</code></li>
</ul>
</li>
<li>代码部分同普通语句</li>
<li>结尾可以有分号，也可以省略</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">static</span>) &#123;</span><br><span class="line">	<span class="comment">// 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>比如说要实现电影院的播放电影，每new一个电影都要播放一些前置操作（打开荧幕 插播广告等），那么可以用到这个普通代码块的技术。</p>
<p>具体实现如下</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240706224628867.png" alt="image-20240706224628867">	</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.codeblock_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    电影屏幕打开...</span></span><br><span class="line"><span class="comment">    广告开始...</span></span><br><span class="line"><span class="comment">    电影正片开始...</span></span><br><span class="line"><span class="comment">    Movie(name) Constructor</span></span><br><span class="line"><span class="comment">    ===================</span></span><br><span class="line"><span class="comment">    电影屏幕打开...</span></span><br><span class="line"><span class="comment">    广告开始...</span></span><br><span class="line"><span class="comment">    电影正片开始...</span></span><br><span class="line"><span class="comment">    Movie(name, price) Constructor</span></span><br><span class="line"><span class="comment">    ===================</span></span><br><span class="line"><span class="comment">    电影屏幕打开...</span></span><br><span class="line"><span class="comment">    广告开始...</span></span><br><span class="line"><span class="comment">    电影正片开始...</span></span><br><span class="line"><span class="comment">    Movie(name, price, director) Constructor</span></span><br><span class="line"><span class="comment">    ===================</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlock01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Movie</span> <span class="variable">movie01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;你好，李焕英&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">        <span class="type">Movie</span> <span class="variable">movie02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;你的名字&quot;</span>, <span class="number">200</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">        <span class="type">Movie</span> <span class="variable">movie03</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;蜘蛛侠&quot;</span>, <span class="number">100</span>, <span class="string">&quot;作者&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> String director;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3个构造器 重载</span></span><br><span class="line">    <span class="comment">// 1. 3个构造器有相同的语句，代码会看起来冗余</span></span><br><span class="line">    <span class="comment">// 2. 此时可以把相同的语句放入代码块中即可。</span></span><br><span class="line">    <span class="comment">// 3. 当我们不管调用哪个构造器创建对象，都会先调用代码块的内容</span></span><br><span class="line">    <span class="comment">// 4. 代码块的内容优先于构造器</span></span><br><span class="line">    <span class="comment">// 理解：代码块是构造器的补充机制，便于对多个构造器重复语句进行重用</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电影屏幕打开...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;广告开始...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;电影正片开始...&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;电影屏幕打开...&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;广告开始...&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;电影正片开始...&quot;);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Movie(name) Constructor&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;电影屏幕打开...&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;广告开始...&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;电影正片开始...&quot;);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Movie(name, price) Constructor&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name, <span class="type">double</span> price, String director)</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;电影屏幕打开...&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;广告开始...&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;电影正片开始...&quot;);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Movie(name, price, director) Constructor&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.director = director;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-4-3-细节1——静态和普通代码块的加载"><a href="#10-4-3-细节1——静态和普通代码块的加载" class="headerlink" title="10.4.3 细节1——静态和普通代码块的加载"></a>10.4.3 细节1——静态和普通代码块的加载</h3><ul>
<li>static 代码块 是<code>对类进行 初始化</code>，随着类的加载而执行，并且<code>只会执行一次</code><ul>
<li>而普通代码块是<code>每创建一次对象 才执行一次</code>（见电影院的案例）</li>
</ul>
</li>
<li><code>静态代码块</code>执行需要类加载，而类什么时候加载？（重要！！<code>记住以下三种情况</code>）<ul>
<li><code>创建对象实例</code>时(new)</li>
<li>创建<code>子类对象实例</code>，父类也会被加载</li>
<li>使用类的<code>静态成员</code>时（静态属性、静态方法）</li>
</ul>
</li>
<li><code>普通代码块</code> 创建对象实例的时候，才会被隐式地调用<ul>
<li>每创建一次就执行一次</li>
<li>如果使用类的静态成员，那么不会执行</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.codeblock_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    执行BB的静态代码块1...</span></span><br><span class="line"><span class="comment">    执行AA的静态代码块1...</span></span><br><span class="line"><span class="comment">    执行Animal的静态代码块1...</span></span><br><span class="line"><span class="comment">    执行Cat的静态代码块1...</span></span><br><span class="line"><span class="comment">    100</span></span><br><span class="line"><span class="comment">    执行DD的静态代码块1...</span></span><br><span class="line"><span class="comment">    888</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlockDetail01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 类加载的时候调用一次静态代码块 且 只加载一次</span></span><br><span class="line">        <span class="comment">// 类加载的三种情况</span></span><br><span class="line">        <span class="comment">// 1. new AA对象</span></span><br><span class="line"><span class="comment">//        AA aa = new AA();</span></span><br><span class="line">        <span class="comment">// 2，new 一个子类，其父类会被加载,且父类先加载</span></span><br><span class="line">        <span class="type">BB</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        <span class="comment">// 3. 调用了类的静态成员,思考：（1）父类会被加载吗？为什么？（2）静态代码块会被执行两次吗？</span></span><br><span class="line">        <span class="comment">// 反思：类加载的时候 会根据继承的查找关系 先加载最顶端的父类。常识，先有父亲才有儿子...</span></span><br><span class="line">        System.out.println(Cat.n1);</span><br><span class="line">        Cat.hi();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通代码块，创建一次对象就会隐式地被调用一次，见快速入门案例</span></span><br><span class="line">        <span class="comment">// 而如果使用了类的静态成员后，普通代码块并不会执行</span></span><br><span class="line">        <span class="comment">// 请区分出 类加载和创建对象。理解：普通代码块是构造器的补充，因此只跟创建对象有关</span></span><br><span class="line">        System.out.println(DD.n1);  <span class="comment">// 并没有执行DD的普通代码块1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DD</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">888</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类加载时执行，只有一次【明确类加载的3种情况】</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行DD的静态代码块1...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建对象时执行，创建一次调用一次</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行DD的普通代码块1...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行Animal的静态代码块1...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行Cat的静态代码块1...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行BB的静态代码块1...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">extends</span> <span class="title class_">BB</span>&#123;</span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行AA的静态代码块1...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-4-4-细节2——创建对象一个类调用顺序"><a href="#10-4-4-细节2——创建对象一个类调用顺序" class="headerlink" title="10.4.4 细节2——创建对象一个类调用顺序"></a>10.4.4 细节2——创建对象一个类调用顺序</h3><ul>
<li>由于创建了一个对象，进行类加载，首先就要对<code>静态代码块和类变量</code>进行初始化（这两个优先级一样，谁在前谁就先初始化）</li>
<li>其次再调用<code>普通代码块和普通成员</code>进行初始化的操作（同理，谁在前谁先初始化）</li>
<li>最后调用<code>构造方法</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.codeblock_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    A 静态代码块01...</span></span><br><span class="line"><span class="comment">    getN1()</span></span><br><span class="line"><span class="comment">    getN2()</span></span><br><span class="line"><span class="comment">    A 普通代码块01...</span></span><br><span class="line"><span class="comment">    A() constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlockDetail02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 【重点 难点】</span></span><br><span class="line">        <span class="comment">// 1. 静态属性初始化和静态代码块优先级相同，按照定义顺序执行，多个同理</span></span><br><span class="line">        <span class="comment">// 2. 普通属性初始化和普通代码块优先级相同，按照定义顺序执行，多个同理</span></span><br><span class="line">        <span class="comment">// 3. 最后调用构造器</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(); <span class="comment">//  静态代码块 --&gt; getN1 --&gt; getN2 --&gt; 普通代码块 --&gt; A()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进一步思考【面试高频】：若加入继承关系后又如何？见CodeBlock04.java</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// 普通属性初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> getN2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A 普通代码块01...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A 静态代码块01...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态属性初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> getN1();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getN1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getN1()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getN2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getN2()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A() constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="10-4-5-细节3——创建对象继承类调用顺序"><a href="#10-4-5-细节3——创建对象继承类调用顺序" class="headerlink" title="10.4.5 细节3——创建对象继承类调用顺序"></a>10.4.5 细节3——创建对象继承类调用顺序</h3><p>首先我们要明确，类的构造方法里面其实除了super()方法，后面还有一句执行普通代码块的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// super()</span></span><br><span class="line">    <span class="comment">// 加载普通代码块 普通成员</span></span><br><span class="line">    System.out.println(<span class="string">&quot;OK);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.codeblock_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    AAA 普通代码块</span></span><br><span class="line"><span class="comment">    AAA() constructor</span></span><br><span class="line"><span class="comment">    BBB 普通代码块</span></span><br><span class="line"><span class="comment">    BBB() constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlockDetail03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BBB</span>(); <span class="comment">// AAA代码块 --&gt; AAA 构造器 ---&gt; BBB代码块 ---&gt; BBB 构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AAA</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAA 普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AAA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// super() ==&gt; Object()</span></span><br><span class="line">        <span class="comment">// 普通代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AAA() constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BBB</span> <span class="keyword">extends</span> <span class="title class_">AAA</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BBB 普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BBB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// super() ==&gt; AAA()</span></span><br><span class="line">        <span class="comment">// 普通代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;BBB() constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来在这个基础上加入静态成员和静态代码块来进阶分析一下。</p>
<ol>
<li>父类的静态代码块和静态属性</li>
<li>子类的静态代码块和静态属性</li>
<li>父类的普通代码块和普通属性</li>
<li>父类的构造方法</li>
<li>子类的普通代码块和普通属性</li>
<li>子类的构造方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.codeblock_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    ======测试代码块继承关系执行过程======</span></span><br><span class="line"><span class="comment">    getN3()</span></span><br><span class="line"><span class="comment">    BBBBB 静态代码块</span></span><br><span class="line"><span class="comment">    getN1()</span></span><br><span class="line"><span class="comment">    AAAAA 静态代码块</span></span><br><span class="line"><span class="comment">    getN4()</span></span><br><span class="line"><span class="comment">    BBBBB 普通代码块</span></span><br><span class="line"><span class="comment">    BBBBB constructor</span></span><br><span class="line"><span class="comment">    getN2()</span></span><br><span class="line"><span class="comment">    AAAAA 普通代码块</span></span><br><span class="line"><span class="comment">    AAAAA constructor</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ======测试代码块访问权限======</span></span><br><span class="line"><span class="comment">    CCCCCC 静态代码块</span></span><br><span class="line"><span class="comment">    100</span></span><br><span class="line"><span class="comment">    static hi</span></span><br><span class="line"><span class="comment">    CCCCCC 普通代码块</span></span><br><span class="line"><span class="comment">    100</span></span><br><span class="line"><span class="comment">    200</span></span><br><span class="line"><span class="comment">    static hi</span></span><br><span class="line"><span class="comment">    ordinary hi</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlockDetail04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n======测试代码块继承关系执行过程======&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AAAAA</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态代码块只能访问静态的成员，普通代码块同普通的方法，什么都可以</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n======测试代码块访问权限======&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CCCCC</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCCCC</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CCCCCC 静态代码块&quot;</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"><span class="comment">//        System.out.println(n2);</span></span><br><span class="line">        hi();</span><br><span class="line"><span class="comment">//        hi2();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CCCCCC 普通代码块&quot;</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">        hi();</span><br><span class="line">        hi2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">hi2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ordinary hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BBBBB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> getN3(); <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n4</span> <span class="operator">=</span> getN4(); <span class="comment">// (5)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BBBBB 静态代码块&quot;</span>); <span class="comment">// (2)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BBBBB 普通代码块&quot;</span>); <span class="comment">// (6)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BBBBB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BBBBB constructor&quot;</span>); <span class="comment">// (7)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getN3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getN3()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getN4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getN4()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">400</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AAAAA</span> <span class="keyword">extends</span> <span class="title class_">BBBBB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> getN1(); <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> getN2(); <span class="comment">// (8)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAAAA 静态代码块&quot;</span>); <span class="comment">// (4)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAAAA 普通代码块&quot;</span>); <span class="comment">//(9)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AAAAA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAAAA constructor&quot;</span>); <span class="comment">//(10)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getN1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getN1()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getN2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getN2()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10-5-静态应用——单例设计模式"><a href="#10-5-静态应用——单例设计模式" class="headerlink" title="10.5 静态应用——单例设计模式"></a>10.5 静态应用——单例设计模式</h2><h3 id="10-5-1-为什么要有设计模式（玄机）"><a href="#10-5-1-为什么要有设计模式（玄机）" class="headerlink" title="10.5.1 为什么要有设计模式（玄机）"></a>10.5.1 为什么要有设计模式（玄机）</h3><ul>
<li>比如<code>单例设计模式 </code>就是让 静态方法和静态属性有了用武之地<ul>
<li>单例设计模式：保证整个软件系统中，对某个类只能有一个对象实例，并且只能有一个获取对象实例的方法。</li>
<li>分为饿汉式和懒汉式两种模式</li>
</ul>
</li>
<li>设计模式是前人实践下来优化后的结构，就像是一个棋谱布局，免去了我们自己探索的过程，里面会有很多玄机之处</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240706235022439.png" alt="image-20240706235022439">	</p>
<h3 id="10-5-2-饿汉式"><a href="#10-5-2-饿汉式" class="headerlink" title="10.5.2 饿汉式"></a>10.5.2 饿汉式</h3><p>操作步骤</p>
<ul>
<li>将构造器私有化</li>
<li>类内部创建对象</li>
<li>向外暴露静态公共方法获取该对象</li>
</ul>
<p>值得注意的点</p>
<ul>
<li>构建单例模式的类时<ul>
<li>类内部创建对象需要定义static便于static方法获取</li>
<li>构造器设为私有，不能让用户新建一个npy</li>
</ul>
</li>
<li>调用该类的时候<ul>
<li>每次获取的对象都是同一个</li>
</ul>
</li>
<li>其他有意思的点<ul>
<li>会存在创建了类但是没有用的情况，因此可能会造成资源的浪费，这点可以通过<code>懒汉式</code>优化，但会有<code>线程安全</code>的问题</li>
<li><code>java.lang.Runtine</code>就是采用了<code>饿汉式</code>的单例模式</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.single_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon01</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   		GirlFriend constructor</span></span><br><span class="line"><span class="comment">        getN1()</span></span><br><span class="line"><span class="comment">        100</span></span><br><span class="line"><span class="comment">        =======类加载完成=======</span></span><br><span class="line"><span class="comment">        com.hspedu.single_.GirlFriend@1b6d3586&#123;name:小红&#125;</span></span><br><span class="line"><span class="comment">        com.hspedu.single_.GirlFriend@1b6d3586&#123;name:小红&#125;</span></span><br><span class="line"><span class="comment">        true</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 此定义方法不是单例模式</span></span><br><span class="line"><span class="comment">//        GirlFriend xh = new GirlFriend(&quot;小红&quot;);</span></span><br><span class="line"><span class="comment">//        GirlFriend xb = new GirlFriend(&quot;小白&quot;);</span></span><br><span class="line">        <span class="comment">// 饿汉式由来：通过该语句，得出即使我们还没有用这个小红对象，却已经创建好了对象，饿汉如此迫不及待地想要npy</span></span><br><span class="line">        System.out.println(GirlFriend.n1);  <span class="comment">// 此时已经创建好了小红对象</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=======类加载完成=======&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">gf1</span> <span class="operator">=</span> GirlFriend.getInstance();</span><br><span class="line">        System.out.println(gf1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态属性初始化，我们因为只在类加载的时候执行一次，因此我们的女朋友永远只能是小红同学</span></span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">gf2</span> <span class="operator">=</span> GirlFriend.getInstance();</span><br><span class="line">        System.out.println(gf2);</span><br><span class="line"></span><br><span class="line">        System.out.println(gf1 == gf2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// java.lang.Runtime就是采用了饿汉式的单例模式，见源码</span></span><br><span class="line">        Runtime.getRuntime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供一个类GirlFriend，完成【单例模式-饿汉式】的设计</span></span><br><span class="line"><span class="comment">// 单例模式要求我们只能new一个女朋友，不能像渣男一样new很多个</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 需要对该对象加上static，以便类方法来获取类变量</span></span><br><span class="line">    <span class="comment">// 这种对象往往是重量级的对象，但存在一个问题：我创建了但是没有用，造成资源浪费 ==&gt; 引出单例模式 懒汉式，使用了才创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GirlFriend</span> <span class="variable">gf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> getN1();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证只能创建一个GirlFriend对象【单例模式-饿汉式】</span></span><br><span class="line">    <span class="comment">// (1)将构造器私有化</span></span><br><span class="line">    <span class="comment">// (2)内部创建一个【static】对象</span></span><br><span class="line">    <span class="comment">// (3)提供一个公共的静态方法来获取该对象，为了方法种获取到对象，对象需要设置成静态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GirlFriend</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;GirlFriend constructor&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getN1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getN1()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString() + <span class="string">&quot;&#123;name:&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-5-3-懒汉式"><a href="#10-5-3-懒汉式" class="headerlink" title="10.5.3 懒汉式"></a>10.5.3 懒汉式</h3><ul>
<li>可以发现变化不大，只是定义对象的时候，不直接new了，而是写在了getInstance()的静态方法里面了</li>
<li>这样的好处是不用的时候不会加载类，减少资源浪费<ul>
<li>但是衍生出了一个<code>线程安全</code>的问题</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.single_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon02</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	999</span></span><br><span class="line"><span class="comment">        =======类加载完成=======</span></span><br><span class="line"><span class="comment">        Cat constructor</span></span><br><span class="line"><span class="comment">        com.hspedu.single_.Cat@1b6d3586[name=阿黄]</span></span><br><span class="line"><span class="comment">        com.hspedu.single_.Cat@1b6d3586[name=阿黄]</span></span><br><span class="line"><span class="comment">        true</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Cat.n1);  <span class="comment">// 此时完成了类加载，没有创建对象 因此没有构造函数语句</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=======类加载完成=======&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> Cat.getInstance(); <span class="comment">// 此时完成对象的创建，符合懒汉式特征</span></span><br><span class="line">        System.out.println(cat1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat2</span> <span class="operator">=</span> Cat.getInstance();</span><br><span class="line">        System.out.println(cat2);</span><br><span class="line"></span><br><span class="line">        System.out.println(cat1 == cat2); <span class="comment">// 的确没有创建第二个对象，保证了单例模式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希望在程序运行过程中只能创建一个Cat对象，但是需要用到Cat后才创建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Cat cat;  <span class="comment">// 这里不直接new</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1)仍然将构造器私有化</span></span><br><span class="line">    <span class="comment">// (2)定义静态属性对象</span></span><br><span class="line">    <span class="comment">// (3)提供public 的static方法 返回cat对象</span></span><br><span class="line">    <span class="comment">// 懒汉式：只有当用户使用getInstance方法后才返回Cat对象，后面调用会返回上次的对象，保证单例</span></span><br><span class="line">    <span class="comment">// 评价：尽管少了资源浪费的风险，但是会有线程安全的问题（假设3个线程同时进入getInstance方法并且同时判断呢？）</span></span><br><span class="line">    <span class="comment">// 后续讲线程的时候解决，单例模式一共有8种方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat constructor&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果猫没有创建对象，就创建</span></span><br><span class="line">        <span class="keyword">if</span> (cat == <span class="literal">null</span>) &#123;</span><br><span class="line">            cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;阿黄&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString() + <span class="string">&quot;[name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-5-4-饿汉式和懒汉式对比"><a href="#10-5-4-饿汉式和懒汉式对比" class="headerlink" title="10.5.4 饿汉式和懒汉式对比"></a>10.5.4 饿汉式和懒汉式对比</h3><ul>
<li>根本区别就是创建那一个单例的时机不一样<ul>
<li>饿汉式是只要类加载了就创建</li>
<li>懒汉式是等到调用者调用对象以后才创建</li>
</ul>
</li>
<li>优劣势不同<ul>
<li>饿汉式可能会有资源浪费，但不会有线程安全问题（后面学习线程会优化完善）</li>
<li>懒汉式可能会有线程安全，但避免了资源浪费问题</li>
</ul>
</li>
</ul>
<h2 id="10-6-final关键字"><a href="#10-6-final关键字" class="headerlink" title="10.6 final关键字"></a>10.6 final关键字</h2><h3 id="10-6-1-为什么要final关键字（类成员需求）"><a href="#10-6-1-为什么要final关键字（类成员需求）" class="headerlink" title="10.6.1 为什么要final关键字（类成员需求）"></a>10.6.1 为什么要final关键字（类成员需求）</h3><p>某些情况下，我们有以下需求</p>
<ul>
<li>不希望这个<code>类</code>被其他类继承</li>
<li>不希望类的某个<code>属性</code>被修改</li>
<li>不希望类的<code>方法</code>被其他类重写</li>
<li>不希望<code>局部变量</code>被修改</li>
</ul>
<h3 id="10-6-2-快速入门"><a href="#10-6-2-快速入门" class="headerlink" title="10.6.2 快速入门"></a>10.6.2 快速入门</h3><p>final表示最终的，可以修饰<code>类、属性、方法、局部变量</code></p>
<ul>
<li>public void hi(final int x)是可以的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.final_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Final01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1)如果要求A类不能被其他类继承，可以用final来修饰类，确保不被别人继承重写</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class B extends A &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="comment">// (2)如果希望某个属性不被修改，可以用final修饰变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">TAX_RATE</span> <span class="operator">=</span> <span class="number">0.08</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setTAX_RATE(double TAX_RATE) &#123;</span></span><br><span class="line"><span class="comment">//        this.TAX_RATE = TAX_RATE;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (3)如果不允许子类重写这个方法，可以用final来修饰方法</span></span><br><span class="line">    <span class="comment">// 比如爷爷定下来了遗产的分配，你就不能改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// (4)如果不希望局部变量被修改，可以用final来修饰局部变量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">double</span> <span class="variable">NUM</span> <span class="operator">=</span> <span class="number">0.01</span>;</span><br><span class="line"><span class="comment">//        NUM = 0.9;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;NUM=&quot;</span> + NUM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void hi() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;重写C类的hi()方法&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-6-3-细节——final的赋值"><a href="#10-6-3-细节——final的赋值" class="headerlink" title="10.6.3 细节——final的赋值"></a>10.6.3 细节——final的赋值</h3><ul>
<li>final修饰的属性就是<code>常量</code>，命名规范XX_XX_XX（TAX_RATE）</li>
<li>final修饰时定义的初值<code>必须被赋初值</code>，后续不能被修改，赋值有三种方法<ul>
<li>定义的时候直接赋值</li>
<li><code>普通代码块</code>赋值</li>
<li>构造器赋值</li>
</ul>
</li>
<li><code>static final</code>的静态常量初始化只能在<code>静态代码块</code>和定义的时候赋值，不能在构造器赋值</li>
<li><code>final类</code>虽然不能被继承，但还是<code>可以创建实例</code>的</li>
<li>如果类不是final类，包含<code>final方法</code>，该方法虽然不能被重写，但是还是<code>可以被继承</code>的（动态绑定机制调用）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.final_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	DD.cal()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDetail01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CC</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">EE</span>().cal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        final定义属性的时候，必须初始化，三种方法初始化</span></span><br><span class="line"><span class="comment">        1. 定义的时候直接赋值</span></span><br><span class="line"><span class="comment">        2. 代码块</span></span><br><span class="line"><span class="comment">        3. 构造函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">TAX_RATE</span> <span class="operator">=</span> <span class="number">0.08</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> TAX_RATE2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> TAX_RATE3;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        TAX_RATE2 = <span class="number">0.02</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AA</span><span class="params">()</span> &#123;</span><br><span class="line">        TAX_RATE3 = <span class="number">0.03</span>;  <span class="comment">// 在这里赋值final类型的属性也是可以的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        final定义属性的时候，如果属性是static类型的，那么只能直接赋值或者静态代码块</span></span><br><span class="line"><span class="comment">        因为static是在类加载的时候给值，所以不能在创建对象时再赋值，因此不能在普通代码块或者构造函数赋值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">TAX_RATE</span> <span class="operator">=</span> <span class="number">0.1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> TAX_RATE2;</span><br><span class="line"><span class="comment">//    public static final double TAX_RATE3;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        TAX_RATE2 = <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        TAX_RATE3 = 0.3;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    public BB() &#123;</span></span><br><span class="line"><span class="comment">//        TAX_RATE3 = 0.03;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// final修饰的类，不能被继承但是可以实例化的</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CC</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// final修饰的方法，不能被重写，但是仍然符合继承的规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DD</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">cal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DD.cal()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EE</span> <span class="keyword">extends</span> <span class="title class_">DD</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>如果类已经被修饰为final，一般方法就没有必要修饰为final了</li>
<li>final不能修饰构造方法</li>
<li>final和static搭配使用效率更高，因为底层优化后使用该变量<code>不会导致类加载</code>（回忆一下类加载的三种情况）</li>
<li>包装类（Integer Double Float Boolean） String都是包装类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.final_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	20000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDetail02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(BBB.NUM2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包装类String Integer 等都是final类，不能被继承</span></span><br><span class="line">        String str;</span><br><span class="line">        Double double1;</span><br><span class="line">        Integer integer1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BBB</span> &#123;</span><br><span class="line"><span class="comment">//    public static int NUM1 = 100000;</span></span><br><span class="line">    <span class="comment">// static和final配合使用，调用的时候不会造成类加载，底层专门对此作了优化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM2</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BBB static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果AAA被final修饰了，里面的方法就没有必要用final修饰了</span></span><br><span class="line"><span class="comment">// 因为别人没机会继承更没办法重写了</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AAA</span> &#123;</span><br><span class="line">    <span class="comment">// final 只能修饰类、属性、方法、局部变量，构造器不行</span></span><br><span class="line">    AAA() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10-7-抽象类"><a href="#10-7-抽象类" class="headerlink" title="10.7 抽象类"></a>10.7 抽象类</h2><h3 id="10-7-1-为什么要抽象类（不确定的给子类）"><a href="#10-7-1-为什么要抽象类（不确定的给子类）" class="headerlink" title="10.7.1 为什么要抽象类（不确定的给子类）"></a>10.7.1 为什么要抽象类（不确定的给子类）</h3><ul>
<li><p>当父类的方法实现不确定怎么实现的时候，可以把具体的实现甩锅给子类来做</p>
</li>
<li><p>而父类只需要声明抽象类，然后定义不确定的抽象方法就可以了</p>
</li>
</ul>
<h3 id="10-7-2-快速入门"><a href="#10-7-2-快速入门" class="headerlink" title="10.7.2 快速入门"></a>10.7.2 快速入门</h3><ul>
<li>父类的方法不确定时，使用<code>abstract</code>关键字修饰方法 &#x3D;&#x3D;》 抽象方法<ul>
<li>抽象方法由abstract修饰，<strong>没有方法体</strong></li>
</ul>
</li>
<li>此时Animal类为抽象类，需要用<code>abstract</code>修饰类 &#x3D;&#x3D;》 抽象类<ul>
<li>抽象类的价值：专注构建<code>设计</code>模式（后面我们会讲到<code>模板设计模式</code>），与抽象类的实现影响独立开</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.abstract_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Abstract01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于父类方法不确定性，所以在这里实现没有什么意义</span></span><br><span class="line">    <span class="comment">// 考虑将该方法设置为抽象方法（没有实现的方法）</span></span><br><span class="line">    <span class="comment">// 没有实现的方法就是没有方法体</span></span><br><span class="line">    <span class="comment">// 当一个类有抽象方法时，需要将该类设置为abstract类</span></span><br><span class="line">    <span class="comment">// 一般来说，抽象类会被继承，由其子类来实现抽象方法</span></span><br><span class="line"><span class="comment">//    public void eat() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;动物的吃方法，暂时不知道怎么吃...&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="10-7-3-细节1——抽象类的抽象性"><a href="#10-7-3-细节1——抽象类的抽象性" class="headerlink" title="10.7.3 细节1——抽象类的抽象性"></a>10.7.3 细节1——抽象类的抽象性</h3><ul>
<li>抽象类不能被<code>实例化</code></li>
<li>抽象类不一定要<code>abstract方法</code>，但一旦声明了abstract方法必须声明为抽象类</li>
<li>abstract关键字只能修饰<code>类和方法</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.abstract_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDetail01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 抽象类不能被实例化</span></span><br><span class="line"><span class="comment">//        new A();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类可以没有抽象方法</span></span><br><span class="line"><span class="comment">// 而且还可以有实现的方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 理解：一旦有abstract方法，该类一定是抽象类，反过来未必</span></span><br><span class="line"><span class="comment">//class B &#123;</span></span><br><span class="line"><span class="comment">//    abstract void hi();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象只能修饰类和方法，属性不能修饰</span></span><br><span class="line"><span class="comment">//    abstract public int n1 = 1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-7-4-细节2——抽象类的成员和子类实现"><a href="#10-7-4-细节2——抽象类的成员和子类实现" class="headerlink" title="10.7.4 细节2——抽象类的成员和子类实现"></a>10.7.4 细节2——抽象类的成员和子类实现</h3><ul>
<li><code>抽象类</code>本质上还是一个<code>类</code>，只是有未实现的方法罢了，它可以有其他成员<ul>
<li>可以包含 非抽象方法、构造器、静态&#x2F;非静态属性、代码块、内部类（后面会讲到类的五大组成部分）</li>
</ul>
</li>
<li>抽象方法不能有方法体</li>
<li>一个类声明为抽象类，一旦有子类继承了，就<code>必须重写所有未实现的抽象方法</code>，除非子类也是抽象类</li>
<li>抽象方法不能被<code>private、final、static</code>修饰，因为他需要子类继承来重写这些方法，被这些关键字修饰了就不能重写了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.abstract_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    ok</span></span><br><span class="line"><span class="comment">    hello</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDetail02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        D.ok();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">E</span>().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法不允许用private final 和 static修饰，因为和重写相违背</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">H</span> &#123;</span><br><span class="line">    <span class="comment">// private无法被子类访问</span></span><br><span class="line"><span class="comment">//    private abstract void hi();</span></span><br><span class="line">    <span class="comment">// final直接表示不能重写</span></span><br><span class="line"><span class="comment">//    abstract final void hi();</span></span><br><span class="line">    <span class="comment">// static是类加载行为，与重写过程中的实例无关</span></span><br><span class="line"><span class="comment">//    abstract static void hi();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一个类继承了抽象类，该类必须实现抽象方法，除非自己声明为抽象方法</span></span><br><span class="line"><span class="comment">// 从语法的角度，加了大括号就表示实现了，写了什么并不关心</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">extends</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">F</span> <span class="keyword">extends</span> <span class="title class_">D</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的本质还是类，因此可以有类的各种成员</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;hsp&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ok</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="10-8-抽象类应用——模板设计模式"><a href="#10-8-抽象类应用——模板设计模式" class="headerlink" title="10.8 抽象类应用——模板设计模式"></a>10.8 抽象类应用——模板设计模式</h2><h3 id="10-8-1-为什么要模板设计（代码解耦）"><a href="#10-8-1-为什么要模板设计（代码解耦）" class="headerlink" title="10.8.1 为什么要模板设计（代码解耦）"></a>10.8.1 为什么要模板设计（代码解耦）</h3><ul>
<li>首先模板设计是基于抽象类的，抽象类和继承紧密相关，我们可以把抽象类看作是若干子类的通用模板<ul>
<li>子类可以在抽象类的基础上拓展，并且可以保留抽象类的行为方式</li>
</ul>
</li>
<li>模板设计可以解决以下两个需求<ul>
<li>一个模板内部一部分是确定的，一部分是没有确定的，没有确定的需要暴露给子类实现</li>
<li>编写抽象父类，父类提供子类的通用方法，交给子类实现</li>
</ul>
</li>
</ul>
<p>总结：代码的耦合性更低了，也很规范。</p>
<h3 id="10-8-2-快速入门"><a href="#10-8-2-快速入门" class="headerlink" title="10.8.2 快速入门"></a>10.8.2 快速入门</h3><p> 现在有一个需求，统计多个任务的完成时间</p>
<p>我们很自然的可以解决这个问题</p>
<ul>
<li>step1. 记录完成前的时间t1</li>
<li>step2. 任务执行</li>
<li>step3. 记录完成后的时间t2，并返回t2 - t1</li>
</ul>
<p>实际上，step1和step3我们其实是已知的，调用方法库就可以得到当前的时间，只有step2不确定</p>
<ul>
<li>一种想法是把步骤封装在一个函数体内，然后调用step2里不确定的方法（见baa实例）</li>
<li>另外一种就是用模板设计模式，单独交给一个抽象类来定义这个任务（见bb实例）</li>
</ul>
<p>可以看到，每个类只要重写未实现的方法就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.abstract_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	任务执行时间: 3</span></span><br><span class="line"><span class="comment">    任务执行时间: 5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        aa.calculate();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Template</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        bb.calculate(); <span class="comment">// 涉及动态绑定机制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> &#123;</span><br><span class="line">    <span class="comment">// 改进1：使用组合模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 得到开始任务的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        job();</span><br><span class="line">        <span class="comment">// 得到结束的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;任务执行时间: &quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算任务 1+2+..+10000</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 10000.for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            num += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="comment">// 进一步改进：使用抽象模板模式,此时只需要定义job方法</span></span><br><span class="line">    <span class="comment">// 计算任务 1+2+..+10000</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 10000.for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">8000000</span>; i++) &#123;</span><br><span class="line">            num -= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>模板设计模式的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.abstract_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模板设计模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        job();  <span class="comment">// 动态绑定机制，执行运行类型为BB的job()</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;任务执行时间: &quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="10-9-接口"><a href="#10-9-接口" class="headerlink" title="10.9 接口"></a>10.9 接口</h2><h3 id="10-9-1-为什么要接口（定义规范统一方法）"><a href="#10-9-1-为什么要接口（定义规范统一方法）" class="headerlink" title="10.9.1 为什么要接口（定义规范统一方法）"></a>10.9.1 为什么要接口（定义规范统一方法）</h3><ul>
<li>usb就是一个最直观的接口例子，设计了统一的接口 尺寸的规范，然后让多个设备（手机 相机）来进行连接，从而保证拓展性</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240707161957343.png" alt="image-20240707161957343">	</p>
<p>单说这个有点模糊，我们需要结合实际场景深入理解一下USB。</p>
<p>现在有一个场景，比如说要造飞机，那需要一个飞机的设计师，还有生产家。</p>
<p>那么接口就是让飞机设计师设计的，比如飞机的大小、规格、功能等等，后面就让生产家造就完了。</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240707165921719.png" alt="image-20240707165921719">	</p>
<p>来一个具体的项目例子，团队要共同开发一个软件，为了控制软件的开发规范等等，项目经理通常会定义一些接口，来让其他程序员实现。</p>
<img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240707170038315.png" alt="image-20240707170038315" style="zoom:67%;" />	



<p>给出一个实际案例，现在要让三个程序员分别连接mysql、oracle和DB2数据库</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240707170140875.png" alt="image-20240707170140875">	</p>
<p>如果按照传统的做法，那就是分别让3个程序员写A B C类，存在一些问题</p>
<ul>
<li>对于连接数据库和关闭数据库的操作，每个程序员定义的方法名会有差异，造成<code>不规范</code></li>
<li>为了保证每个程序员定义代码的规范性，所以需要用到接口这个技术来统一地规范需要实现的方法（比如这里的数据库连接和释放）</li>
</ul>
<p>定义接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DBInterface</span> &#123; <span class="comment">// 项目经理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MySQL实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlDB</span> <span class="keyword">implements</span> <span class="title class_">DBInterface</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;connect mysql&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;close mysql&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Oracle实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OracleDB</span> <span class="keyword">implements</span> <span class="title class_">DBInterface</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Connecting to Oracle Database&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Closing Oracle Database&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	connect mysql</span></span><br><span class="line"><span class="comment">    close mysql</span></span><br><span class="line"><span class="comment">    Connecting to Oracle Database</span></span><br><span class="line"><span class="comment">    Closing Oracle Database</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interface03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 规范代码，使用起来统一管理</span></span><br><span class="line">        <span class="type">MysqlDB</span> <span class="variable">mysqlDB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MysqlDB</span>();</span><br><span class="line">        t(mysqlDB);</span><br><span class="line"></span><br><span class="line">        <span class="type">OracleDB</span> <span class="variable">oracleDB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OracleDB</span>();</span><br><span class="line">        t(oracleDB);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">t</span><span class="params">(DBInterface db)</span> &#123;</span><br><span class="line">        db.connect();</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="10-9-2-快速入门"><a href="#10-9-2-快速入门" class="headerlink" title="10.9.2 快速入门"></a>10.9.2 快速入门</h3><p>接口把一些没有实现的方法封装到了一起，某个类要实现的时候，根据情况来实现相关的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interface 类名 implements 接口 &#123;</span><br><span class="line">    属性;</span><br><span class="line">    方法;（<span class="keyword">default</span>）</span><br><span class="line">    必须实现的接口方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>理解：接口是比抽象类更抽象的类，<code>一般方法都没有方法体</code>(jdk7前)。</p>
<ul>
<li>jdk8以后 接口类可以有静态方法、默认方法(default)，即<code>接口也可以有具体实现</code></li>
</ul>
</li>
<li><p>体现出多态、<code>高内聚低耦合</code>的思想</p>
<ul>
<li><p>子类实现接口定义的规范</p>
</li>
<li><p>接口类可以作为多态参数进行传入从而实现接口多态。</p>
</li>
</ul>
</li>
</ul>
<p>接口类AInterface.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AInterface</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">// 等价public staitc final public n1 = 10 后面会说到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="comment">// (1)接口中，抽象方法可以省略abstract关键字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (2)在JDK8以后可以有默认实现方法，需要用default关键字修饰</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">ok</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AInterface ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (3)jdk8后，可以有静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AInterface cry&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主方法Interface02.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interface02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一个类 implements 实现接口</span></span><br><span class="line"><span class="comment">// 需要将该接口所有的抽象方法实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">AInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A hi()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>有了这些铺垫，我们来实现一下USB的案例</p>
<p>接口UsbInterface.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UsbInterface</span> &#123; <span class="comment">// 接口</span></span><br><span class="line">    <span class="comment">// 规定接口的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Camera.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Camera</span> <span class="keyword">implements</span> <span class="title class_">UsbInterface</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Camera start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Camera stop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Phone.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Phone类实现了USBInterface</span></span><br><span class="line"><span class="comment">// （1）Phone类实现接口，本质：实现UsbInterface规定（声明）的方法(规范)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">UsbInterface</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Phone start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Phone stop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Computer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="comment">// 编写方法</span></span><br><span class="line">    <span class="comment">// 1.usbInterface形参是接口类型</span></span><br><span class="line">    <span class="comment">// 2.参数 可接收 实现UsbInterface接口的类 的 对象实例，即多态参数</span></span><br><span class="line">    <span class="comment">// 实现了接口多态，用接口的引用指向实现的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(UsbInterface usbInterface)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过接口来调用方法</span></span><br><span class="line">        usbInterface.start();</span><br><span class="line">        usbInterface.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主方法Interface01.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Phone start</span></span><br><span class="line"><span class="comment">    Phone stop</span></span><br><span class="line"><span class="comment">    =============</span></span><br><span class="line"><span class="comment">    Camera start</span></span><br><span class="line"><span class="comment">    Camera stop</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interface01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建手机相机对象，实现了USB接口</span></span><br><span class="line">        <span class="type">Camera</span> <span class="variable">camera</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="comment">// 创建计算机，实现了USB接口</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        computer.work(phone); <span class="comment">// 把手机接入到计算机</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=============&quot;</span>);</span><br><span class="line">        computer.work(camera); <span class="comment">// 把相机接入到计算机</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="10-9-3-细节1——接口的抽象性"><a href="#10-9-3-细节1——接口的抽象性" class="headerlink" title="10.9.3 细节1——接口的抽象性"></a>10.9.3 细节1——接口的抽象性</h3><ul>
<li>接口不能被<code>实例化</code></li>
<li>接口中所有的方法都是<code>public方法</code>，接口中的抽象方法，<code>不需要用abstract修饰</code></li>
<li>普通类实现接口，<code>必须实现所有抽象方法</code><ul>
<li>当然，如果是抽象类实现接口，就不需要实现了</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDetail01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        new IA();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.接口本身无法实例化</span></span><br><span class="line"><span class="comment">// 2.接口所有方法是public方法， 接口的抽象方法可以不用abstract修饰</span></span><br><span class="line"><span class="comment">// 3.普通类实现接口，必须把接口所有的抽象方法实现</span></span><br><span class="line"><span class="comment">// 4.抽象类可以不实现接口的抽象方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">    <span class="comment">// 等价于public abstract void say();</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alt+回车 快速实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类可以不实现接口的方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Tiger</span> <span class="keyword">implements</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-9-4-细节2——接口的静态final属性"><a href="#10-9-4-细节2——接口的静态final属性" class="headerlink" title="10.9.4 细节2——接口的静态final属性"></a>10.9.4 细节2——接口的静态final属性</h3><ul>
<li>一个类可以实现多个接口</li>
<li>接口中的属性，只能是final的，并且是<code>public static final</code>修饰符<ul>
<li>int a &#x3D; 1 等价于 public static final int a &#x3D; 1</li>
<li>由于是属性是静态的，那么接口中属性的访问形式就是<code>接口名.属性名</code></li>
</ul>
</li>
<li>接口不能继承其他类，但是可以<code>同时继承多个接口</code><ul>
<li>注意是<code>接口继承接口</code> interface A extends B, C</li>
</ul>
</li>
<li>接口的<code>修饰符</code>只能是类和默认，和类的修饰符一样。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDetail02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 证明interface的属性是static的,访问属性同static访问方法</span></span><br><span class="line">        System.out.println(IB.n1);</span><br><span class="line"><span class="comment">//        IB.n1 = 11;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IB</span> &#123;</span><br><span class="line">    <span class="comment">// 等价于public static final int n1 = 10;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IC</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口可以继承多个其他接口，注意不是实现</span></span><br><span class="line"><span class="comment">// 接口修饰符只能是public或者默认，同类的修饰符</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ID</span> <span class="keyword">extends</span> <span class="title class_">IB</span>, IC &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span> <span class="keyword">implements</span> <span class="title class_">IB</span>, IC &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-9-5-实现接口-vs-继承类（补充关系）"><a href="#10-9-5-实现接口-vs-继承类（补充关系）" class="headerlink" title="10.9.5 实现接口 vs 继承类（补充关系）"></a>10.9.5 实现接口 vs 继承类（补充关系）</h3><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240707172729076.png" alt="image-20240707172729076" style="zoom:67%;" />	

<p>韩老师举了一个例子</p>
<ul>
<li>小猴子继承monkey<ul>
<li>隐式的获取了父类的可访问成员</li>
<li>继承更多的是注重代码的<code>复用性和可维护性</code></li>
<li>继承只能继承一个</li>
</ul>
</li>
<li>小猴子实现小鸟和鱼<ul>
<li>小猴子可以在继承monkey的基础上，必须完成小鸟的fly()和小鱼的swim()行为</li>
<li>接口更多的是在于<code>设计各种规范的方法</code>，让其他实现类灵活的去使用，实现<code>代码的解耦</code>（接口规范和动态绑定，后面马上说<code>接口的多态</code>）</li>
<li>接口可以实现多个</li>
</ul>
</li>
</ul>
<p>得出的结论</p>
<ul>
<li>实现接口是继承类的<code>补充</code></li>
<li>两者侧重点不同，继承注重<code>代码复用</code>，接口注重<code>代码规范</code></li>
<li>实现和继承 面向的对象不同<ul>
<li>继承要求满足<code>is-a</code>的关系，而接口只需满足<code>lika-a </code>的关系，接口是更加灵活的</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Monkey(悟空) climbing by father</span></span><br><span class="line"><span class="comment">    Monkey(悟空) learn swimming by fishable</span></span><br><span class="line"><span class="comment">    Monkey(悟空) learn flying by fishable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsVsInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LittleMonkey</span> <span class="variable">wuKong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LittleMonkey</span>(<span class="string">&quot;悟空&quot;</span>);</span><br><span class="line">        wuKong.climbing();</span><br><span class="line">        wuKong.swimming();</span><br><span class="line">        wuKong.flying();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="comment">// 子类继承父类后自动拥有父类的功能</span></span><br><span class="line"><span class="comment">// 而子类如果要扩展功能，可以通过实现接口的方式来扩展</span></span><br><span class="line"><span class="comment">// 理解：实现接口是对java单继承机制的补充</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monkey</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Monkey</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">climbing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Monkey(&quot;</span> + name + <span class="string">&quot;) climbing by father&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fishable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Birdable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">flying</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LittleMonkey</span> <span class="keyword">extends</span> <span class="title class_">Monkey</span> <span class="keyword">implements</span> <span class="title class_">Fishable</span>,Birdable&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LittleMonkey</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Monkey(&quot;</span> + getName() + <span class="string">&quot;) learn swimming by fishable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flying</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Monkey(&quot;</span> + getName() + <span class="string">&quot;) learn flying by fishable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们要注意，如果参数的指向是模糊的，那么就会报错，在继承和实现接口同时出现的时候有一个案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceExercise02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A2</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 反映出public static final</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B2</span> <span class="keyword">implements</span> <span class="title class_">A2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">px</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println(x);  // 错误 引用ambiguous</span></span><br><span class="line">        <span class="comment">// 解决方案 明确指定即可</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A2:&quot;</span> + A2.x);</span><br><span class="line">        System.out.println(<span class="string">&quot;B2:&quot;</span> + <span class="built_in">super</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>().px();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-9-6-接口的多态"><a href="#10-9-6-接口的多态" class="headerlink" title="10.9.6 接口的多态"></a>10.9.6 接口的多态</h3><ul>
<li>在前面的USB案例中，我们已经展示了接口的<code>多态参数</code>的使用<ul>
<li>UsbInterface既可以接收Phone类型的对象，也可以接收Camera类型的对象</li>
</ul>
</li>
</ul>
<p>我们进一步地说明接口多态中的<code>多态数组</code>和<code>多态传递</code>的现象</p>
<h4 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h4><p>多态数组案例，我们这里数组的类型就是接口的类型了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfacePolyArr</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 多态数组 --&gt; 接口类型数组</span></span><br><span class="line">        Usb[] usb = <span class="keyword">new</span> <span class="title class_">Usb</span>[<span class="number">2</span>];</span><br><span class="line">        usb[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Phone_</span>();</span><br><span class="line">        usb[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Camera_</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; usb.length; i++) &#123;</span><br><span class="line">            usb[i].work();</span><br><span class="line">            <span class="comment">// 向下转型，判断运行类型</span></span><br><span class="line">            <span class="keyword">if</span> (usb[i] <span class="keyword">instanceof</span> Phone_) &#123;</span><br><span class="line">                ((Phone_) usb[i]).call();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone_</span> <span class="keyword">implements</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Phone_ call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Phone_ work&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera_</span> <span class="keyword">implements</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Camera_ work&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h4><p>前面USB已经提到了这个案例，本质上就是父类（接口类）的引用可以指向IF接口的对象实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfacePolyParameter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 接口的多态体现案例</span></span><br><span class="line">        <span class="comment">// 接口类型if01 可以指向实现了IF接口的对象实例</span></span><br><span class="line">        <span class="type">IF</span> <span class="variable">if01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Monster</span>();</span><br><span class="line">        <span class="type">IF</span> <span class="variable">if02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继承体现的多态</span></span><br><span class="line">        <span class="type">AAA</span> <span class="variable">aaa01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BBB</span>();</span><br><span class="line">        <span class="type">AAA</span> <span class="variable">aaa02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CCC</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IF</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span> <span class="keyword">implements</span> <span class="title class_">IF</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">IF</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AAA</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BBB</span> <span class="keyword">extends</span> <span class="title class_">AAA</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCC</span> <span class="keyword">extends</span> <span class="title class_">AAA</span> &#123;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="多态传递"><a href="#多态传递" class="headerlink" title="多态传递"></a>多态传递</h4><p>如果子类实现了一个接口，而这个接口继承了其他接口，那么这个子类也可以实现其他接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示多态传递现象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfacePolyPass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IG</span> <span class="variable">ig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        <span class="comment">// 如果IG继承了IH接口，Teacher类实现了IG接口</span></span><br><span class="line">        <span class="comment">// 相当于Teacher类实现了IH接口</span></span><br><span class="line">        <span class="comment">// 这就是接口的多态传递现象</span></span><br><span class="line">        <span class="type">IH</span> <span class="variable">ih</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IH</span> &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IG</span> <span class="keyword">extends</span> <span class="title class_">IH</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">IG</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-9-7-接口多态——唐僧使用交通工具"><a href="#10-9-7-接口多态——唐僧使用交通工具" class="headerlink" title="10.9.7 接口多态——唐僧使用交通工具"></a>10.9.7 接口多态——唐僧使用交通工具</h3><ul>
<li>有一个交通工具接口类Vehicles，有work接口</li>
<li>有Horse类和Boat类分别实现Vehicles</li>
<li>创建交通工具工厂类，有两个方法分别获得交通工具Horse和Boat</li>
<li>有Person类，有name和Vehicles属性，在构造器中为两个属性赋值</li>
<li>实例化Person对象“唐僧”，要求一般情况下用Horse作为交通工具</li>
<li>遇到大河时用Boat作为交通工具</li>
</ul>
<p>涉及到的编程思想和细节较多，代码解耦的很好，值得细品、借鉴。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.homework;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yuezi2048</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Homework06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;唐僧&quot;</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入当前情况：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">condition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Scanner(System.in).next();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">tang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name, <span class="keyword">new</span> <span class="title class_">Horse</span>());</span><br><span class="line">        <span class="comment">// 如果过火焰山，使用飞机，后续修改代码就很方便</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;过河&quot;</span>.equals(condition)) &#123;</span><br><span class="line">            tang.passRiver(); <span class="comment">// 如果在函数单纯的判断当前载具为空，那么就遗漏了一些逻辑</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;火焰山&quot;</span>.equals(condition))&#123;</span><br><span class="line">            tang.passFlamingMountain();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tang.common();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Vehicles</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Horse</span> <span class="keyword">implements</span> <span class="title class_">Vehicles</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Horse work()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boat</span> <span class="keyword">implements</span> <span class="title class_">Vehicles</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Boat work()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plane</span> <span class="keyword">implements</span> <span class="title class_">Vehicles</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Plane work()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VehiclesFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Horse</span> <span class="variable">horse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Horse</span>(); <span class="comment">// 饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">VehiclesFactory</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Horse <span class="title function_">getHorseInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        return new Horse(); // 这里不太合适,我需要一直跟着唐僧的那一匹白龙马 做出优化</span></span><br><span class="line">        <span class="keyword">return</span> horse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Boat <span class="title function_">getBoatInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Boat</span>(); <span class="comment">// 这里可以，每一条河的船可以生成不同的新的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Plane <span class="title function_">getPlaneInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Plane</span>(); <span class="comment">// 这里可以，每一个飞机可以生成不同的新的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Vehicles vehicles;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, Vehicles vehicles)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.vehicles = vehicles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及到编程思想，将具体的功能（过河-获取船，否则获取马）封装到方法里面</span></span><br><span class="line">    <span class="comment">// 因为一开始构造函数有一个Vehicle 并且有一个接口，我们选择复用接口 来实现解耦</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">passRiver</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        Boat boat = VehiclesFactory.getBoatInstance();</span></span><br><span class="line"><span class="comment">//        boat.work();</span></span><br><span class="line">        <span class="comment">// 出现问题：如果vehicle为空 或者 不是船时，应该是改成船的，但是还是会调用原来的载具，加入特判即可</span></span><br><span class="line"><span class="comment">//        if (vehicles == null || !(vehicles instanceof Boat)) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (!(vehicles <span class="keyword">instanceof</span> Boat)) &#123; <span class="comment">// 这里包含了vehicles为空的情况</span></span><br><span class="line">            vehicles = VehiclesFactory.getBoatInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 体现出使用接口调用，使用多态</span></span><br><span class="line">        vehicles.work();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">passFlamingMountain</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(vehicles <span class="keyword">instanceof</span> Plane)) &#123;</span><br><span class="line">            vehicles = VehiclesFactory.getPlaneInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        vehicles.work();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">common</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(vehicles <span class="keyword">instanceof</span> Horse)) &#123;</span><br><span class="line">            vehicles = VehiclesFactory.getHorseInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        vehicles.work();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vehicles <span class="title function_">getVehicles</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vehicles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="10-10-内部类"><a href="#10-10-内部类" class="headerlink" title="10.10 内部类"></a>10.10 内部类</h2><h3 id="10-10-1-为什么要内部类（类的包含关系）"><a href="#10-10-1-为什么要内部类（类的包含关系）" class="headerlink" title="10.10.1 为什么要内部类（类的包含关系）"></a>10.10.1 为什么要内部类（类的包含关系）</h3><ul>
<li>内部类可以直接访问私有属性</li>
<li>体现出类与类之间的包含关系。如Car.Air，表示定义了车里的空调类</li>
</ul>
<h3 id="10-10-2-快速入门"><a href="#10-10-2-快速入门" class="headerlink" title="10.10.2 快速入门"></a>10.10.2 快速入门</h3><p><code>内部类(inner class)</code>：一个类里嵌套定义一个类，是我们类的五大成员的最后一大类【属性、构造器、代码块、方法、<code>内部类</code>】</p>
<ul>
<li><p>内部类可以直接访问此类的<code>私有属性</code>，并且体现出类与类的<code>包含关系</code>，后面我们在看源码的时候，会包含大量的内部类</p>
</li>
<li><p>内部类一共就四种</p>
<ul>
<li><p>定义在类的局部位置（方法&#x2F;代码块）：（1）<code>局部内部类</code>（有类名）；（2）<strong><code>匿名内部类</code></strong>（**重要!!!**系统分配类名不需要自己定义）</p>
</li>
<li><p>定义在类的成员位置：（3）<code>成员内部类</code>（无static修饰）；（4）<code>静态内部类</code>（有static修饰）</p>
</li>
</ul>
</li>
</ul>
<p>给一个具体的快速入门案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass01</span> &#123; <span class="comment">// 外部其他类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123; <span class="comment">// 外部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 属性</span></span><br><span class="line">    &#123; <span class="comment">// 代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Outer code block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">(<span class="type">int</span> n1)</span> &#123; <span class="comment">// 构造器</span></span><br><span class="line">        <span class="built_in">this</span>.n1 = n1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123; <span class="comment">// 方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123; <span class="comment">// 成员内部类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="10-10-3-局部内部类"><a href="#10-10-3-局部内部类" class="headerlink" title="10.10.3 局部内部类"></a>10.10.3 局部内部类</h3><p>本质上是一个类</p>
<ul>
<li><code>访问权限</code>：可以直接访问外部类的所有成员，包括私有的、<ul>
<li>内部类访问外部类成员：<code>直接访问</code>（如果外部类成员和内部类重名，就近原则访问，要访问外部类的话：Outer.this.n1）</li>
<li>外部类访问内部类成员：需要<code>创建对象</code>再访问</li>
<li>外部其他类不能直接访问内部类成员：相当于外部其他类不能访问局部变量</li>
</ul>
</li>
<li><code>修饰符</code>：访问修饰符同局部变量，只能被<code>final</code>修饰，其他都不行</li>
<li><code>作用域</code>：定义的方法体或代码块内</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示局部内部类的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalInnerClass</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        内部类的n1 = 800</span></span><br><span class="line"><span class="comment">        hashcode(Inner02.this):com.hspedu.Innerclass.Outer02$2Inner02@4aa298b7</span></span><br><span class="line"><span class="comment">        Outer02.m2</span></span><br><span class="line"><span class="comment">        ===============================</span></span><br><span class="line"><span class="comment">        外部类的n1=100</span></span><br><span class="line"><span class="comment">        hashcode(Outer02.this):com.hspedu.Innerclass.Outer02@7d4991ad</span></span><br><span class="line"><span class="comment">        hashcode(outer02):com.hspedu.Innerclass.Outer02@7d4991ad</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer02</span> <span class="variable">outer02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer02</span>();</span><br><span class="line">        outer02.m1();</span><br><span class="line">        System.out.println(<span class="string">&quot;hashcode(outer02):&quot;</span> + outer02);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer02</span> &#123; <span class="comment">// 外部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer02.m2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// 代码块</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner02</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// （1）局部内部类定义在外部类的局部位置，一般是在方法体内</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner02</span> &#123; <span class="comment">// 局部内部类（本质还是一个类）</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">800</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// (2)可以访问外部类的所有属性，包括私有成员</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123; <span class="comment">// 内部类同样也包含五个要素</span></span><br><span class="line">                <span class="comment">// (3)局部内部类和局部变量一样，不能用访问修饰符修饰，但可以用final修饰</span></span><br><span class="line">                <span class="comment">// (4) 作用域仅局限在方法体或者代码块内</span></span><br><span class="line">                <span class="comment">// (5)局部内部类访问外部类成员，直接访问3</span></span><br><span class="line">                System.out.println(<span class="string">&quot;内部类的n1 = &quot;</span> + n1); <span class="comment">// 内部类属于外部类，可以访问外部类私有成员 这里等价于this.n1</span></span><br><span class="line">                System.out.println(<span class="string">&quot;hashcode(Inner02.this):&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">                m2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner03</span> <span class="keyword">extends</span> <span class="title class_">Inner02</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (6)外部类可以创建Inner02对象，调用方法即可[注意局部内部类作用域]</span></span><br><span class="line">        <span class="type">Inner02</span> <span class="variable">inner02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner02</span>();</span><br><span class="line">        inner02.f1();</span><br><span class="line">        System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">        <span class="comment">// (7)外部类和局部类名重合时，遵循就近原则如果要访问外部类的成员，使用外部类名.this.成员访问</span></span><br><span class="line">        <span class="comment">// 解读：Outer02.this本质是外部类的对象，哪个对象调用了m1()方法，Outer02.this就是哪个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;外部类的n1=&quot;</span> + Outer02.<span class="built_in">this</span>.n1);</span><br><span class="line">        System.out.println(<span class="string">&quot;hashcode(Outer02.this):&quot;</span> + Outer02.<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="10-10-4-匿名内部类"><a href="#10-10-4-匿名内部类" class="headerlink" title="10.10.4 *匿名内部类"></a>10.10.4 *匿名内部类</h3><ul>
<li>基于接口的<code>匿名内部类</code><ul>
<li>IA dog &#x3D; new IA() {}; 左边是编译类型IA，右边是需要实现IA接口的匿名内部类，<code>括号里是对应的构造方法</code></li>
<li>相当于定义了接口的子类Outer04$1（底层命名），定义完后，匿名内部类不能再new，但可以反复调用dog对象</li>
</ul>
</li>
<li>基于继承类的<code>匿名内部类</code><ul>
<li>Father fa &#x3D; new Father(“jack”) {};，同理调用Father类的构造方法，定义了继承Father类的子类，可以重写父类的test方法</li>
</ul>
</li>
<li>基于抽象类的<code>匿名内部类</code><ul>
<li>Animal animal &#x3D; new Animal() {}; 调用Animal类的默认构造方法，定义了实现抽象类的匿名内部类，待实现Animal类的eat方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示匿名内部类的使用【重点掌握】</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClass</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Tiger cry</span></span><br><span class="line"><span class="comment">        dog的运行类型是class com.hspedu.Innerclass.Outer04$1</span></span><br><span class="line"><span class="comment">        Dog cry</span></span><br><span class="line"><span class="comment">        Dog cry</span></span><br><span class="line"><span class="comment">        =================</span></span><br><span class="line"><span class="comment">        Father(Jack)</span></span><br><span class="line"><span class="comment">        father的运行类型是class com.hspedu.Innerclass.Outer04$2</span></span><br><span class="line"><span class="comment">        匿名内部类重写了test()方法</span></span><br><span class="line"><span class="comment">        =============</span></span><br><span class="line"><span class="comment">        dog eat bone.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer04</span> <span class="variable">outer04</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer04</span>();</span><br><span class="line">        outer04.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer04</span> &#123; <span class="comment">// 外部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123; <span class="comment">// 方法</span></span><br><span class="line">        <span class="comment">// 基于接口的匿名内部类</span></span><br><span class="line">        <span class="comment">// 1.需求：想使用IA接口，并创建对象</span></span><br><span class="line">        <span class="comment">// 2.传统写法：新建一个类实现IA接口，并重写cry()方法，然后再创建对象调用</span></span><br><span class="line">        <span class="type">IA</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tiger</span>();</span><br><span class="line">        tiger.cry();</span><br><span class="line">        <span class="comment">// 3.进阶需求：要求只用一次Tiger类，以后不使用了，而且老韩还要通过Dog类实现IA接口...</span></span><br><span class="line">        <span class="comment">// 4.使用匿名内部类简化开发</span></span><br><span class="line">        <span class="comment">// 5. dog的编译类型是IA</span></span><br><span class="line">        <span class="comment">// 6. dog的运行类型是【?】，答：看等号右边，即 【实现了IA接口的匿名内部类Outer04$1】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            看底层（底层自动分配了XXXX）</span></span><br><span class="line"><span class="comment">            class XXXX implements IA &#123;</span></span><br><span class="line"><span class="comment">                @Override</span></span><br><span class="line"><span class="comment">                public void cry() &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(&quot;dog cry&quot;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 7. jdk底层在创建匿名内部类时，立即就创建了Outer04$1实例，并且把地址返回给dog</span></span><br><span class="line">        <span class="comment">// 因此，new IA() &#123;&#125; 并不是实例化抽象的接口，而是在底层自动实例化了实现了IA接口的匿名内部类</span></span><br><span class="line">        <span class="comment">// 8. 匿名内部类使用一次不能再new Outer04$1()，但是对象是可以反复使用的，理解为临时生成一个对象</span></span><br><span class="line">        <span class="type">IA</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Dog cry&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog的运行类型是&quot;</span> + dog.getClass());</span><br><span class="line">        dog.cry();</span><br><span class="line">        dog.cry();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        <span class="comment">// 演示基于类的匿名内部类</span></span><br><span class="line">        <span class="comment">// 1.father的编译类型是Father</span></span><br><span class="line">        <span class="comment">// 2.father的运行类型是继承Father类的匿名内部类Outer04$2</span></span><br><span class="line">        <span class="comment">// 3.同理，在底层创建了匿名内部类</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            class Outer04$2 extends Father &#123;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 注意，参数列表会传递给Father构造器，底层自动为我们实现了匿名内部类的构造器</span></span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>(<span class="string">&quot;Jack&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类重写了test()方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;father的运行类型是&quot;</span> + father.getClass());</span><br><span class="line">        father.test();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=============&quot;</span>);</span><br><span class="line">        <span class="comment">// 基于抽象类的匿名内部类</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;dog eat bone.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        animal.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span> &#123; <span class="comment">// 接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> <span class="keyword">implements</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tiger cry&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// class Dog implements IA ... ? 不建议，建议用匿名内部类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123; <span class="comment">// 类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father(&quot;</span> + name + <span class="string">&quot;)&quot;</span>);<span class="comment">// 构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123; <span class="comment">// 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="细节——匿名内部类的访问"><a href="#细节——匿名内部类的访问" class="headerlink" title="细节——匿名内部类的访问"></a>细节——匿名内部类的访问</h4><p>本质上是一个类，但同时他本身是一个<code>对象</code>(可以调用匿名内部类的方法)</p>
<ul>
<li><code>访问权限</code>：可以直接访问外部类的所有成员，包括私有的、<ul>
<li>内部类访问外部类成员：<code>直接访问</code>（如果外部类成员和内部类重名，就近原则访问，要访问外部类的话：Outer.this.n1）</li>
<li>外部其他类不能直接访问内部类成员：相当于外部其他类不能访问局部变量</li>
</ul>
</li>
<li><code>修饰符</code>：访问修饰符同局部变量，只能被<code>final</code>修饰，其他都不行</li>
<li><code>作用域</code>：定义的方法体或代码块内</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	this(anonymous).n1=888</span></span><br><span class="line"><span class="comment">    Outer05.n1=99</span></span><br><span class="line"><span class="comment">    Outer05.this=com.hspedu.Innerclass.Outer05@1b6d3586</span></span><br><span class="line"><span class="comment">    匿名内部类重写父类的hi方法</span></span><br><span class="line"><span class="comment">    Person ok(Jack)</span></span><br><span class="line"><span class="comment">    outher05=com.hspedu.Innerclass.Outer05@1b6d3586</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClassDetail</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer05</span> <span class="variable">outer05</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer05</span>();</span><br><span class="line">        outer05.f1();</span><br><span class="line">        System.out.println(<span class="string">&quot;outher05=&quot;</span> + outer05);</span><br><span class="line">        <span class="comment">// 外部其他类不能访问匿名内部类，还是因为匿名内部类是局部变量</span></span><br><span class="line"><span class="comment">//        person.hi();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer05</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创造一个基于类的内部类</span></span><br><span class="line">        <span class="comment">// (1)第一种调用匿名内部类的方法，将匿名对象赋值给编译类型为Person类的对象，动态绑定机制调用对象的方法</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">888</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// (3)可以访问外部类的私有属性n1，直接访问即可</span></span><br><span class="line">                System.out.println(<span class="string">&quot;this(anonymous).n1=&quot;</span> + n1);</span><br><span class="line">                <span class="comment">// 匿名内部类和外部类重名时，遵循就近原则，如果要访问外部类，同样用Outer.this.n1</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Outer05.n1=&quot;</span> + Outer05.<span class="built_in">this</span>.n1);</span><br><span class="line">                <span class="comment">// Outer05.this就是谁调用f1()就是谁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Outer05.this=&quot;</span> + Outer05.<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类重写父类的hi方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        person.hi(); <span class="comment">// 动态绑定，运行类型是$Outer05$1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// (2)第二种调用匿名内部类的方法，因为匿名内部类本身也是一个对象，因此可以直接调用,同new Person().hi()</span></span><br><span class="line">        <span class="comment">// class Outer05$2 extends Person &#123;&#125;</span></span><br><span class="line">        <span class="comment">// (4) 匿名内部类不能添加访问修饰符,因为匿名内部类的地位仅是局部变量</span></span><br><span class="line">        <span class="comment">// (5) 匿名内部类作用域是在定义的方法或代码块中</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ok</span><span class="params">(String str)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.ok(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.ok(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ok</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person ok(&quot;</span> + str + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象类和接口都可以</span></span><br></pre></td></tr></table></figure>



<h4 id="应用——匿名内部类作为实参传递"><a href="#应用——匿名内部类作为实参传递" class="headerlink" title="应用——匿名内部类作为实参传递"></a>应用——匿名内部类作为实参传递</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这是一副名画</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassExercise01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 匿名内部类可以直接当作实参传递</span></span><br><span class="line">        f1(<span class="keyword">new</span> <span class="title class_">IL</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是一副名画&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 对比一下传统写法：f1(new Picture().show) 需要再写个类</span></span><br><span class="line">        <span class="comment">// 编程领域称之为硬编码，此场景不太推荐，因为只有一次却要专门定义一个类，就不太合适</span></span><br><span class="line">        <span class="comment">//  而且如果在Picture当中修改了show方法，那么对应所有的实例都会修改，反之匿名内部类比较灵活 只影响一个</span></span><br><span class="line">        <span class="comment">// 当然如果需要多次重复使用picture对象，那当然为此专门新建一个类好</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(IL il)</span> &#123;</span><br><span class="line">        il.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IL</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-10-5-成员内部类"><a href="#10-10-5-成员内部类" class="headerlink" title="10.10.5 成员内部类"></a>10.10.5 成员内部类</h3><p>本质上是类的一个成员（没有static修饰的类）</p>
<ul>
<li><code>访问权限</code>：可以直接访问外部类的所有成员，包括私有的<ul>
<li>内部类访问外部类成员：<code>直接访问</code>（如果外部类成员和内部类重名，就近原则访问，要访问外部类的话：Outer.this.n1）</li>
<li>外部类访问内部类成员：需要<code>创建对象</code>再访问</li>
<li>外部其他类有两种方法访问成员内部类<ul>
<li>第一种是通过外部类对象new：<code>Outer.Inner xxx  = outher.new Inner();  </code></li>
<li>第二种是通过外部类的方法getInstance访问：<code>new outer().getInnerInstance()</code></li>
</ul>
</li>
</ul>
</li>
<li><code>修饰符</code>：访问修饰符同类的成员，public protected 默认 private final</li>
<li><code>作用域</code>：定义的整个类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Outer01的n1=10，Inner08的n1=66</span></span><br><span class="line"><span class="comment">    Outer08 say</span></span><br><span class="line"><span class="comment">    99.8</span></span><br><span class="line"><span class="comment">    =================</span></span><br><span class="line"><span class="comment">    Outer01的n1=10，Inner08的n1=66</span></span><br><span class="line"><span class="comment">    Outer08 say</span></span><br><span class="line"><span class="comment">    Outer01的n1=10，Inner08的n1=66</span></span><br><span class="line"><span class="comment">    Outer08 say</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer08</span> <span class="variable">outer08</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer08</span>();</span><br><span class="line">        outer08.t1();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        <span class="comment">// 外部其他类使用成员内部类的两种方式</span></span><br><span class="line">        <span class="comment">// (1)用外部类的对象 去 new一个内部类，返回给Outer08.Inner08</span></span><br><span class="line">        <span class="comment">// 理解：把Inner08是Outer08当作一个成员，又因为不是静态成员，因此要借助 外部类的对象访问</span></span><br><span class="line">        <span class="comment">// 不用特别纠结，语法规定，知道就行</span></span><br><span class="line">        Outer08.<span class="type">Inner08</span> <span class="variable">inner08</span> <span class="operator">=</span> outer08.<span class="keyword">new</span> <span class="title class_">Inner08</span>();</span><br><span class="line">        inner08.say();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (2)在外部类中编写方法编写一个方法 返回Inner08对象</span></span><br><span class="line">        Outer08.<span class="type">Inner08</span> <span class="variable">inner082</span> <span class="operator">=</span> outer08.getInner08Instance();</span><br><span class="line">        inner082.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer08</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;hsp&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer08 say&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以添加访问修饰符，因为他是外部类的一个成员，对成员允许的，内部类也可以</span></span><br><span class="line">    <span class="comment">// 成员内部类作用域在整个类中</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner08</span> &#123; <span class="comment">// 成员内部类【定义位置在外部类的成员位置上】</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">double</span> <span class="variable">sal</span> <span class="operator">=</span> <span class="number">99.8</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 可以直接访问外部类的所有成员，包括私有成员</span></span><br><span class="line">            <span class="comment">// 外部类的属性直接访问</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Outer01的n1=&quot;</span> + Outer08.<span class="built_in">this</span>.n1 + <span class="string">&quot;，Inner08的n1=&quot;</span> + n1);</span><br><span class="line">            <span class="comment">// 内部类访问外部类同名类时，同样要用Outer08.this的手法来获取</span></span><br><span class="line">            Outer08.<span class="built_in">this</span>.say();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Inner08 <span class="title function_">getInner08Instance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner08</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写一个方法,创建成员内部类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 外部类使用内部类，创建一个成员内部类，然后调用相关的属性和方法</span></span><br><span class="line">        <span class="type">Inner08</span> <span class="variable">inner08</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner08</span>();</span><br><span class="line">        inner08.say();</span><br><span class="line">        System.out.println(inner08.sal);  <span class="comment">// 同一个类中可以访问内部类私有属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-10-6-静态内部类"><a href="#10-10-6-静态内部类" class="headerlink" title="10.10.6 静态内部类"></a>10.10.6 静态内部类</h3><p>本质上是类的一个成员（有static修饰的类，注意普通的类不能被static修饰 ）</p>
<ul>
<li><code>访问权限</code>：可以直接访问外部类的所有成员，包括私有的<ul>
<li>内部类访问外部类成员：<code>直接访问静态成员</code>（如果外部类成员和内部类重名，就近原则访问，要访问外部类成员的话：Outer.n1就可以了）</li>
<li>外部类访问内部类成员：需要<code>创建对象</code>再访问</li>
<li>外部其他类有两种方法访问成员内部类<ul>
<li>第一种是通过外部类直接new：<code>Outer.Inner xxx  = new Outher.Inner();  </code></li>
<li>第二种是通过外部类的方法getInstance访问：<code>new outer().getInnerInstance()</code><ul>
<li>可以编写静态方法：<code>Outer.getInnerInstance()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>修饰符</code>：访问修饰符同类的成员，public protected 默认 private final</li>
<li><code>作用域</code>：定义的整个类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	贾宝玉</span></span><br><span class="line"><span class="comment">    Outer10 cry</span></span><br><span class="line"><span class="comment">    Outer10.name = hsp, Outer10.Inner10.name = 贾宝玉</span></span><br><span class="line"><span class="comment">    ===========outer10.m1()=============</span></span><br><span class="line"><span class="comment">    贾宝玉</span></span><br><span class="line"><span class="comment">    Outer10 cry</span></span><br><span class="line"><span class="comment">    Outer10.name = hsp, Outer10.Inner10.name = 贾宝玉</span></span><br><span class="line"><span class="comment">    ===========[1]new Outer10.Inner10().say()=============</span></span><br><span class="line"><span class="comment">    贾宝玉</span></span><br><span class="line"><span class="comment">    Outer10 cry</span></span><br><span class="line"><span class="comment">    Outer10.name = hsp, Outer10.Inner10.name = 贾宝玉</span></span><br><span class="line"><span class="comment">    ===========[2]new Outer10().getInner10Instance().say()=============</span></span><br><span class="line"><span class="comment">    贾宝玉</span></span><br><span class="line"><span class="comment">    Outer10 cry</span></span><br><span class="line"><span class="comment">    Outer10.name = hsp, Outer10.Inner10.name = 贾宝玉</span></span><br><span class="line"><span class="comment">    ===========[3]Outer10.getInner10Instance_().say()=============</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer10</span> <span class="variable">outer10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer10</span>();</span><br><span class="line">        outer10.m1();</span><br><span class="line">        System.out.println(<span class="string">&quot;===========outer10.m1()=============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用外部其他类 使用静态内部类</span></span><br><span class="line">        <span class="comment">// 方式1</span></span><br><span class="line">        <span class="comment">// 静态内部类可以通过类名直接访问（满足访问权限）</span></span><br><span class="line">        Outer10.<span class="type">Inner10</span> <span class="variable">inner10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer10</span>.Inner10();</span><br><span class="line">        inner10.say();</span><br><span class="line">        System.out.println(<span class="string">&quot;===========[1]new Outer10.Inner10().say()=============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式2</span></span><br><span class="line">        <span class="comment">// 编写一个方法，可以返回静态内部类的对象实例</span></span><br><span class="line">        Outer10.<span class="type">Inner10</span> <span class="variable">inner101</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer10</span>().getInner10Instance();</span><br><span class="line">        inner101.say();</span><br><span class="line">        System.out.println(<span class="string">&quot;===========[2]new Outer10().getInner10Instance().say()=============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 亦可编写静态方法访问静态成员</span></span><br><span class="line">        Outer10.<span class="type">Inner10</span> <span class="variable">inner102</span> <span class="operator">=</span> Outer10.getInner10Instance_();</span><br><span class="line">        inner102.say();</span><br><span class="line">        System.out.println(<span class="string">&quot;===========[3]Outer10.getInner10Instance_().say()=============&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer10</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;hsp&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer10 cry&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="comment">// 1.放在外部类的成员位置</span></span><br><span class="line">    <span class="comment">// 2.使用static修饰</span></span><br><span class="line">    <span class="comment">// 3.可以访问所有静态成员包括私有，但不能直接访问非静态成员</span></span><br><span class="line">    <span class="comment">// 4.可以添加任意访问修饰符(public protected 默认 private)，因为他本质是一个成员</span></span><br><span class="line">    <span class="comment">// 5.作用域：整个类体</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner10</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;贾宝玉&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// (1)静态类只能访问静态成员，不能直接访问非静态成员</span></span><br><span class="line">            <span class="comment">// 内部类访问外部类的成员，直接访问即可</span></span><br><span class="line"><span class="comment">//            System.out.println(n1);</span></span><br><span class="line">            System.out.println(name);</span><br><span class="line">            cry();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 老规矩，内部类和外部类成员重名时，就近原则</span></span><br><span class="line">            <span class="comment">// 访问外部类成员时 用外部类名.成员就可以了，这里是静态的直接类名访问就好了</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Outer10.name = &quot;</span> + Outer10.name +</span><br><span class="line">                    <span class="string">&quot;, Outer10.Inner10.name = &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Inner10 <span class="title function_">getInner10Instance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner10</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Inner10 <span class="title function_">getInner10Instance_</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner10</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 外部类访问内部类的成员，创建对象再访问</span></span><br><span class="line">        <span class="type">Inner10</span> <span class="variable">inner10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner10</span>();</span><br><span class="line">        inner10.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yuezi2048.github.io">yuezi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yuezi2048.github.io/2024/07/14/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/10.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86%EF%BC%89/">https://yuezi2048.github.io/2024/07/14/2.Areas🌐/back-end-java/1.JavaSE/基础篇——韩顺平/10.面向对象编程（高级部分）/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://yuezi2048.github.io" target="_blank">yuezi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/">基础篇——韩顺平</a></div><div class="post-share"><div class="social-share" data-image="/img/touxiang.jpg" data-sites="qq,wechat"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/07/13/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/13.%E5%B8%B8%E7%94%A8%E7%B1%BB/" title="13.常用类"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">13.常用类</div></div><div class="info-2"><div class="info-item-1">十三、常用类13.1 包装类13.1.1 为什么要包装类（接口 方法）针对于八种基本数据类型对应的引用类型——包装类 	 有了包装类，我们就可以调用类的方法	  实现了Comparable接口，就可以进行大小的比较 实现了Serializable接口，就可以串行化数据，后续可以通过文件流，网络传输传输数据了  	 	 	 13.1.2 快速入门包装类和基本数据类型转换以int &lt;-&gt; Integer为例  在jdk5之前（不包括jdk5）都是手动装箱和手动拆箱的 手动装箱：（1）new Integer(n1)  （2）Integer.valueOf(n1) 手动拆箱：integer.intValue();   在jdk5之后，采用自动装箱和自动拆箱的方式 自动装箱：Integer integer2 &#x3D; n2 自动拆箱：n2 &#x3D; integer2  自动装箱底层还是使用的是valueOf()的方法，自动拆箱底层用的是intValue()方法    package com.hspedu.wrapper;/** *...</div></div></div></a><a class="pagination-related" href="/2024/07/16/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/16.%E5%9D%A6%E5%85%8B%E5%A4%A7%E6%88%98%EF%BC%88%E4%B8%8A%EF%BC%89/" title="16.坦克大战（上）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">16.坦克大战（上）</div></div><div class="info-2"><div class="info-item-1">十六、坦克大战（上）16.1 游戏说明			 涉及技术（多思考 多练，从小到大 循序渐进）  OOP 多线程 I&#x2F;O 数据库 项目驱动学习  16.2 绘制坦克16.2.1 前置知识java坐标系是左上角为原点，向右x轴，向下y轴 	 引入像素的概念：  像素是一个密度单位，与长度单位区分开 如800 * 600，表示长为800像素点，高为600像素点组成的屏幕  给出绘制图像的案例  JFrame：窗口，理解为画框 JPanel画板（extends JComponent） JComponent类提供paint(Graphics g)方法绘制图案 自动调用paint的四种情况：（1）第一次屏幕显示；（2）最小化，再最大化；（3）窗口大小变化；（4）调用repaint()方法   Graphics类：提供绘制图案的方法，理解为画笔（见jdk文档） drawLine、drawRect、drawOval、drawRect、drawImage、drawString fillOval、fillRect setFont、setColor    	 	 package...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/05/30/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/02.Java%E6%A6%82%E8%BF%B0/" title="02.Java概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-30</div><div class="info-item-2">02.Java概述</div></div><div class="info-2"><div class="info-item-1">二、Java概述2.1 Java特点2.1.1 Java历史程序：计算机编写的一系列有序指令的集合 诞生历史 	   Java8、Java11为LTS（长久支持版本），重点学习  现使用Sublime感受Java语言学习，巩固一些基础的代码编写与规范，后续使用idea或Eclipse。   2.1.2 Java语言的特点 面向对象（oop） 健壮性（强类型机制、异常处理、垃圾回收） 跨平台（本质上是编译好的class字节码文件可以通过各个操作系统的JVM运行） 解释性语言（同js,php），区别于C&#x2F;C++编译性语言，java编译后的代码不能直接被机器执行，需要jvm来解释，而编译性语言可以。  	 2.1.3 JDK、JRE、JVM*JDK（Java Development kit 开发工具包）  **JDK &#x3D; JRE  + Java开发工具（**包括java、javac、javadoc、javap等） JDK提供给开发人员进行Java开发，JDK本身包含JRE运行环境  JRE（Java Runtime Environment 运行环境）  JRE...</div></div></div></a><a class="pagination-related" href="/2024/11/05/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/01.%E5%86%85%E5%AE%B9%E6%A1%86%E6%9E%B6/" title="01.内容框架"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-05</div><div class="info-item-2">01.内容框架</div></div><div class="info-2"><div class="info-item-1">一、JavaSE内容介绍三个阶段循序渐进学习JavaSE，每个章节课后有面试/联系题 + 讲解，每个阶段结束后用项目检验巩固学习成果。 第一阶段：编程思想(P001 - P373)  第01章 内容介绍(P001 - P006)第02章 Java概述(P007 - P034)第03章 变量(P035 - P062)第04章 运算符(P063 - P103)第05章 程序控制结构(P104 - P155)第06章 数组、排序和查找(P156 - P191)第07章 面向对象编程（基础部分）(P192 - P263)第08章 面向对象编程（中级部分）(P264 - P361)第09章 房屋出租系统(P362 - P373)  第二阶段：编程能力(P374 - P661)  第10章 面向对象编程（高级部分）(P374 - P424)第11章 枚举和注解(P425 - P443)第12章 异常(P444 - P459)第13章 常用类(P460 - P498)第14章 集合(P499 - P553)第15章 泛型(P554 - P568)第16章 坦克大战1(P569 -...</div></div></div></a><a class="pagination-related" href="/2024/05/30/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/03.%E5%8F%98%E9%87%8F/" title="03.变量"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-30</div><div class="info-item-2">03.变量</div></div><div class="info-2"><div class="info-item-1">三、变量3.1 变量入门 为什么要变量 一个程序就是一个世界，每个元素需要由变量来表示   变量是什么 变量组成三要素：类型 + 名称 + 值 类型 - int，名称 - a，值 - 1    public class Test &#123;    public static void main(String[] args) &#123;        int a = 1;        int b = 89;        System.out.println(a + &quot;\n&quot; + b);    &#125;&#125;   变量原理（上述代码为例）：变量名a指向新开辟的4字节内存，内存值为1，b变量同理 变量相当于内存中一个数据存储空间，变量名就是访问这个空间的索引    	    变量demo public class Var02 &#123;	//编写一个 main 方法    public static void main(String[] args) &#123;        //记录人的信息        int age = 30;     ...</div></div></div></a><a class="pagination-related" href="/2024/05/30/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/04.%E8%BF%90%E7%AE%97%E7%AC%A6/" title="04.运算符"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-30</div><div class="info-item-2">04.运算符</div></div><div class="info-2"><div class="info-item-1">四、运算符 算数运算符 赋值运算符 关系运算符（比较运算符） 逻辑运算符 位运算符 三元运算符  4.1 算数运算符	 细节  &#x2F; 号在整数中不保留小数  Java中，a % b 等价于 a - (int) a / b * b  10 % -3 &#x3D; 10 - 10 &#x2F; (-3) * (-3) &#x3D; 10 - 9 &#x3D; 1   重点关注两道面试题（关键点：++是一种自增运算，&#x3D;是一种赋值运算，自增的本质是需要临时变量实现的，之后再赋值操作）  使用内存分析法进行分析，每一步操作对应一个内存中变量值的修改    int i = 1;  // i =&gt; 1i = i ++;  // temp = i = 1 ,i = i + 1 = 2, i =temp = 1System.out.println(i); // 输出1    int i = 1; // i = 1i = ++ i; // i = i + 1 = 2, temp = i = 2, i = temp = 2	System.out.println(i); //...</div></div></div></a><a class="pagination-related" href="/2024/06/01/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/05.%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/" title="05.程序控制结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-01</div><div class="info-item-2">05.程序控制结构</div></div><div class="info-2"><div class="info-item-1">五、程序控制结构5.1 顺序控制	  细节  顺序控制中的变量需要前向引用  5.2 分支控制5.2.1 if-else 单分支 if 双分支 If-else 多分支 if-else if -else  	 细节  每个条件表达式都会走，直到有一个满足的，才会执行后面的代码块 可以没有else，此时if-else没有执行入口 最多只有一个执行入口  关注一个代码 boolean b = true;if (b=false) System.out.println(&quot;a&quot;);else if (b) System.out.println(&quot;b&quot;);else if (!b) System.out.println(&quot;c&quot;);  // 输出此代码块else System.out.println(&quot;d&quot;);    5.2.2 嵌套分支 建议嵌套不要超过3层，否则可读性很差 判断好某个条件，需要进一步判断各种情况下使用  	 5.2.3 switch快速入门 switch(表达式) &#123;    case...</div></div></div></a><a class="pagination-related" href="/2024/07/06/2.Areas%F0%9F%8C%90/back-end-java/1.JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87%E2%80%94%E2%80%94%E9%9F%A9%E9%A1%BA%E5%B9%B3/06.%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/" title="06.数组、排序和查找"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-06</div><div class="info-item-2">06.数组、排序和查找</div></div><div class="info-2"><div class="info-item-1">六、数组、排序和查找6.1 数组使用为什么要数组：6只鸡，每只鸡的体重3kg,5kg,1kg,3.4kg,2kg,50kg ，问你平均体重怎么算？  没有数组我们只能通过定义6个变量，引申到1w只鸡就不太合适了 引申出数组，用来存放多个相同类型的数据 注：数组是一种引用类型    public class Array01 &#123;	public static void main(String[] args) &#123;		double[] hens = &#123;1, 2, 3&#125;;		double totalWeight = 0;		for (int i = 0; i &lt; hens.length; i ++ ) &#123;			System.out.println(&quot;第&quot; + (i + 1) + &quot;个元素是&quot; + hens[i]);			totalWeight += hens[i];		&#125;		System.out.println(&quot;平均体重是&quot; + (totalWeight /...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yuezi</div><div class="author-info-description">积微者速成</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">603</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuezi2048"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">积微者速成</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86%EF%BC%89"><span class="toc-text">十、面向对象编程（高级部分）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-text">10.1 类变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%B1%BB%E5%8F%98%E9%87%8F%EF%BC%88%E5%85%AC%E5%85%B1%E8%AE%BF%E9%97%AE%EF%BC%89"><span class="toc-text">10.1.1 为什么要类变量（公共访问）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">10.1.2 快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-3-%E7%B1%BB%E5%8F%98%E9%87%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">10.1.3 类变量内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-4-%E7%BB%86%E8%8A%82%E2%80%94%E2%80%94%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E8%AE%BF%E9%97%AE"><span class="toc-text">10.1.4 细节——类变量的加载和访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">10.2 类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-1-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">10.2.1 快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-2-%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B8%A4%E4%B8%AA%E7%BB%8F%E5%85%B8%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">10.2.2 类方法两个经典使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-2-%E7%BB%86%E8%8A%82%E2%80%94%E2%80%94%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E8%B0%83%E7%94%A8"><span class="toc-text">10.2.2 细节——类方法的加载和调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-main%E7%B1%BB%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-text">10.3 main类方法结构分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">10.4 代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%88%E6%9E%84%E9%80%A0%E5%99%A8%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">10.4.1 为什么要代码块（构造器补充）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">10.4.2 快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-3-%E7%BB%86%E8%8A%821%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E5%92%8C%E6%99%AE%E9%80%9A%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">10.4.3 细节1——静态和普通代码块的加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-4-%E7%BB%86%E8%8A%822%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="toc-text">10.4.4 细节2——创建对象一个类调用顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-5-%E7%BB%86%E8%8A%823%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E7%B1%BB%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="toc-text">10.4.5 细节3——创建对象继承类调用顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-%E9%9D%99%E6%80%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">10.5 静态应用——单例设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%8E%84%E6%9C%BA%EF%BC%89"><span class="toc-text">10.5.1 为什么要有设计模式（玄机）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-2-%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-text">10.5.2 饿汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-3-%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-text">10.5.3 懒汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-4-%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%92%8C%E6%87%92%E6%B1%89%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-text">10.5.4 饿汉式和懒汉式对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">10.6 final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81final%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E7%B1%BB%E6%88%90%E5%91%98%E9%9C%80%E6%B1%82%EF%BC%89"><span class="toc-text">10.6.1 为什么要final关键字（类成员需求）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">10.6.2 快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-3-%E7%BB%86%E8%8A%82%E2%80%94%E2%80%94final%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-text">10.6.3 细节——final的赋值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-7-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">10.7 抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E4%B8%8D%E7%A1%AE%E5%AE%9A%E7%9A%84%E7%BB%99%E5%AD%90%E7%B1%BB%EF%BC%89"><span class="toc-text">10.7.1 为什么要抽象类（不确定的给子类）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">10.7.2 快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-3-%E7%BB%86%E8%8A%821%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%80%A7"><span class="toc-text">10.7.3 细节1——抽象类的抽象性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-4-%E7%BB%86%E8%8A%822%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%92%8C%E5%AD%90%E7%B1%BB%E5%AE%9E%E7%8E%B0"><span class="toc-text">10.7.4 细节2——抽象类的成员和子类实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-8-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">10.8 抽象类应用——模板设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-8-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%80%A6%EF%BC%89"><span class="toc-text">10.8.1 为什么要模板设计（代码解耦）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-8-2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">10.8.2 快速入门</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-9-%E6%8E%A5%E5%8F%A3"><span class="toc-text">10.9 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-9-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%AE%9A%E4%B9%89%E8%A7%84%E8%8C%83%E7%BB%9F%E4%B8%80%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-text">10.9.1 为什么要接口（定义规范统一方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-9-2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">10.9.2 快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-9-3-%E7%BB%86%E8%8A%821%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%80%A7"><span class="toc-text">10.9.3 细节1——接口的抽象性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-9-4-%E7%BB%86%E8%8A%822%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%9D%99%E6%80%81final%E5%B1%9E%E6%80%A7"><span class="toc-text">10.9.4 细节2——接口的静态final属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-9-5-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3-vs-%E7%BB%A7%E6%89%BF%E7%B1%BB%EF%BC%88%E8%A1%A5%E5%85%85%E5%85%B3%E7%B3%BB%EF%BC%89"><span class="toc-text">10.9.5 实现接口 vs 继承类（补充关系）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-9-6-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-text">10.9.6 接口的多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">多态数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-text">多态参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E4%BC%A0%E9%80%92"><span class="toc-text">多态传递</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-9-7-%E6%8E%A5%E5%8F%A3%E5%A4%9A%E6%80%81%E2%80%94%E2%80%94%E5%94%90%E5%83%A7%E4%BD%BF%E7%94%A8%E4%BA%A4%E9%80%9A%E5%B7%A5%E5%85%B7"><span class="toc-text">10.9.7 接口多态——唐僧使用交通工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-10-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">10.10 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-10-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E7%B1%BB%E7%9A%84%E5%8C%85%E5%90%AB%E5%85%B3%E7%B3%BB%EF%BC%89"><span class="toc-text">10.10.1 为什么要内部类（类的包含关系）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-10-2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">10.10.2 快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-10-3-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">10.10.3 局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-10-4-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">10.10.4 *匿名内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E2%80%94%E2%80%94%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">细节——匿名内部类的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%BD%9C%E4%B8%BA%E5%AE%9E%E5%8F%82%E4%BC%A0%E9%80%92"><span class="toc-text">应用——匿名内部类作为实参传递</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-10-5-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">10.10.5 成员内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-10-6-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">10.10.6 静态内部类</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/Excalidraw/Drawing%202024-11-01%2015.37.37.excalidraw/" title="Drawing 2024-11-01 15.37.37.excalidraw">Drawing 2024-11-01 15.37.37.excalidraw</a><time datetime="2025-10-31T04:19:26.621Z" title="发表于 2025-10-31 12:19:26">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/01.project/condefather/yupao/back-end/7.%E4%BC%98%E5%8C%96%E4%B8%BB%E9%A1%B5%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/" title="7.优化主页性能-优化批量导入数据">7.优化主页性能-优化批量导入数据</a><time datetime="2025-10-31T04:19:26.102Z" title="发表于 2025-10-31 12:19:26">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/81.%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B8%E6%A0%87Cursor%E5%88%86%E9%A1%B5_%E5%AF%B9%E6%AF%94%E4%BC%A0%E7%BB%9FLIMIT_OFFSET%E5%88%86%E9%A1%B5%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88/" title="81.什么是游标Cursor分页_对比传统LIMIT_OFFSET分页的优势是什么">81.什么是游标Cursor分页_对比传统LIMIT_OFFSET分页的优势是什么</a><time datetime="2025-10-31T04:14:27.000Z" title="发表于 2025-10-31 12:14:27">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/80.%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E5%90%84%E8%87%AA%E4%BC%98%E7%BC%BA%E7%82%B9/" title="80.全量同步和增量同步各自优缺点">80.全量同步和增量同步各自优缺点</a><time datetime="2025-10-31T04:13:32.000Z" title="发表于 2025-10-31 12:13:32">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/79.%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93_%E7%9B%B8%E6%AF%94%E5%8D%95%E6%9D%A1%E6%8F%92%E5%85%A5%E4%BC%98%E5%8A%BF/" title="79.什么是批量数据入库_相比单条插入优势">79.什么是批量数据入库_相比单条插入优势</a><time datetime="2025-10-31T04:03:26.000Z" title="发表于 2025-10-31 12:03:26">2025-10-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/default.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By yuezi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>