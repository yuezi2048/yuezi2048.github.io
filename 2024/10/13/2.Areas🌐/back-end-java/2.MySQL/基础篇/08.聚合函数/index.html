<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>08.聚合函数 | yuezi</title><meta name="author" content="yuezi"><meta name="copyright" content="yuezi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="八、聚合函数1. 聚合函数1.1 聚合函数概述聚合函数：一组函数返回一个值，作用于一组数据 	 聚合函数语法 	  注：聚合函数不能嵌套调用。比如不能出现类似“AVG(SUM(字段名称))”形式的调用。  1.2 常见聚合函数类型聚合函数类型  AVG()  SUM() MAX()  MIN()  **COUNT() ** 方差 标准差 中位数等等…  # 1. 常见的聚集函数# 1.1 AVG">
<meta property="og:type" content="article">
<meta property="og:title" content="08.聚合函数">
<meta property="og:url" content="https://yuezi2048.github.io/2024/10/13/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/08.%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/index.html">
<meta property="og:site_name" content="yuezi">
<meta property="og:description" content="八、聚合函数1. 聚合函数1.1 聚合函数概述聚合函数：一组函数返回一个值，作用于一组数据 	 聚合函数语法 	  注：聚合函数不能嵌套调用。比如不能出现类似“AVG(SUM(字段名称))”形式的调用。  1.2 常见聚合函数类型聚合函数类型  AVG()  SUM() MAX()  MIN()  **COUNT() ** 方差 标准差 中位数等等…  # 1. 常见的聚集函数# 1.1 AVG">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuezi2048.github.io/img/touxiang.jpg">
<meta property="article:published_time" content="2024-10-13T14:22:00.000Z">
<meta property="article:modified_time" content="2024-10-13T14:22:00.000Z">
<meta property="article:author" content="yuezi">
<meta property="article:tag" content="基础篇">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuezi2048.github.io/img/touxiang.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "08.聚合函数",
  "url": "https://yuezi2048.github.io/2024/10/13/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/08.%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/",
  "image": "https://yuezi2048.github.io/img/touxiang.jpg",
  "datePublished": "2024-10-13T14:22:00.000Z",
  "dateModified": "2024-10-13T14:22:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "yuezi",
      "url": "https://yuezi2048.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuezi2048.github.io/2024/10/13/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/08.%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?bfb48b678d82bea9f9cc9d59227767e4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"FPH6F2TOJL","apiKey":"06d9ea26c803ba912b4d8e13404ed34d","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '08.聚合函数',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/backgound.css"><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">603</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yuezi</span></a><a class="nav-page-title" href="/"><span class="site-name">08.聚合函数</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">08.聚合函数</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-13T14:22:00.000Z" title="发表于 2024-10-13 22:22:00">2024-10-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-13T14:22:00.000Z" title="更新于 2024-10-13 22:22:00">2024-10-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/back-end-java/">back-end-java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/back-end-java/2-MySQL/">2.MySQL</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/back-end-java/2-MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/">基础篇</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="八、聚合函数"><a href="#八、聚合函数" class="headerlink" title="八、聚合函数"></a>八、聚合函数</h1><h2 id="1-聚合函数"><a href="#1-聚合函数" class="headerlink" title="1. 聚合函数"></a>1. 聚合函数</h2><h3 id="1-1-聚合函数概述"><a href="#1-1-聚合函数概述" class="headerlink" title="1.1 聚合函数概述"></a>1.1 聚合函数概述</h3><p>聚合函数：一组函数返回一个值，作用于一组数据</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240814162907695.png" alt="image-20240814162907695">	</p>
<p>聚合函数语法</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240814162928957.png" alt="image-20240814162928957">	</p>
<blockquote>
<p>注：聚合函数不能<strong>嵌套调用</strong>。比如不能出现类似“AVG(SUM(字段名称))”形式的调用。</p>
</blockquote>
<h3 id="1-2-常见聚合函数类型"><a href="#1-2-常见聚合函数类型" class="headerlink" title="1.2 常见聚合函数类型"></a>1.2 常见聚合函数类型</h3><p><strong>聚合函数类型</strong></p>
<ul>
<li><strong>AVG()</strong> </li>
<li><strong>SUM()</strong></li>
<li><strong>MAX()</strong> </li>
<li><strong>MIN()</strong> </li>
<li>**COUNT() **</li>
<li>方差 标准差 中位数等等…</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1. 常见的聚集函数</span><br><span class="line"># 1.1 AVG / SUM( 空值也会过滤掉 )</span><br><span class="line">SELECT AVG(salary), SUM(salary), AVG(salary) * 107</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">-- 用于数值类型求，以下操作没有意义</span><br><span class="line">SELECT SUM(last_name), SUM(hire_date)</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 1.2 MAX / MIN(数值、字符串、日期类型)</span><br><span class="line">SELECT MAX(salary), MIN(salary)</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">-- 字符串和日期可以比较大小，以下操作是可以</span><br><span class="line">SELECT MAX(last_name), MIN(last_name) MAX(hire_date), MIN(hire_date)</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line"># 1.3 COUNT：</span><br><span class="line">-- 作用：计算指定字段在查询结构中的个数（不包含null）</span><br><span class="line">-- count(1) 理解：选中该记录，但没有指名具体字段，使用常量充当（数人头的例子）</span><br><span class="line"></span><br><span class="line">SELECT COUNT(employee_id), COUNT(salary), COUNT(salary * 3), </span><br><span class="line">COUNT(1), COUNT(100), COUNT(*)</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">-- 实现计算表中有多少条记录</span><br><span class="line">-- 方式1：COUNT(*)</span><br><span class="line">-- 方式2：COUNT(1)</span><br><span class="line">-- 方式3：COUNT(具体字段)，不一定能确定！因为他不计算字段的空值</span><br><span class="line">SELECT COUNT(commission_pct)</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-AVG使用注意事项"><a href="#1-3-AVG使用注意事项" class="headerlink" title="1.3 AVG使用注意事项"></a>1.3 AVG使用注意事项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 公式 AVG = SUM / COUNT</span><br><span class="line">SELECT AVG(salary), SUM(salary) / COUNT(salary),</span><br><span class="line">AVG(commission_pct), SUM(commission_pct) / COUNT(commission_pct), SUM(commission_pct) / 107</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">-- 需求：查询公司平均奖金率(需要考虑没有的)</span><br><span class="line">-- 错误写法</span><br><span class="line">SELECT AVG(commission_pct)</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">-- 正确写法 </span><br><span class="line">SELECT SUM(commission_pct) / COUNT(*),</span><br><span class="line"># SUM(commission_pct) / COUNT(IFNULL(commission_pct, 0))</span><br><span class="line"># AVG(IFNULL(commission_pct), 0)</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>



<h3 id="1-4-COUNT的使用效率分析"><a href="#1-4-COUNT的使用效率分析" class="headerlink" title="1.4 COUNT的使用效率分析"></a>1.4 COUNT的使用效率分析</h3><p>如果需要统计统计表的记录数，从优化的角度哪一种效率最高？</p>
<ul>
<li>MyISAM存储引擎，统计都是O(1)时间复杂度，三者一样，数据表有一个专门的meta计数器存储信息</li>
<li>InnoDB存储引擎，是一个个数过去的，复杂度为O(n)，效率：count(*) &#x3D; count(1) &gt; count(字段)，，由于前者使用了二级索引，所以会快一些，见下篇内容<ul>
<li>count(*) 是 SQL92 定义的标准统计行数的语法，与是否为NULL无关</li>
<li>即count(*)会统计值为NULL的行，需要结合实际情况使用</li>
</ul>
</li>
</ul>
<h2 id="2-GROUP-BY"><a href="#2-GROUP-BY" class="headerlink" title="2. GROUP BY"></a>2. GROUP BY</h2><p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240814163900802.png" alt="image-20240814163900802">	</p>
<p>使用GROUP BY子句将数据分成若干组</p>
<ul>
<li>可以使用多个列分组，顺序无所谓，含义一样</li>
<li>GROUP BY 可以出现SELECT没有的，而SELECT不能出现GROUP BY 没有的</li>
<li>GROUP BY可以使用WITH ROLLUP表示将整个数据当成一组再处理一份，此时不能用ORDER BY<ul>
<li>补充：若有多个字段，在WITH ROLLUP的基础上，可配合IFNULL使用，比如想在最后一行加上整体的相关聚合函数值</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 2. group by使用</span><br><span class="line"># 需求：查询各个部门的平均工资/最高工资(为null的自成一组)</span><br><span class="line">SELECT department_id, COUNT(*), AVG(salary), SUM(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line"># 需求2：查询各个job_id的平均工资</span><br><span class="line">SELECT job_id, AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id;</span><br><span class="line"></span><br><span class="line"># 需求3：查询各个department下每个job的平均工资</span><br><span class="line">SELECT department_id, job_id, AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id, job_id;</span><br><span class="line"># 等价写法：各个job下的department</span><br><span class="line">SELECT department_id, job_id, AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id, department_id;</span><br><span class="line"></span><br><span class="line"># 错误写法：Expression #2 of SELECT list is not in GROUP BY clause </span><br><span class="line">SELECT department_id, job_id, AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line">-- 结论1：SELECT中出现的非组函数字段必须声明在GROUP BY中，反之GROUP BY声明的字段可以不在SELECT中</span><br><span class="line">-- 结论2：GROUP BY声明在FROM 后面，WHERE的后面 ORDER BY前面，LIMIT前面</span><br><span class="line">-- 结论3：MYSQL中使用GROUP BY使用WITH ROLLUP, 会把一整个数据作为一组来显示，和order by是互相排斥的</span><br><span class="line">SELECT department_id, AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id WITH ROLLUP;</span><br><span class="line"></span><br><span class="line"># 正确实现：查询各个部门平均工资，按照平均工资升序排列</span><br><span class="line"># 错误实现：加上WITH ROLLUP,会加上整个公司的平均工资，而不是某一组的公司 不适合参与排序</span><br><span class="line">SELECT department_id, AVG(salary) avg_sal</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"># GROUP BY department_id WITH ROLLUP</span><br><span class="line">ORDER BY avg_sal ASC;</span><br></pre></td></tr></table></figure>



<h2 id="3-HAVING"><a href="#3-HAVING" class="headerlink" title="3. HAVING"></a>3. HAVING</h2><h3 id="3-1-HAVING的规则"><a href="#3-1-HAVING的规则" class="headerlink" title="3.1 HAVING的规则"></a>3.1 HAVING的规则</h3><p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240814164550776.png" alt="image-20240814164550776">	</p>
<p><strong>过滤分组：HAVING子句</strong></p>
<ol>
<li>行已经被分组。</li>
<li>使用了聚合函数。</li>
<li>满足HAVING 子句中条件的分组将被显示。</li>
<li>HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 3. having的使用（用于过滤数据）</span><br><span class="line"># 需求：查询各个部门最高工资比10000高的部门信息</span><br><span class="line"># 错误写法：WHERE不能用聚合函数</span><br><span class="line">SELECT department_id, MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE MAX(salary) &gt; 10000</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line"># 正确写法:一旦过滤条件中出现聚合函数</span><br><span class="line"># (1)必须声明HAVING；</span><br><span class="line"># (2)声明在GROUP BY后面（涉及MYSQL的执行过程）</span><br><span class="line">SELECT department_id, MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MAX(salary) &gt; 10000;</span><br><span class="line"></span><br><span class="line"># (3) 没有分组GROUP BY使用HAVING意义不大</span><br><span class="line"># 开发中，使用HAVING前提：使用了GROUP BY</span><br><span class="line">-- 不建议的写法</span><br><span class="line">SELECT MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">HAVING MAX(salary) &gt; 10000;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-HAVING-vs-WHERE"><a href="#3-2-HAVING-vs-WHERE" class="headerlink" title="3.2 HAVING vs WHERE"></a>3.2 HAVING vs WHERE</h3><p>区别1：<code>聚合函数</code>的使用场景</p>
<ul>
<li>WHERE可以筛选表中的字段，但不能使用分组的聚合函数</li>
<li>而HAVING是需要配合GROUP BY使用，将分组计算的函数和分组字段作为筛选条件</li>
</ul>
<p>说明：在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务，是WHERE的筛选补充机制。</p>
<p>区别2：<code>关联查询</code>效率</p>
<ul>
<li>关联查询时，WHERE是先筛选再连接，而HAIVNG是先连接再筛选</li>
</ul>
<p>说明：在关联查询上，WHERE比HAINVG高效，WHERE先得到较小的数据集和关联表再连接，占用资源就少，效率就高，HAIVNG则相反。</p>
<p>小结如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>WHERE</td>
<td>先筛选数据再关联，执行效率高</td>
<td>不能使用分组中的计算函数进行筛选</td>
</tr>
<tr>
<td>HAVING</td>
<td>可以使用分组中的计算函数</td>
<td>在最后的结果集中进行筛选，执行效率较低</td>
</tr>
</tbody></table>
<p><strong>开发中的选择：</strong></p>
<p>WHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用 WHERE 和 HAVING。</p>
<ul>
<li><p>我们可以在使用分组统计函数时放在 HAVING，普通条件用 WHERE。</p>
</li>
<li><p>既发挥了WHERE在关联查询的效率，又能保证分组统计函数的使用</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查询：部门id为10 20 30 40四个部门大于10000的信息</span><br><span class="line">-- 方式1:推荐（执行效率高）</span><br><span class="line">SELECT department_id, MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id IN (10, 20, 30, 40)</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MAX(salary) &gt; 10000;</span><br><span class="line"></span><br><span class="line">-- 方式2</span><br><span class="line">SELECT department_id, MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING department_id IN (10, 20, 30, 40)</span><br><span class="line">AND MAX(salary) &gt; 10000;</span><br><span class="line"></span><br><span class="line">-- 结论：当过滤条件中有聚合函数时，此过滤条件必须声明在HAVING中</span><br><span class="line">-- 当过滤条件中没有聚合函数时，可以写在where中（建议），也可以在HAVING中</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">  WHERE 和 HAVING 比较</span><br><span class="line">   1. 适用范围:HAVING适用范围更广</span><br><span class="line">   2. 如果过滤条件中没有聚合函数：where执行效率高于having（WHERE先筛选后连接，HAVING先连接再筛选）</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>



<h2 id="4-SELECT执行过程"><a href="#4-SELECT执行过程" class="headerlink" title="4. SELECT执行过程"></a>4. SELECT执行过程</h2><p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240814165700048.png" alt="image-20240814165700048">		</p>
<p>在连接操作时，可以细分为三个生成虚拟表的步骤</p>
<ol>
<li>首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；</li>
<li>通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；</li>
<li>添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 4. SQL底层执行原理</span><br><span class="line"># 4.1 SELECT语句的完整结构</span><br><span class="line">/*</span><br><span class="line">SQL92</span><br><span class="line">SELECT ...,...,...(聚合函数)</span><br><span class="line">FROM ...,...(多表查询)</span><br><span class="line">WHERE ... = ...(多表连接条件) AND ...(过滤条件 不包含聚合函数)</span><br><span class="line">GROUP BY ... (分组)</span><br><span class="line">HAVING ..(过滤条件 包含聚合函数)</span><br><span class="line">ORDER BY ... ASC / DESC</span><br><span class="line">LIMIT ..,..</span><br><span class="line"></span><br><span class="line">SQL 99</span><br><span class="line">SELECT ...,...,...(聚合函数)</span><br><span class="line">FROM ...(LEFT/RIGHT) JOIN...(多表查询) ON ... = ...(多表连接条件)</span><br><span class="line">(LEFT/RIGHT)JOIN ... ON ...</span><br><span class="line">WHERE ...(过滤条件 不包含聚合函数)</span><br><span class="line">GROUP BY ... (分组)</span><br><span class="line">HAVING ..(过滤条件 包含聚合函数)</span><br><span class="line">ORDER BY ... ASC / DESC</span><br><span class="line">LIMIT ..,..</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"># 4.2 SQL语句执行过程（每一步都是有虚拟表操作）</span><br><span class="line"># FROM ..,.. -&gt; ON(CROSS JOIN) --&gt; (LEFT/RIGHT JOIN) --&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT</span><br><span class="line">SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5</span><br><span class="line">FROM player JOIN team ON player.team_id = team.team_id # 顺序 1</span><br><span class="line">WHERE height &gt; 1.80 # 顺序 2</span><br><span class="line">GROUP BY player.team_id # 顺序 3</span><br><span class="line">HAVING num &gt; 2 # 顺序 4</span><br><span class="line">ORDER BY num DESC # 顺序 6</span><br><span class="line">LIMIT 2 # 顺序 7</span><br></pre></td></tr></table></figure>



<h2 id="5-课后练习"><a href="#5-课后练习" class="headerlink" title="5. 课后练习"></a>5. 课后练习</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># chaprter08 exercise</span><br><span class="line"></span><br><span class="line">#1.where子句可否使用组函数进行过滤?</span><br><span class="line"># no，使用having来对组函数过滤，非组函数使用where</span><br><span class="line"></span><br><span class="line">#2.查询公司员工工资的最大值，最小值，平均值，总和</span><br><span class="line">SELECT MAX(salary) max_salary, MIN(salary) min_salary, SUM(salary) sum_salary</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#3.查询各job_id的员工工资的最大值，最小值，平均值，总和</span><br><span class="line">SELECT job_id, MAX(salary), MIN(salary), SUM(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id;</span><br><span class="line"></span><br><span class="line">#4.选择具有各个job_id的员工人数</span><br><span class="line">SELECT job_id, COUNT(*)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id;</span><br><span class="line"></span><br><span class="line">#5.查询员工最高工资和最低工资的差距(DIFFERENCE)</span><br><span class="line">SELECT MAX(salary) - MIN(salary) &quot;DIFFERENCE&quot;</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#6.查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内</span><br><span class="line">SELECT manager_id , MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE manager_id IS NOT NULL</span><br><span class="line">GROUP BY manager_id</span><br><span class="line">HAVING MIN(salary) &gt;= 6000</span><br><span class="line">ORDER BY manager_id;</span><br><span class="line"></span><br><span class="line">#7.查询所有部门的名字，1ocation_id，员工数量和平均工资，并按平均工资降序</span><br><span class="line">-- 因为涉及到所有部门，所以要用外连接，左连接比较多</span><br><span class="line">-- 这里会有一个bug：对于没有员工的部门，使用count(*)会有一个本身带null的记录，所以显示数量为1，而不是0，这里得用具体字段来执行了</span><br><span class="line">SELECT d.department_name, d.location_id, COUNT(employee_id), AVG(e.salary) &quot;avg_sal&quot;</span><br><span class="line">FROM departments d LEFT JOIN employees e</span><br><span class="line">ON d.department_id = e.department_id</span><br><span class="line">GROUP BY d.department_id, location_id</span><br><span class="line">order by avg_sal desc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#8.查询每个工种、每个部门的部门名、工种名和最低工资</span><br><span class="line">SELECT e.job_id, d.department_name, MIN(e.salary)</span><br><span class="line">FROM departments d LEFT JOIN employees e </span><br><span class="line">ON d.department_id = e.department_id</span><br><span class="line">GROUP BY e.job_id, d.department_id</span><br><span class="line">ORDER BY job_id;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yuezi2048.github.io">yuezi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yuezi2048.github.io/2024/10/13/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/08.%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/">https://yuezi2048.github.io/2024/10/13/2.Areas🌐/back-end-java/2.MySQL/基础篇/08.聚合函数/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://yuezi2048.github.io" target="_blank">yuezi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%AF%87/">基础篇</a></div><div class="post-share"><div class="social-share" data-image="/img/touxiang.jpg" data-sites="qq,wechat"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/13/2.Areas%F0%9F%8C%90/back-end-java/3.JDBC/3.%E9%AB%98%E7%BA%A7%E7%AF%87_%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B0%81%E8%A3%85_%E6%A0%87%E8%AF%86%E8%BF%9E%E6%8E%A5/" title="3.高级篇_工具类封装_标识连接"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">3.高级篇_工具类封装_标识连接</div></div><div class="info-2"><div class="info-item-1">高级篇一、JDBC优化和工具类封装1.1 存在的问题我们发现，虽然连接池解决了用户频繁请求释放连接造成的资源浪费，但有这些问题：  用户连接一次就要写 创建连接池、建立连接、连接回收的代码，存在代码冗余的问题 —&gt; 工具类封装 用户频繁连接，会对应连接池不同的新连接，在使用事务时，用户无法保证事务的正常提交 -&gt; 怎么让用户线程在一段时间内标识唯一的连接？ –&gt; map  1.2...</div></div></div></a><a class="pagination-related" href="/2024/10/13/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/11.%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9/" title="11.数据的增删改"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">11.数据的增删改</div></div><div class="info-2"><div class="info-item-1">十一、数据的增删改# 0. 储备工作USE atguigudb;CREATE TABLE IF NOT EXISTS emp1(id INT,`name` VARCHAR(15),hire_date DATE,salary DOUBLE(10, 2));DESC emp1;SELECT * FROM emp1;    1. 插入数据1.1 方式1：VALUES ① 没有指明，默认按照声明顺序 ② 指明添加的字段（推荐），其他没有声明的字段为默认值（注意约束的条件） ③ 可以同时插入多条字段，用逗号隔开（推荐）  # 1. 添加数据# 方式1：一条一条加# ① 没有指明添加的字段（此时必须要按照声明的先后顺序添加）INSERT INTO emp1VALUES (1, &#x27;Tom&#x27;, &#x27;2000-12-21&#x27;, 3400);# ② 指明要添加的字段（推荐 可以不加一些字段，当然在没有约束等条件下）INSERT INTO emp1(id, hire_date, salary, `name`)VALUES (2,...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/08/14/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/00.%E5%9F%BA%E7%A1%80%E7%AF%87%E5%86%85%E5%AE%B9%E6%A1%86%E6%9E%B6/" title="00.基础篇内容框架"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-14</div><div class="info-item-2">00.基础篇内容框架</div></div><div class="info-2"><div class="info-item-1">MySQL数据库基础篇分为5个篇章： 1. 数据库概述与MySQL安装篇  第01章：数据库概述 第02章：MySQL环境搭建  2. SQL之SELECT使用篇  第03章：基本的SELECT语句 第04章：运算符 第05章：排序与分页 第06章：多表查询 第07章：单行函数 第08章：聚合函数 第09章：子查询  3. SQL之DDL、DML、DCL使用篇  第10章：创建和管理表 第11章：数据处理之增删改 第12章：MySQL数据类型精讲 第13章：约束  4. 其它数据库对象篇（开发用到了再学）  第14章：视图 第15章：存储过程与函数 第16章：变量、流程控制与游标 第17章：触发器  5. MySQL8 新特性篇（开发用到了再学）  第18章：MySQL8其它新特性  ps：普通开发往往积累单点技术、比如 CRUD、锁类型、索引的数据结构… 而对于技术骨干、架构师则往往需要对底层原理吃透：  数据库事务 ACID...</div></div></div></a><a class="pagination-related" href="/2024/08/14/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/" title="01.数据库概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-14</div><div class="info-item-2">01.数据库概述</div></div><div class="info-2"><div class="info-item-1">一、数据库概述1. 为什么要数据库 数据的持久化：将数据保存到硬盘上，可供可掉电式的存储设备使用，大多使用关系数据库实现（也可以通过文件I&#x2F;O、XML实现）  	 2. DB 和 DBMS2.1 概述 数据库DB：存储数据的仓库，本质上是一个文件系统，保存一系列有组织的数据 数据库管理系统DBMS：管理和操纵数据库的大型软件，从而建立、使用和维护数据库。用户可以使用DBMS查询数据库的数据 结构化查询语言SQL：用于数据库交互的语言  其中，DBMS可以管理多个DB，开发中，通常针对每个应用创建一个数据库，并在一个数据库中创建多个表，从而保存实体用户的数据 	 2.2 常见DBMS常见的DBMS 参考数据库最新排名:https://db-engines.com/en/ranking 	 发展趋势：https://db-engines.com/en/ranking_trend 	 Oracle 1979 年，Oracle 2 诞生，它是第一个商用的 RDBMS（关系型数据库管理系统）。随着 Oracle 软件的名气越来越大，公司也改名叫 Oracle...</div></div></div></a><a class="pagination-related" href="/2025/05/25/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/02.MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="02.MySQL环境搭建"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-25</div><div class="info-item-2">02.MySQL环境搭建</div></div><div class="info-2"><div class="info-item-1">二、MySQL环境搭建1. 清除原有MySQL环境Step1：停止MySQL服务 	 Step2：软件卸载  亦可通过mysql-installer-community-8.0.26.0.msi卸载，此时安装目录也会被移除  	 Step3：残余文件清理 如果再次安装不成功，可以卸载后对残余文件进行清理后再安装。 （1）服务目录：mysql服务的安装目录 （2）数据目录：默认在C:\ProgramData\MySQL 注意：请在卸载前做好数据备份 在操作完以后，需要重启计算机，然后进行安装即可。如果仍然安装失败，需要继续操作如下步骤4。 Step4：清理注册表 在系统的搜索框中输入regedit HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL服务 目录删除HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\MySQL服务...</div></div></div></a><a class="pagination-related" href="/2024/08/16/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/03.%E5%9F%BA%E6%9C%ACSELECT%E8%AF%AD%E5%8F%A5/" title="03.基本SELECT语句"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-16</div><div class="info-item-2">03.基本SELECT语句</div></div><div class="info-2"><div class="info-item-1">三、基本SELECT语句1. SQL概述1.1 SQL背景 1946 年，世界上第一台电脑诞生，如今，借由这台电脑发展起来的互联网已经自成江湖。在这几十年里，无数的技术、产业在这片江湖里沉浮，有的方兴未艾，有的已经几幕兴衰。但在这片浩荡的波动里，有一门技术从未消失，甚至“老当益壮”，那就是 SQL。  45 年前，也就是 1974 年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语言，SQL 的半衰期可以说是非常长了。   不论是前端工程师，还是后端算法工程师，都一定会和数据打交道，都需要了解如何又快又准确地提取自己想要的数据。更别提数据分析师了，他们的工作就是和数据打交道，整理不同的报告，以便指导业务决策。  SQL（Structured Query...</div></div></div></a><a class="pagination-related" href="/2025/04/24/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/04.%E8%BF%90%E7%AE%97%E7%AC%A6/" title="04.运算符"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-24</div><div class="info-item-2">04.运算符</div></div><div class="info-2"><div class="info-item-1">四、运算符1. 算数运算符算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（*）、除（&#x2F;）和取模（%）运算。 1.1 加减法# 算数运算符：+ - * / div % mod SELECT 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 - 30, 100 + 35.5, 100 - 35.5FROM DUAL;+-----+---------+---------+----------+--------------+------------+------------+| 100 | 100 + 0 | 100 - 0 | 100 + 50 | 100 + 50 -30 | 100 + 35.5 | 100 - 35.5 |+-----+---------+---------+----------+--------------+------------+------------+| 100 |     100 |     100 |      150 |         ...</div></div></div></a><a class="pagination-related" href="/2025/05/28/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/05.%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E9%A1%B5/" title="05.排序和分页"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-28</div><div class="info-item-2">05.排序和分页</div></div><div class="info-2"><div class="info-item-1">五、排序和分页1. 排序1.1 单列排序 使用 ORDER BY 子句排序 ASC（ascend）: 升序 DESC（descend）:降序   ORDER BY 子句在SELECT语句的结尾。 关注SELECT查询的顺序，实际场景：别名不能在where从句中使用，而可以在order by中使用  # 1. 一级排序# 如果没有使用排序操作，默认情况下查询返回的数据按照添加数据的顺序SELECT * FROM employees;-- 1.1 基本使用# 练习：按照salary从高到低显示数据(ORDER BY 通过什么来排序)# 升序:ASC(ascend) 降序：DESC(descend)SELECT employee_id, last_name, salaryFROM employeesORDER BY salary DESC;# 从低到高(没有显式写，默认升序)SELECT employee_id, last_name, salaryFROM employeesORDER BY salary ASC;-- 2. 别名# 使用列的别名进行排序SELECT...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yuezi</div><div class="author-info-description">积微者速成</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">603</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuezi2048"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">积微者速成</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-text">八、聚合函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-text">1. 聚合函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E6%A6%82%E8%BF%B0"><span class="toc-text">1.1 聚合函数概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%B8%B8%E8%A7%81%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.2 常见聚合函数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-AVG%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">1.3 AVG使用注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-COUNT%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-text">1.4 COUNT的使用效率分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-GROUP-BY"><span class="toc-text">2. GROUP BY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-HAVING"><span class="toc-text">3. HAVING</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-HAVING%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text">3.1 HAVING的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-HAVING-vs-WHERE"><span class="toc-text">3.2 HAVING vs WHERE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-SELECT%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">4. SELECT执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0"><span class="toc-text">5. 课后练习</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/Excalidraw/Drawing%202024-11-01%2015.37.37.excalidraw/" title="Drawing 2024-11-01 15.37.37.excalidraw">Drawing 2024-11-01 15.37.37.excalidraw</a><time datetime="2025-10-31T04:19:26.621Z" title="发表于 2025-10-31 12:19:26">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/01.project/condefather/yupao/back-end/7.%E4%BC%98%E5%8C%96%E4%B8%BB%E9%A1%B5%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/" title="7.优化主页性能-优化批量导入数据">7.优化主页性能-优化批量导入数据</a><time datetime="2025-10-31T04:19:26.102Z" title="发表于 2025-10-31 12:19:26">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/81.%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B8%E6%A0%87Cursor%E5%88%86%E9%A1%B5_%E5%AF%B9%E6%AF%94%E4%BC%A0%E7%BB%9FLIMIT_OFFSET%E5%88%86%E9%A1%B5%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88/" title="81.什么是游标Cursor分页_对比传统LIMIT_OFFSET分页的优势是什么">81.什么是游标Cursor分页_对比传统LIMIT_OFFSET分页的优势是什么</a><time datetime="2025-10-31T04:14:27.000Z" title="发表于 2025-10-31 12:14:27">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/80.%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E5%90%84%E8%87%AA%E4%BC%98%E7%BC%BA%E7%82%B9/" title="80.全量同步和增量同步各自优缺点">80.全量同步和增量同步各自优缺点</a><time datetime="2025-10-31T04:13:32.000Z" title="发表于 2025-10-31 12:13:32">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/79.%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93_%E7%9B%B8%E6%AF%94%E5%8D%95%E6%9D%A1%E6%8F%92%E5%85%A5%E4%BC%98%E5%8A%BF/" title="79.什么是批量数据入库_相比单条插入优势">79.什么是批量数据入库_相比单条插入优势</a><time datetime="2025-10-31T04:03:26.000Z" title="发表于 2025-10-31 12:03:26">2025-10-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/default.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By yuezi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>