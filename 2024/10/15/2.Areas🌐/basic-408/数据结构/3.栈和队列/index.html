<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>3.栈和队列 | yuezi</title><meta name="author" content="yuezi"><meta name="copyright" content="yuezi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、栈1.1 受限逻辑结构栈：受限的线性表（逻辑结构）—&gt; 顺序表和链表是物理结构 线性表：可以在任意位置进行操作 对线性表的操作进行约束：只允许在一端进行添加或者删除，另一端及中间位置不能操作：栈（Stack），生活例子：弹夹  允许操作的一端：栈顶 不允许操作的一段：栈底 如果没有元素：空栈  栈相关方法：  操作 入栈 出栈   判断 判满 判空  性质：先进后出 应用场景：  函数调">
<meta property="og:type" content="article">
<meta property="og:title" content="3.栈和队列">
<meta property="og:url" content="https://yuezi2048.github.io/2024/10/15/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/index.html">
<meta property="og:site_name" content="yuezi">
<meta property="og:description" content="一、栈1.1 受限逻辑结构栈：受限的线性表（逻辑结构）—&gt; 顺序表和链表是物理结构 线性表：可以在任意位置进行操作 对线性表的操作进行约束：只允许在一端进行添加或者删除，另一端及中间位置不能操作：栈（Stack），生活例子：弹夹  允许操作的一端：栈顶 不允许操作的一段：栈底 如果没有元素：空栈  栈相关方法：  操作 入栈 出栈   判断 判满 判空  性质：先进后出 应用场景：  函数调">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuezi2048.github.io/img/touxiang.jpg">
<meta property="article:published_time" content="2024-10-15T03:45:54.000Z">
<meta property="article:modified_time" content="2024-10-15T03:45:54.000Z">
<meta property="article:author" content="yuezi">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuezi2048.github.io/img/touxiang.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "3.栈和队列",
  "url": "https://yuezi2048.github.io/2024/10/15/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/",
  "image": "https://yuezi2048.github.io/img/touxiang.jpg",
  "datePublished": "2024-10-15T03:45:54.000Z",
  "dateModified": "2024-10-15T03:45:54.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "yuezi",
      "url": "https://yuezi2048.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuezi2048.github.io/2024/10/15/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?bfb48b678d82bea9f9cc9d59227767e4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"FPH6F2TOJL","apiKey":"06d9ea26c803ba912b4d8e13404ed34d","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '3.栈和队列',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/backgound.css"><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">603</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yuezi</span></a><a class="nav-page-title" href="/"><span class="site-name">3.栈和队列</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">3.栈和队列</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-15T03:45:54.000Z" title="发表于 2024-10-15 11:45:54">2024-10-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-15T03:45:54.000Z" title="更新于 2024-10-15 11:45:54">2024-10-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/basic-408/">basic-408</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h1><h2 id="1-1-受限逻辑结构"><a href="#1-1-受限逻辑结构" class="headerlink" title="1.1 受限逻辑结构"></a>1.1 受限逻辑结构</h2><p>栈：受限的线性表（逻辑结构）—&gt; 顺序表和链表是物理结构</p>
<p>线性表：可以在任意位置进行操作</p>
<p>对线性表的操作进行约束：只允许在一端进行添加或者删除，另一端及中间位置不能操作：栈（Stack），生活例子：弹夹</p>
<ul>
<li>允许操作的一端：栈顶</li>
<li>不允许操作的一段：栈底</li>
<li>如果没有元素：空栈</li>
</ul>
<p>栈相关方法：</p>
<ul>
<li>操作<ul>
<li>入栈</li>
<li>出栈</li>
</ul>
</li>
<li>判断</li>
<li>判满</li>
<li>判空</li>
</ul>
<p>性质：先进后出</p>
<p>应用场景：</p>
<ul>
<li>函数调用的实现（递归）</li>
<li>倒着走的业务逻辑（历史记录 撤销）</li>
<li>内存的堆栈：物理</li>
<li>STL库：stack容器  –&gt; 栈</li>
</ul>
<h2 id="1-2-顺序存储实现"><a href="#1-2-顺序存储实现" class="headerlink" title="1.2 顺序存储实现"></a>1.2 顺序存储实现</h2><p>存储结构</p>
<p>顺序存储实现栈：顺序栈 —-&gt; 数组a[MAX_SIZE]</p>
<p>初始化栈：栈底固定不动，在下标0位置。栈顶是活动的，需要变量（int）标记栈顶：top —&gt; 为了描述方便，通常借用指针称呼top变量：栈顶指针</p>
<ul>
<li>top &#x3D; -1 —&gt; top指向栈顶元素真正的位置<ul>
<li>入栈：需判满，top++，指向新的栈顶位置，再在top下标位置放入元素  –&gt; a[++top] &#x3D; k</li>
<li>出栈：需判空，top–即可，top往上的空间都是脏数据不用管</li>
<li>判满：top &#x3D;&#x3D; MAX_SIZE - 1</li>
<li>判空：top &#x3D;&#x3D; -1</li>
<li>得到栈顶元素：return a[top]</li>
</ul>
</li>
<li>top &#x3D; 0 –&gt; top指向栈顶元素的下一个位置<ul>
<li>入栈：需判满，在top下标位置放入元素，再top++ –&gt; a[top++] &#x3D; k</li>
<li>出栈：需判空，top– 即可</li>
<li>判满：top &#x3D;&#x3D; MAX_SIZE</li>
<li>判空：top &#x3D;&#x3D; 0</li>
<li>得到栈顶元素： return a[top - 1]</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SeqStack</span> &#123;</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> top; <span class="comment">// 栈顶指针</span></span><br><span class="line">&#125;SeqStack;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqStack <span class="title">initStack</span><span class="params">(SeqStack S)</span> </span>&#123;</span><br><span class="line">    S.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * MAX_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (S.data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配空间失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    S.top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">(SeqStack *S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;top == MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(SeqStack *S, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isFull</span>(S)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈满 入栈失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;data[++ S-&gt;top] = k;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(SeqStack *S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(SeqStack *S, <span class="type">int</span> *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(S)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈空 出栈失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    *x = S-&gt;data[S-&gt;top];</span><br><span class="line">    S-&gt;top --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getTop</span><span class="params">(SeqStack *S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(S)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空栈 获取栈顶元素失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;data[S-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">push 1</span></span><br><span class="line"><span class="comment">push 2</span></span><br><span class="line"><span class="comment">push 3</span></span><br><span class="line"><span class="comment">pop 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SeqStack S = <span class="built_in">initStack</span>(S);</span><br><span class="line">    <span class="built_in">push</span>(&amp;S, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;push %d\n&quot;</span>, <span class="built_in">getTop</span>(&amp;S));</span><br><span class="line">    <span class="built_in">push</span>(&amp;S, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;push %d\n&quot;</span>, <span class="built_in">getTop</span>(&amp;S));</span><br><span class="line">    <span class="built_in">push</span>(&amp;S, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;push %d\n&quot;</span>, <span class="built_in">getTop</span>(&amp;S));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pop</span>(&amp;S, &amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pop %d\n&quot;</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="1-3-链式存储实现"><a href="#1-3-链式存储实现" class="headerlink" title="1.3 链式存储实现"></a>1.3 链式存储实现</h2><p>链式存储实现栈：链栈 —-&gt; 基于单链表</p>
<ul>
<li>初始化：初始化一个带头节点的单链表</li>
<li>入栈：通过头插法，栈顶是首元节点，头指针（L-&gt;next）作为栈顶指针</li>
<li>出栈：删除首元节点</li>
<li>判空：L-&gt;next &#x3D; NULL</li>
<li>判满：链表无需判满</li>
<li>栈顶元素：return L-&gt;next-&gt;data</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StackNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">StackNode</span> *next;</span><br><span class="line">&#125;LinkStackNode, *LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkStack <span class="title">initStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkStack s = (LinkStackNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkStack));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空间分配失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkStack <span class="title">Push</span><span class="params">(LinkStack top, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头插法</span></span><br><span class="line">    LinkStack s = (LinkStackNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkStack));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空间分配失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = k;</span><br><span class="line">    s-&gt;next = top-&gt;next;</span><br><span class="line">    top-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(LinkStack top)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkStack <span class="title">pop</span><span class="params">(LinkStack top, <span class="type">int</span> *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(top)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈空，出栈失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StackNode *p = top-&gt;next;</span><br><span class="line">    *x = p-&gt;data;</span><br><span class="line">    top-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getTop</span><span class="params">(LinkStack top)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(top)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈空 获取元素失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkStack top = <span class="built_in">initStack</span>();</span><br><span class="line">    top = <span class="built_in">Push</span>(top, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;push %d\n&quot;</span>, <span class="built_in">getTop</span>(top));</span><br><span class="line">    top = <span class="built_in">Push</span>(top, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;push %d\n&quot;</span>, <span class="built_in">getTop</span>(top));</span><br><span class="line">    top = <span class="built_in">Push</span>(top, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;push %d\n&quot;</span>, <span class="built_in">getTop</span>(top));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">pop</span>(top, &amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;del %d\n&quot;</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h1 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h1><h2 id="2-1-队列受限逻辑结构"><a href="#2-1-队列受限逻辑结构" class="headerlink" title="2.1 队列受限逻辑结构"></a>2.1 队列受限逻辑结构</h2><ul>
<li><p>队列：线性逻辑结构，受限的线性表</p>
<ul>
<li>在一端只允许添加操作，另一端只允许删除操作，中间位置不可操作</li>
</ul>
</li>
<li><p>队列中允许添加操作的一端是 队尾（队尾”指针”），另一端称为队首（队头）（队首”指针”）</p>
</li>
<li><p>性质：先进先出</p>
</li>
<li><p>操作</p>
<ul>
<li>入队</li>
<li>出队</li>
</ul>
</li>
<li><p>应用：计算机中需要排队的需求，先来先服务</p>
</li>
</ul>
<h2 id="2-2-顺序存储实现（解决假溢出）"><a href="#2-2-顺序存储实现（解决假溢出）" class="headerlink" title="2.2 顺序存储实现（解决假溢出）"></a>2.2 顺序存储实现（解决假溢出）</h2><p>单端队列</p>
<ul>
<li><p>顺序存储的队列：顺序队列（基于数组a[MAXSIZE] ）  两种思路</p>
<ul>
<li>初始化空的队列：f&#x3D;0, r&#x3D;0;  r 指向真正队尾的下一个位置</li>
<li>入队：  a[r ++] &#x3D; k;</li>
<li>出队： f ++</li>
<li>判满：r &#x3D;&#x3D; MAXSIZE（假溢出问题）</li>
<li>判空：f &#x3D; r</li>
<li>得到队首元素 x &#x3D; a[f]</li>
</ul>
</li>
<li><p>第二种思路</p>
<ul>
<li>初始化： f &#x3D; 0, r &#x3D; -1</li>
<li>入队 a[++ r] &#x3D; k;</li>
<li>出队：f ++;</li>
<li>判满： r &#x3D;&#x3D; MAXSIZE- 1（假溢出问题）</li>
<li>判空：f &#x3D; r + 1</li>
</ul>
</li>
<li><p>链式存储的队列：链式队列（基于链表）</p>
</li>
</ul>
<p>为了解决顺序队列假溢出的问题，使用循环队列（数学mod运算）</p>
<ul>
<li>初始化：f &#x3D; 0，r &#x3D; 0 （r 不能为 -1 ）</li>
<li>入队 ： a[r] &#x3D; k, r &#x3D; (r + 1)  % MAXSIZE</li>
<li>出队： f &#x3D; (f + 1) % MAXSIZE</li>
<li>判空：f &#x3D;&#x3D; r</li>
<li>判满（两种方式 来 避免和判空冲突）<ul>
<li>方式1：牺牲一个存储空间：(r + 1) % MAXSIZE &#x3D;&#x3D; f（常用）</li>
<li>方式2：增加一个flag变量  出队时flag &#x3D; 0，入队时flag&#x3D;1，然后当f &#x3D;&#x3D; r时，进一步判断flag变量</li>
</ul>
</li>
<li>得到队首元素 x &#x3D; a[f]</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span>* data; <span class="comment">// 数组</span></span><br><span class="line">    <span class="type">int</span> f, r; <span class="comment">// 队首指针，队尾指针</span></span><br><span class="line">&#125;SeqQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">SeqQueue <span class="title">initQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SeqQueue q;</span><br><span class="line">    q.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span> (q.data == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空间分配失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    q.f = q.r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">(SeqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.r + <span class="number">1</span>) % MAXSIZE == Q.f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(SeqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q.r == Q.f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(SeqQueue *Q, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isFull</span>(*Q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队满，无法入队&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Q-&gt;data[Q-&gt;r] = k;</span><br><span class="line">    Q-&gt;r = (Q-&gt;r + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeQueue</span><span class="params">(SeqQueue *Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(*Q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空，无法出队&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;队首元素%d出队\n&quot;, Q-&gt;data[Q-&gt;f]);</span></span><br><span class="line">    Q-&gt;f = (Q-&gt;f + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHead</span><span class="params">(SeqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q.data[Q.f];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解决假溢出的问题</span></span><br><span class="line"></span><br><span class="line">    SeqQueue Q = <span class="built_in">initQueue</span>();</span><br><span class="line">    <span class="built_in">EnQueue</span>(&amp;Q, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">EnQueue</span>(&amp;Q, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">DeQueue</span>(&amp;Q);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EnQueue</span>(&amp;Q, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">DeQueue</span>(&amp;Q);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EnQueue</span>(&amp;Q, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">EnQueue</span>(&amp;Q, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">EnQueue</span>(&amp;Q, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>(Q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Ele= %d\n&quot;</span>, <span class="built_in">getHead</span>(Q));</span><br><span class="line">        <span class="built_in">DeQueue</span>(&amp;Q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-3-链式存储实现"><a href="#2-3-链式存储实现" class="headerlink" title="2.3 链式存储实现"></a>2.3 链式存储实现</h2><p>链式队列：带头节点的单链表</p>
<ul>
<li>头指针：队列元素的头指针 + 尾指针 ，队首元素在首元节点f-&gt;next，队尾指针f<ul>
<li>初始化：f &#x3D; r, f -&gt; next &#x3D; r-&gt;next &#x3D; NULL</li>
<li>入队：带尾指针的单链表尾插</li>
<li>出队：删除队首节点（如果删除时r指向首元节点，需要对r进行特殊处理，防止r成为野指针）</li>
<li>无需判满</li>
<li>判空：f-&gt;next &#x3D;&#x3D; NULL  &#x2F;  f &#x3D;&#x3D; r</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span> * next;</span><br><span class="line">&#125;QNode, *LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    QNode *f, *r;</span><br><span class="line">&#125;LinkQ;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkQ <span class="title">initLinkQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkQ Q;</span><br><span class="line">    Q.f = (QNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span> (Q.f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空间分配失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Q;</span><br><span class="line">    &#125;</span><br><span class="line">    Q.f-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.r = Q.f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enQueue</span><span class="params">(LinkQ *Q, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    QNode *s = (QNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空间分配失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = k;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;r-&gt;next = s;</span><br><span class="line">    Q-&gt;r = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(LinkQ Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q.f == Q.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deQueue</span><span class="params">(LinkQ *Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(*Q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空 出队失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    QNode *q = Q-&gt;f-&gt;next;</span><br><span class="line">    Q-&gt;f-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="comment">// r指向首元节点时，需要特殊处理，防止r指向空指针</span></span><br><span class="line">    <span class="keyword">if</span> (q == Q-&gt;r) &#123;</span><br><span class="line">        Q-&gt;r = Q-&gt;f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除元素%d\n&quot;</span>, q-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    q = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义队首指针</span></span><br><span class="line">    LinkQ Q = <span class="built_in">initLinkQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">enQueue</span>(&amp;Q, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">enQueue</span>(&amp;Q, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">enQueue</span>(&amp;Q, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deQueue</span>(&amp;Q);</span><br><span class="line">    <span class="built_in">deQueue</span>(&amp;Q);</span><br><span class="line">    <span class="built_in">deQueue</span>(&amp;Q);</span><br><span class="line">    <span class="built_in">deQueue</span>(&amp;Q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-双端队列"><a href="#2-4-双端队列" class="headerlink" title="2.4 双端队列"></a>2.4 双端队列</h2><ul>
<li><p>双端队列：两端都允许操作的队列，两端都可以进行入队和出队，前端和后端（不符合先进先出了）</p>
<ul>
<li>入队：前端入队的元素要排在后端入队的元素前面</li>
<li>出队：在写出队序列的时候不区分出队的位置，只看谁先出队</li>
<li>应用：<ul>
<li>前端入队的数据从前端入队，后端入队的数据从后端出队：双向栈</li>
</ul>
</li>
</ul>
</li>
<li><p>顺序存储实现双端队列：基于数组（循环数组）</p>
<ul>
<li><strong>注意：为了保证前后端指向数据 不重叠，因此需要有一个指针指向数据的下一个位置（这里以前一个位置为例）</strong></li>
<li>前端入队：先放数据，后动指针（前端指针不指向最前端真实元素，而是最前面的再前面一个位置）</li>
<li>后端入队：先动指针，后放数据（后端指针指向后端真实数据）</li>
<li>前后端出队：前端指针++， 后端指针–即可</li>
<li>判空：前端指针 &#x3D; 后端指针（引入size变量，size&#x3D;&#x3D;0 ）</li>
<li>判满：牺牲一块空间，前端指针 &#x3D; 后端指针 + 1（引入size变量，size&#x3D;&#x3D;maxsize）</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240926153305082.png" alt="image-20240926153305082">	</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以套结构体，写法更规范但写起来繁琐一些</span></span><br><span class="line"><span class="type">int</span> *q = <span class="literal">NULL</span>; <span class="comment">// 指针模拟开数组</span></span><br><span class="line"><span class="type">int</span> l, r; <span class="comment">// 左端，右端</span></span><br><span class="line"><span class="type">int</span> size; <span class="comment">// 双向队列实际大小</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * maxsize);</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配内存失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    l = r = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左端入队</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_left</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判满</span></span><br><span class="line">    <span class="keyword">if</span> (size == maxsize) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列已满！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先放数据，后移动指针</span></span><br><span class="line">    q[l] = k;</span><br><span class="line">    l = (l - <span class="number">1</span> + maxsize) % maxsize; <span class="comment">// 注意负数取模的问题</span></span><br><span class="line">    size ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左端出队</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete_left</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队元素：%d\n&quot;</span>, q[(l + <span class="number">1</span>) % maxsize]);</span><br><span class="line">    l = (l + <span class="number">1</span>) % maxsize;</span><br><span class="line">    size --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右端入队</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_right</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判满</span></span><br><span class="line">    <span class="keyword">if</span> (size == maxsize) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列已满！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先移动指针，再放数据</span></span><br><span class="line">    r = (r + <span class="number">1</span>) % maxsize;</span><br><span class="line">    q[r] = k;</span><br><span class="line">    size ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete_right</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队元素%d\n&quot;</span>, q[r]);</span><br><span class="line">    r = (r - <span class="number">1</span> + maxsize) % maxsize;</span><br><span class="line">    size --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意要考虑队列为空的情况</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为l指向最左边的前一个元素，所以从l后面一个下标开始遍历</span></span><br><span class="line">    <span class="type">int</span> i = (l + <span class="number">1</span>) % maxsize;</span><br><span class="line">    <span class="keyword">while</span> (i != r) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">        i = (i + <span class="number">1</span>) % maxsize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q[r]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">initQueue</span>(); <span class="comment">// 初始化队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试：3 2 1 4 -&gt; 2 1</span></span><br><span class="line">    <span class="built_in">insert_left</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">insert_left</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">insert_left</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">insert_right</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">delete_left</span>();</span><br><span class="line">    <span class="built_in">delete_right</span>();</span><br><span class="line">    <span class="built_in">printQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<ul>
<li>链式存储实现双端队列：基于双向链表<ul>
<li>前端入队：L-&gt;data &#x3D; k; L前面插入一个没有数据的节点s，L &#x3D; S（L指向的位置不是真正的前端）</li>
<li>后端入队：双链表正常尾插</li>
<li>前端出队：直接free掉L的位置，更新L的位置（此时1的位置为脏数据）</li>
<li>后端出队，直接free掉R的位置，更新R的位置</li>
<li>判空：L &#x3D; R</li>
</ul>
</li>
</ul>
<p> <img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240926161839030.png" alt="image-20240926161839030">	</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">linkQueue</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">linkQueue</span> *pre, *next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明收尾指针</span></span><br><span class="line">Node *l = <span class="literal">NULL</span>;</span><br><span class="line">Node *r = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    l = (Node *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    l-&gt;next = l-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">    r = l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左边入队</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertLeft</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    Node *s = (Node *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s是前端数据的前一个不保存数据的节点</span></span><br><span class="line">    l-&gt;data = k;</span><br><span class="line">    s-&gt;next = l;</span><br><span class="line">    s-&gt;pre = l-&gt;pre;</span><br><span class="line">    l-&gt;pre = s;</span><br><span class="line">    l = s;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 左边出队</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 删除判空</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is empty.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除数据%d\n&quot;</span>, l-&gt;next-&gt;data);</span><br><span class="line"></span><br><span class="line">    Node *p = l;</span><br><span class="line">    l = p-&gt;next;</span><br><span class="line">    l-&gt;pre = p-&gt;pre;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右边入队</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertRight</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    Node *s = (Node *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常双向链表入队</span></span><br><span class="line">    s-&gt;data = k;</span><br><span class="line">    s-&gt;next = r-&gt;next;</span><br><span class="line">    s-&gt;pre = r;</span><br><span class="line">    r-&gt;next = s;</span><br><span class="line">    r = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 删除要判空</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is empty.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除数据%d\n&quot;</span>, r-&gt;data);</span><br><span class="line">    Node *p = r;</span><br><span class="line">    r = p-&gt;pre;</span><br><span class="line">    r-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node *p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != r) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, r-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">initQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试：3 2 1 4 -&gt; 2 1</span></span><br><span class="line">    <span class="built_in">insertLeft</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">insertLeft</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">insertLeft</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">insertRight</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deleteLeft</span>();</span><br><span class="line">    <span class="built_in">deleteRight</span>();</span><br><span class="line">    <span class="built_in">printQueue</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>优先队列（算法直播课详细讲）<ul>
<li>队列 + 优先级  –&gt; 优先级高的先出 –&gt; 基于堆实现</li>
</ul>
</li>
<li>STL<ul>
<li>stack queue deque priority_queue</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yuezi2048.github.io">yuezi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yuezi2048.github.io/2024/10/15/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">https://yuezi2048.github.io/2024/10/15/2.Areas🌐/basic-408/数据结构/3.栈和队列/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://yuezi2048.github.io" target="_blank">yuezi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post-share"><div class="social-share" data-image="/img/touxiang.jpg" data-sites="qq,wechat"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/13/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/07.%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/" title="07.单行函数"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">07.单行函数</div></div><div class="info-2"><div class="info-item-1">七、单行函数1. 函数理解1.1 函数的作用函数的作用是什么呢？  它可以把我们经常使用的代码封装起来，需要的时候直接调用即可。这样既提高了代码效率，又提高了可维护性。 在 SQL 中我们也可以使用函数对检索出来的数据进行函数操作。使用这些函数，可以极大地提高用户对数据库的管理效率。    	 从函数定义的角度出发，我们可以将函数分成内置函数和自定义函数。  在 SQL 语言中，同样也包括了内置函数和自定义函数。内置函数是系统内置的通用函数，而自定义函数是我们根据自己的需要编写的， 本章及下一章讲解的是 SQL 的内置函数。  1.2 不同DBMS函数的差异我们在使用 SQL 语言的时候，不是直接和这门语言打交道，而是通过它使用不同的数据库软件，即 DBMS。  DBMS 之间的差异性很大，远大于同一个语言不同版本之间的差异。  实际上，只有很少的函数是被 DBMS 同时支持的。  比如，大多数 DBMS 使用（||）或者（+）来做拼接符，而在 MySQL 中的字符串拼接函数为concat()。   大部分 DBMS 会有自己特定的函数，这就意味着采用 SQL...</div></div></div></a><a class="pagination-related" href="/2024/10/18/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/10.%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/" title="10.创建和管理表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">10.创建和管理表</div></div><div class="info-2"><div class="info-item-1">十、创建和管理表1. 基础知识1.1 数据存储过程 数据存储的重要性：先有数据的存储，才能谈数据的处理 MySQL数据存储：系统架构层面来看，从大到小依次是数据库服务器、数据库、数据表、数据表的行与列  	 1.2 标识符命名规则 数据库名、表名不得超过30个字符，变量名限制为29个 必须只能包含 **A–Z, a–z, 0–9, _**共63个字符 数据库名、表名、字段名等对象名中间不要包含空格 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用&#96;（着重号）引起来 保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了  1.3...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/10/05/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%20C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" title="1. C语言基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-05</div><div class="info-item-2">1. C语言基础</div></div><div class="info-2"><div class="info-item-1">一、基础语法1.1 编译过程程序为什么要被编译器编译之后才能运行？  机器识别的只有机器语言（由二进制的0和1组成） 因此我们必须将高级语言翻译为能让机器识别的机器语言程序  转换成机器语言的过程是怎么样的？  预处理：展开头文件&#x2F;宏替换&#x2F;去注释&#x2F;条件编译 编译：检查语法，生成汇编代码 汇编：将汇编代码转化为二进制的机器码 链接合成可执行的程序，并在声明的文件找相关的定义  1.2 宏定义和typedef关键字define  使用一个标识符来表示一个字符串，这就是宏，标识符叫宏名 替换文本可以是常数、表达式、字符串、基本数据类型、简单函数  typedef  为数据类型定义新名称，常用于结构体（对struct {} 起一个别名）  #include &lt;stdio.h&gt;#define ll long long#define Max 20#define MAX(x, y) ((x) &gt; (y) ? (x) : (y))typedef long long lll;ll a;lll b;int aa[Max];    typedef...</div></div></div></a><a class="pagination-related" href="/2024/09/12/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.DS%E6%A6%82%E8%BF%B0%E5%92%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/" title="2.DS概述和顺序表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-12</div><div class="info-item-2">2.DS概述和顺序表</div></div><div class="info-2"><div class="info-item-1">一、数据结构基本概念1.1 抽象数据类型我们现在有基本数据类型：  int表示2^32个数字：[-2^31, 2^31-1]  为了表示更多的数据类型表示实际复杂的业务，我们需要一个抽象数据类型 抽象数据类型（可自定义）：静态的数据 + 动态的操作（函数） 引出数据结构Data Structure：数据（data）和数据之间的关系（structure） 我们使用抽象数据类型来定义一个数据结构  分析问题：找到数据之间逻辑的关系（逻辑结构） 解决问题：如何把数据和数据之间的关系存入存储器（存储结构&#x2F;物理结构&#x2F;映像） 关系：存储结构是用计算机语言实现的逻辑结构  1.2 逻辑结构和存储结构数据结构可分为两块：逻辑结构和存储结构 逻辑结构  线性逻辑结构：一对一（线性表 栈 队列） 非线性逻辑结构：一对多（树形结构）、多对多（图型结构）  存储结构  顺序存储：逻辑上相邻的元素，在存储中位置也相邻（数组） 链式存储：逻辑上相邻的元素，存储器的位置可以不相邻，但需要实现逻辑上的相邻（链表） 索引存储，散列存储（Hash）...</div></div></div></a><a class="pagination-related" href="/2025/04/07/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E5%9B%BE/" title="5.图"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-07</div><div class="info-item-2">5.图</div></div><div class="info-2"><div class="info-item-1">五、图5.1 基本概念 图：用来描述事物之间相互联系或相互作用的多对多的关系 图是由两个有限集合构成的，分别是点集V和边集E，其中边是通过两个端点来描述的 分类标准1：有无自边和重边，分为简单图（默认）和非简单图 分类标准2：根据边是否有方向性$&lt;v_i,v_j&gt;$，分为有向图和无向图 对于有向图来说，起点$v_i$是弧尾，终点$v_j$是弧头 一条无向边相当于两条有向边（为图的存储铺垫） 环&#x2F;回路：从图中某点出发，沿着边走，最终回到起点 —&gt; 有向无环图（DAG图） 完全有向图：图有n个点，一共有$n(n-1)$个边 完全无向图：图有n个点，一共有$\frac{n(n-1)}{2}$个边   分类标准3：根据边的数目 分为稠密图和稀疏图 分类标准4：根据边是否有权值 分为...</div></div></div></a><a class="pagination-related" href="/2024/12/10/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.%20%E6%8E%92%E5%BA%8F/" title="6. 排序"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-10</div><div class="info-item-2">6. 排序</div></div><div class="info-2"><div class="info-item-1">六、排序（默认升序）  就地排序、非就地排序 –&gt; 空间复杂度 内部排序、外部排序（只能拿一部分数据在内存中排，其他的存在外存中）—&gt; 基本上是内部排序 稳定性：重复数据的相对位置如果不发生变化，那么就是稳定交换 时间复杂度  排序算法包括：  插入：直接插入排序、shell排序（缩小增量排序） 交换：冒泡排序、快速排序 选择：简单选择排序、堆排序（堆） 归并排序：2-路归并 计数排序：桶排序、基数排序  约定  上课案例：a[1] - a[n] 数组分成两部分：乱序区、有序区 初始：整个数组是乱序区 乱序区不断缩小，有序区不断增大 最终：整个数组是有序区    6.1 插入6.1.1 插入排序 初始：a[1]是有序区、a[2]-a[n]是乱序区 每次把乱序区的一个数据插入到有序区中的合适位置，有序区长度+1，乱序区长度-1，执行n-1次为止   如何把数据插入到有序区的合适位置，即对于a[1]~a[i-1]的有序区，如何将a[i]加入到有序区中   找位置：a[i]从后往前比，直到遇到第一个小于等于a[i]的数a[k]，则 k+1...</div></div></div></a><a class="pagination-related" href="/2025/03/25/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E6%A0%91/" title="4.树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-25</div><div class="info-item-2">4.树</div></div><div class="info-2"><div class="info-item-1">〇、前置知识——递归 递归：某个函数直接或间接的调用自身（递进 回归）  （基于栈实现）   递归的本质：函数调用（创建副本）  如何理解递归代码：画出递归调用图  递归函数组成  递归出口 &#x2F; 终止条件 &#x2F; 边界条件：停止递归调用的条件（避免栈溢出 &#x2F; 爆内存） 特别注意：这里往往出问题（条件找错 &#x2F; 没找全条件）   递归体   解决的问题  如果一个问题能分成若干个小问题，并且小问题的解决思路和大问题一样 大问题和小问题的数据规模不一样   开发中怎么写递归函数  写的时候不要往深层次想执行过程，只需要知道函数解决什么问题的（一次递归的结果），该怎么分配子问题 即编码的时候更多的看成是黑盒问题而不是白盒问题，验证和复盘的时候可以追究白盒      #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;// 累加问题 1 + 2 + 3 + ... + n/*	5	15*/int add(int n) &#123;    if (n == 1) &#123; // 递归出口       ...</div></div></div></a><a class="pagination-related" href="/2025/01/02/2.Areas%F0%9F%8C%90/basic-408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.%20%E6%9F%A5%E6%89%BE/" title="7. 查找"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-02</div><div class="info-item-2">7. 查找</div></div><div class="info-2"><div class="info-item-1">连地址法链地址法（拉链法 链接法）：一个地址处只能存放同义词，不存放非同义词，将同义词组成链表，存在对应的地址处即可 不同情况下的ASL：查找一个数据的比较次数 ASL平均查找长度：查找n个数查找长度和 &#x2F; n 开放地址法  ASL成功查找长度 ASL失败查找长度  链地址法  ASL成功查找长度  #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define size 13// 链表的节点结构typedef struct Node &#123;    int data;    struct Node *next;&#125;HNode, *HLink;int Hash(int k) &#123;    return k % 13;&#125;void Insert(HLink hash[], int k) &#123;    int i = Hash(k);        // 申请链表节点    HNode* p = (HNode*)malloc(sizeof(HNode));    p-&gt;data = k; ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yuezi</div><div class="author-info-description">积微者速成</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">603</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuezi2048"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">积微者速成</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A0%88"><span class="toc-text">一、栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%8F%97%E9%99%90%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-text">1.1 受限逻辑结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.2 顺序存储实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.3 链式存储实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%98%9F%E5%88%97"><span class="toc-text">二、队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E9%98%9F%E5%88%97%E5%8F%97%E9%99%90%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-text">2.1 队列受限逻辑结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0%EF%BC%88%E8%A7%A3%E5%86%B3%E5%81%87%E6%BA%A2%E5%87%BA%EF%BC%89"><span class="toc-text">2.2 顺序存储实现（解决假溢出）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3 链式存储实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-text">2.4 双端队列</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/Excalidraw/Drawing%202024-11-01%2015.37.37.excalidraw/" title="Drawing 2024-11-01 15.37.37.excalidraw">Drawing 2024-11-01 15.37.37.excalidraw</a><time datetime="2025-10-31T04:19:26.621Z" title="发表于 2025-10-31 12:19:26">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/01.project/condefather/yupao/back-end/7.%E4%BC%98%E5%8C%96%E4%B8%BB%E9%A1%B5%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/" title="7.优化主页性能-优化批量导入数据">7.优化主页性能-优化批量导入数据</a><time datetime="2025-10-31T04:19:26.102Z" title="发表于 2025-10-31 12:19:26">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/81.%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B8%E6%A0%87Cursor%E5%88%86%E9%A1%B5_%E5%AF%B9%E6%AF%94%E4%BC%A0%E7%BB%9FLIMIT_OFFSET%E5%88%86%E9%A1%B5%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88/" title="81.什么是游标Cursor分页_对比传统LIMIT_OFFSET分页的优势是什么">81.什么是游标Cursor分页_对比传统LIMIT_OFFSET分页的优势是什么</a><time datetime="2025-10-31T04:14:27.000Z" title="发表于 2025-10-31 12:14:27">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/80.%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E5%90%84%E8%87%AA%E4%BC%98%E7%BC%BA%E7%82%B9/" title="80.全量同步和增量同步各自优缺点">80.全量同步和增量同步各自优缺点</a><time datetime="2025-10-31T04:13:32.000Z" title="发表于 2025-10-31 12:13:32">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/79.%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93_%E7%9B%B8%E6%AF%94%E5%8D%95%E6%9D%A1%E6%8F%92%E5%85%A5%E4%BC%98%E5%8A%BF/" title="79.什么是批量数据入库_相比单条插入优势">79.什么是批量数据入库_相比单条插入优势</a><time datetime="2025-10-31T04:03:26.000Z" title="发表于 2025-10-31 12:03:26">2025-10-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/default.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By yuezi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>