<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>09.子查询 | yuezi</title><meta name="author" content="yuezi"><meta name="copyright" content="yuezi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="九、子查询1. 需求分析和问题解决1.1 实际问题现在要查询谁的工资比Abel的高，但是Abel的工资又需要查询，而前面提到，我们要避免多条查询语句，衍生出了子查询的概念。 	 用前面的知识，多条语句，我们也可以很轻松地解决这个问题。 # 1. 由一个具体需求引出子查询# 需求：谁的工资比Abel高# 传统方式1：需要对数据库进行两次数据交互-- 11000SELECT last_name, sa">
<meta property="og:type" content="article">
<meta property="og:title" content="09.子查询">
<meta property="og:url" content="https://yuezi2048.github.io/2024/08/15/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/09.%E5%AD%90%E6%9F%A5%E8%AF%A2/index.html">
<meta property="og:site_name" content="yuezi">
<meta property="og:description" content="九、子查询1. 需求分析和问题解决1.1 实际问题现在要查询谁的工资比Abel的高，但是Abel的工资又需要查询，而前面提到，我们要避免多条查询语句，衍生出了子查询的概念。 	 用前面的知识，多条语句，我们也可以很轻松地解决这个问题。 # 1. 由一个具体需求引出子查询# 需求：谁的工资比Abel高# 传统方式1：需要对数据库进行两次数据交互-- 11000SELECT last_name, sa">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuezi2048.github.io/img/touxiang.jpg">
<meta property="article:published_time" content="2024-08-15T02:11:26.000Z">
<meta property="article:modified_time" content="2024-08-15T02:11:26.000Z">
<meta property="article:author" content="yuezi">
<meta property="article:tag" content="基础篇">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuezi2048.github.io/img/touxiang.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "09.子查询",
  "url": "https://yuezi2048.github.io/2024/08/15/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/09.%E5%AD%90%E6%9F%A5%E8%AF%A2/",
  "image": "https://yuezi2048.github.io/img/touxiang.jpg",
  "datePublished": "2024-08-15T02:11:26.000Z",
  "dateModified": "2024-08-15T02:11:26.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "yuezi",
      "url": "https://yuezi2048.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuezi2048.github.io/2024/08/15/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/09.%E5%AD%90%E6%9F%A5%E8%AF%A2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?bfb48b678d82bea9f9cc9d59227767e4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"FPH6F2TOJL","apiKey":"06d9ea26c803ba912b4d8e13404ed34d","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '09.子查询',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/backgound.css"><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">603</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yuezi</span></a><a class="nav-page-title" href="/"><span class="site-name">09.子查询</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">09.子查询</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-15T02:11:26.000Z" title="发表于 2024-08-15 10:11:26">2024-08-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-15T02:11:26.000Z" title="更新于 2024-08-15 10:11:26">2024-08-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/back-end-java/">back-end-java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/back-end-java/2-MySQL/">2.MySQL</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/back-end-java/2-MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/">基础篇</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="九、子查询"><a href="#九、子查询" class="headerlink" title="九、子查询"></a>九、子查询</h1><h2 id="1-需求分析和问题解决"><a href="#1-需求分析和问题解决" class="headerlink" title="1. 需求分析和问题解决"></a>1. 需求分析和问题解决</h2><h3 id="1-1-实际问题"><a href="#1-1-实际问题" class="headerlink" title="1.1 实际问题"></a>1.1 实际问题</h3><p>现在要查询谁的工资比Abel的高，但是Abel的工资又需要查询，而前面提到，我们要避免多条查询语句，衍生出了子查询的概念。</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240814170632438.png" alt="image-20240814170632438">	</p>
<p>用前面的知识，多条语句，我们也可以很轻松地解决这个问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1. 由一个具体需求引出子查询</span><br><span class="line"># 需求：谁的工资比Abel高</span><br><span class="line"># 传统方式1：需要对数据库进行两次数据交互</span><br><span class="line">-- 11000</span><br><span class="line">SELECT last_name, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name = &#x27;Abel&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT last_name, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; 11000;</span><br></pre></td></tr></table></figure>



<p>有一点内功的，应当想到使用自连接的方式，从而和Abel这条记录连接上，进而筛选出工资比Abel高的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 方式2：自连接</span><br><span class="line">SELECT e2.last_name, e2.salary</span><br><span class="line">FROM employees e1, employees e2</span><br><span class="line">WHERE e1.last_name = &#x27;Abel&#x27;</span><br><span class="line">AND e2.salary &gt; e1.salary</span><br></pre></td></tr></table></figure>



<p>而改进第一种方法后，就可以用子查询解决我们的问题（这属于<code>不相关子查询</code>，后面会提到概念）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 方式3：子查询</span><br><span class="line"># 不相关子查询：外层每一个salary和内层每一个salary比较</span><br><span class="line">SELECT last_name, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">		SELECT salary</span><br><span class="line">		FROM employees</span><br><span class="line">		WHERE last_name = &#x27;Abel&#x27;</span><br><span class="line">		);</span><br></pre></td></tr></table></figure>



<h3 id="1-2-子查询的基本使用"><a href="#1-2-子查询的基本使用" class="headerlink" title="1.2 子查询的基本使用"></a>1.2 子查询的基本使用</h3><p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240814171249949.png" alt="image-20240814171249949">	</p>
<ul>
<li>给出子查询中 称谓的规范：<code>外查询</code>（主查询） <code>内查询</code>（子查询）</li>
<li>子查询（内查询）在主查询之前一次执行完成。</li>
<li>子查询的结果被主查询（外查询）使用 。</li>
<li><strong>注意事项</strong><ul>
<li>子查询要包含在括号内</li>
<li>将子查询放在比较条件的右侧</li>
<li>单行操作符对应单行子查询，多行操作符对应多行子查询</li>
</ul>
</li>
</ul>
<h3 id="1-3-子查询的分类"><a href="#1-3-子查询的分类" class="headerlink" title="1.3 子查询的分类"></a>1.3 子查询的分类</h3><ul>
<li><p>角度1：<code>单行子查询</code> vs <code>多行子查询</code>（子查询返回单个&#x2F;多个结果）</p>
</li>
<li><p>角度2：<code>相关子查询</code> vs <code>不相关自查询</code>（子查询是否执行多次）</p>
<ul>
<li>子查询执行多次的理解：我们首先会进行外部查询，而外部查询每次都需要调用内部查询，得到内部查询返回的结果后再处理外部，理解为嵌套for循环</li>
<li>每次内部查询返回的和外部的字段，是有关联的，所以每次执行 返回的不一定一样，见实际例子</li>
</ul>
</li>
</ul>
<p>相关子查询实例：查询工资大于本部门平均工资的员工信息</p>
<p>不相关子查询实例：查询工资大于本公司平均工资的员工信息</p>
<h2 id="2-单行子查询"><a href="#2-单行子查询" class="headerlink" title="2. 单行子查询"></a>2. 单行子查询</h2><table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>equal to</td>
</tr>
<tr>
<td>&gt;</td>
<td>greater than</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>greater than or equal to</td>
</tr>
<tr>
<td>&lt;</td>
<td>less than</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>less than or equal to</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>not equal to</td>
</tr>
</tbody></table>
<h3 id="2-1-单行子查询语句"><a href="#2-1-单行子查询语句" class="headerlink" title="2.1 单行子查询语句"></a>2.1 单行子查询语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 子查询编写步骤：①从里往外 ②从外往里</span><br><span class="line"># 4. 单行子查询</span><br><span class="line"># 4.1 单行操作符 = != &gt; &lt; &gt;= &lt;=</span><br><span class="line">-- 查询工资大于149号员工工资的员工信息</span><br><span class="line"></span><br><span class="line">SELECT last_name, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">		SELECT salary</span><br><span class="line">		FROM employees</span><br><span class="line">		WHERE employee_id = 149</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资</span><br><span class="line">SELECT job_id, last_name, job_id, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id = (</span><br><span class="line">		SELECT job_id </span><br><span class="line">		FROM employees </span><br><span class="line">		WHERE employee_id = 141</span><br><span class="line">		)</span><br><span class="line">AND salary &gt; (</span><br><span class="line">		SELECT salary</span><br><span class="line">		FROM employees</span><br><span class="line">		WHERE employee_id = 143</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line"># 返回公司工资最少的员工的last_name,job_id和salary</span><br><span class="line">SELECT last_name, job_id, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary = (</span><br><span class="line">		SELECT MIN(salary) </span><br><span class="line">		FROM employees</span><br><span class="line">		);</span><br><span class="line">		</span><br><span class="line"># 查询与141号或174号员工的manager_id和department_id相同的其他员工的employee_id，manager_id，department_id</span><br><span class="line">SELECT employee_id, manager_id, department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE manager_id IN(</span><br><span class="line">		SELECT manager_id</span><br><span class="line">		FROM employees</span><br><span class="line">		WHERE employee_id IN (141, 174)</span><br><span class="line">)</span><br><span class="line">AND department_id IN(</span><br><span class="line">		SELECT department_id</span><br><span class="line">		FROM employees</span><br><span class="line">		WHERE employee_id IN (141, 174)</span><br><span class="line">)</span><br><span class="line">AND employee_id NOT IN(141, 174)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"># 方式2：了解（成对查询） 效率差不多 本质都是单行/多行查询，但适配性不高</span><br><span class="line">SELECT employee_id, manager_id, department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE (manager_id, department_id) IN (</span><br><span class="line">				SELECT manager_id, department_id</span><br><span class="line">				FROM employees</span><br><span class="line">				WHERE employee_id IN (141, 174)</span><br><span class="line">				)</span><br><span class="line">AND employee_id NOT IN(141, 174);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 题目：查询最低工资大于110号部门最低工资的部门id和其最低工资</span><br><span class="line">SELECT department_id, MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id IS NOT NULL</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MIN(salary) &gt; (</span><br><span class="line">		SELECT MIN(salary)</span><br><span class="line">		FROM employees</span><br><span class="line">		WHERE department_id = 110</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">需求：显示员工的employee_id,last_name和location。</span><br><span class="line">其中，若员工department_id与location_id为1800的department_id相同，则location为’Canada’，其余则为’USA’</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">SELECT employee_id, last_name, CASE WHEN department_id = (</span><br><span class="line">						SELECT department_id</span><br><span class="line">						FROM departments</span><br><span class="line">						WHERE location_id = 1800</span><br><span class="line">						)</span><br><span class="line">					THEN &#x27;Canda&#x27;</span><br><span class="line">					ELSE &#x27;USA&#x27; END &quot;location&quot;</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-2-子查询的空值问题"><a href="#2-2-子查询的空值问题" class="headerlink" title="2.2 子查询的空值问题"></a>2.2 子查询的空值问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 4.2 子查询的空值问题（内查询如果为空，外查询会没有返回）</span><br><span class="line">SELECT last_name, job_id</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  job_id =</span><br><span class="line">                (SELECT job_id</span><br><span class="line">                 FROM   employees</span><br><span class="line">                 WHERE  last_name = &#x27;Haas&#x27;);</span><br></pre></td></tr></table></figure>



<h3 id="2-3-单行子查询非法使用"><a href="#2-3-单行子查询非法使用" class="headerlink" title="2.3 单行子查询非法使用"></a>2.3 单行子查询非法使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 4.3 非法使用子查询(单行使用多行)</span><br><span class="line">SELECT employee_id, last_name</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  salary =</span><br><span class="line">                (SELECT   MIN(salary)</span><br><span class="line">                 FROM     employees</span><br><span class="line">                 GROUP BY department_id);</span><br></pre></td></tr></table></figure>





<h2 id="3-多行子查询"><a href="#3-多行子查询" class="headerlink" title="3. 多行子查询"></a>3. 多行子查询</h2><h3 id="3-1-多行子查询的操作符"><a href="#3-1-多行子查询的操作符" class="headerlink" title="3.1 多行子查询的操作符"></a>3.1 多行子查询的操作符</h3><ul>
<li>也称为集合比较子查询</li>
<li>内查询返回多行</li>
<li>使用多行比较操作符</li>
</ul>
<table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>等于列表中的<strong>任意一个</strong></td>
</tr>
<tr>
<td>ANY</td>
<td>需要和单行比较操作符一起使用，和子查询返回的<strong>某一个</strong>值比较</td>
</tr>
<tr>
<td>ALL</td>
<td>需要和单行比较操作符一起使用，和子查询返回的<strong>所有</strong>值比较</td>
</tr>
<tr>
<td>SOME</td>
<td>实际上是ANY的别名，作用相同，一般常使用ANY</td>
</tr>
</tbody></table>
<blockquote>
<p>体会 ANY 和 ALL 的区别</p>
</blockquote>
<h3 id="3-2-多行子查询语句"><a href="#3-2-多行子查询语句" class="headerlink" title="3.2 多行子查询语句"></a>3.2 多行子查询语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 5.2 举例:查询哪些员工等于其中一个部门的最低工资</span><br><span class="line">SELECT employee_id, last_name</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  salary IN</span><br><span class="line">                (SELECT   MIN(salary)</span><br><span class="line">                 FROM     employees</span><br><span class="line">                 GROUP BY department_id);</span><br><span class="line"></span><br><span class="line"># ANY / ALL</span><br><span class="line"># 返回【其它job_id中】【比job_id为‘IT_PROG’部门的一个人工资低】的(即存在一个IT_PROG部门的人，查找的人工资比他低)</span><br><span class="line"># 员工的员工号、姓名、job_id 以及salary</span><br><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id = &#x27;IT_PROG&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT employee_id, last_name, job_id, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id &lt;&gt; &#x27;IT_PROG&#x27;</span><br><span class="line">AND salary &lt; ANY (</span><br><span class="line">	SELECT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id = &#x27;IT_PROG&#x27;</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line"># 返回【其它job_id中】【比job_id为‘IT_PROG’部门所有的员工工资低】的</span><br><span class="line"># 员工的员工号、姓名、job_id 以及salary</span><br><span class="line">SELECT employee_id, last_name, job_id, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id &lt;&gt; &#x27;IT_PROG&#x27;</span><br><span class="line">AND salary &lt; ALL (</span><br><span class="line">	SELECT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id = &#x27;IT_PROG&#x27;</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line"># 查询平均工资最低的部门id</span><br><span class="line">-- MySQL中 聚合函数不能嵌套，如MIN(AVG())，但Oracle可以</span><br><span class="line">-- 我的思路（1）各个部门的平均工资看成是一个集合;(2)查找比各个部门平均工资最小的（3）SELECT</span><br><span class="line">-- 老师的方式1思路：使用子查询解决，让avg的结果充当为一个表，然后使用min的聚合函数充当，外面套一层外查询得到id</span><br><span class="line">SELECT AVG(salary) avg_sal</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line"># avg的结果充当为一个表</span><br><span class="line">SELECT MIN(avg_sal) </span><br><span class="line">FROM (</span><br><span class="line">	SELECT AVG(salary) avg_sal-</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	) t_dept_avg_sal;</span><br><span class="line"></span><br><span class="line">-- 启发：得到的结果也可以作为一个临时表作为子查询</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary) = (</span><br><span class="line">		SELECT MIN(avg_sal) </span><br><span class="line">		FROM (</span><br><span class="line">			SELECT AVG(salary) avg_sal</span><br><span class="line">			FROM employees</span><br><span class="line">			GROUP BY department_id</span><br><span class="line">			) t_dept_avg_sal</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">-- 方式2 使用多行子查询优化：</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary) &lt;= ALL (</span><br><span class="line">			SELECT AVG(salary) avg_sal</span><br><span class="line">			FROM employees</span><br><span class="line">			GROUP BY department_id</span><br><span class="line">			)</span><br></pre></td></tr></table></figure>



<h3 id="3-3-多行子查询空值问题"><a href="#3-3-多行子查询空值问题" class="headerlink" title="3.3 多行子查询空值问题"></a>3.3 多行子查询空值问题</h3><ul>
<li>注意一旦内层的集合有空值，外层立刻返回null</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 5.3 多行子查询的空行问题</span><br><span class="line">-- 如果内查询里面包含了null值，那么结果会返回空值！因此要加入特判！</span><br><span class="line">SELECT last_name</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id NOT IN (</span><br><span class="line">			SELECT manager_id</span><br><span class="line">			FROM employees</span><br><span class="line">			# where manager_id is not null</span><br><span class="line">			);</span><br></pre></td></tr></table></figure>



<h2 id="4-相关子查询"><a href="#4-相关子查询" class="headerlink" title="4. 相关子查询"></a>4. 相关子查询</h2><h3 id="4-1-执行流程"><a href="#4-1-执行流程" class="headerlink" title="4.1 执行流程"></a>4.1 执行流程</h3><ul>
<li><code>相关子查询</code>：子查询的执行 依赖于 外部查询（通常是引用了外表，做了条件关联，所以子查询每执行一次就要重新查一遍），也叫<code>关联子查询</code></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240815093031586.png" alt="image-20240815093031586">	</p>
<ul>
<li>明确<code>相关子查询</code>是一行一行地<code>顺序执行</code>，主查询每过一行，就要执行一次子查询，再细分执行流程如下：</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240815093023040.png" alt="image-20240815093023040">	</p>
<h3 id="4-2-相关子查询语句"><a href="#4-2-相关子查询语句" class="headerlink" title="4.2 相关子查询语句"></a>4.2 相关子查询语句</h3><ul>
<li>关注一个点，子查询的位置很灵活，除了<code>GROUP BY</code>和 <code>LIMIT</code>都可以加<ul>
<li>包括：<code>WHERE，FROM，ORDER BY，多表连接，甚至是SELECT</code>，后面课后练习会提到这个点</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 6. 相关子查询(内查询中出现了其他表，每条记录进来都要查一遍)</span><br><span class="line"># 6.1</span><br><span class="line"># 回顾：查询员工中工资大于本公司平均工资的员工的last_name,salary和其department_id</span><br><span class="line">SELECT last_name, salary, department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">		SELECT AVG(salary)</span><br><span class="line">		FROM employees</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id</span><br><span class="line">-- 方式1：相关子查询</span><br><span class="line">SELECT last_name, salary, department_id</span><br><span class="line">FROM employees e1</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">		SELECT AVG(salary)</span><br><span class="line">		FROM employees e2</span><br><span class="line">		WHERE department_id = e1.department_id</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">-- 方式2：在FROM中声明子查询(将每个部门的平均工资临时做一个表，注意该表内容在外面看来就是一个字段而不是函数，聚合函数必须起别名)</span><br><span class="line">SELECT e.last_name, e.salary, e.department_id</span><br><span class="line">FROM employees e, (</span><br><span class="line">		SELECT department_id, AVG(salary) avg_sal</span><br><span class="line">		FROM employees</span><br><span class="line">		GROUP BY department_id) t_dept_avl_sal</span><br><span class="line">WHERE e.department_id = t_dept_avl_sal.department_id</span><br><span class="line">AND e.salary &gt; t_dept_avl_sal.avg_sal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查询员工的id,salary,按照department_name 排序</span><br><span class="line">SELECT employee_id, salary</span><br><span class="line">FROM employees e</span><br><span class="line">ORDER BY (</span><br><span class="line">	SELECT department_name</span><br><span class="line">	FROM departments d</span><br><span class="line">	WHERE d.department_id = e.department_id</span><br><span class="line">	) ASC;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 结论：在select结构中，除了GROUP BY 和LIMIT 之外，其他位置都可以声明子查询！包括select</span><br><span class="line">/*</span><br><span class="line">SELECT ...,...,...(聚合函数)</span><br><span class="line">FROM ...(LEFT/RIGHT) JOIN...(多表查询) ON ... = ...(多表连接条件)</span><br><span class="line">(LEFT/RIGHT)JOIN ... ON ...</span><br><span class="line">WHERE ...(过滤条件 不包含聚合函数)</span><br><span class="line">GROUP BY ... (分组)</span><br><span class="line">HAVING ..(过滤条件 包含聚合函数)</span><br><span class="line">ORDER BY ... ASC / DESC</span><br><span class="line">LIMIT ..,..</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">-- 若employees表中employee_id与job_history表中employee_id相同的数目不小于2</span><br><span class="line">-- 输出这些相同id的员工的employee_id,last_name和其job_id</span><br><span class="line">SELECT employee_id, last_name, job_id</span><br><span class="line">FROM employees e</span><br><span class="line">WHERE 2 &lt;= (</span><br><span class="line">	SELECT COUNT(*)</span><br><span class="line">	FROM job_history j</span><br><span class="line">	WHERE j.employee_id = e.employee_id</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>



<h3 id="4-3-EXISTS关键字"><a href="#4-3-EXISTS关键字" class="headerlink" title="4.3 EXISTS关键字"></a>4.3 EXISTS关键字</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 6.2 EXISTS和NOT EXISTS关键字</span><br><span class="line"># 查询公司管理者的employee_id，last_name，job_id，department_id信息</span><br><span class="line"># 方式1: 自连接</span><br><span class="line">SELECT DISTINCT mgr.employee_id, mgr.last_name, mgr.job_id, mgr.department_id</span><br><span class="line">FROM employees emp JOIN employees mgr</span><br><span class="line">WHERE emp.manager_id = mgr.employee_id;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"># 方式2：不相关子查询</span><br><span class="line">SELECT employee_id, last_name, job_id, department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id IN (</span><br><span class="line">		SELECT DISTINCT manager_id</span><br><span class="line">		FROM employees</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line"># 方式3：相关子查询EXISTS（内部找到了满足条件的就会停止，外部继续塞入下一条记录交给内部查找该记录的id是不是管理者）</span><br><span class="line">-- 只要有记录就可以返回true</span><br><span class="line">-- 注意细节，因为要找的是管理者的信息，所以外层应当是管理者的信息</span><br><span class="line">SELECT employee_id, last_name, job_id, department_id</span><br><span class="line">FROM employees e1</span><br><span class="line">WHERE EXISTS (</span><br><span class="line">	SELECT *</span><br><span class="line">	FROM employees e2</span><br><span class="line">	WHERE e1.employee_id = e2.manager_id</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line"># 查询departments表中，不存在于employees表中的部门的department_id和department_name(有16个 共27个部门)</span><br><span class="line"># 方式1：右外连接减去公共部分</span><br><span class="line">SELECT d.department_id, d.department_name</span><br><span class="line">FROM employees e RIGHT JOIN departments d</span><br><span class="line">ON e.department_id = d.department_id</span><br><span class="line">WHERE e.department_id IS NULL;</span><br><span class="line"></span><br><span class="line"># 方式2：没找到的是我们所需要的</span><br><span class="line">SELECT d.department_id, d.department_name</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE NOT EXISTS (</span><br><span class="line">		SELECT *</span><br><span class="line">		FROM employees e</span><br><span class="line">		WHERE d.department_id = e.department_id</span><br><span class="line">		);</span><br></pre></td></tr></table></figure>



<h3 id="4-4-相关更新"><a href="#4-4-相关更新" class="headerlink" title="4.4 相关更新"></a>4.4 相关更新</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE table1 alias1</span><br><span class="line">SET    column = (SELECT expression</span><br><span class="line">                 FROM   table2 alias2</span><br><span class="line">                 WHERE  alias1.column = alias2.column);</span><br></pre></td></tr></table></figure>

<p>使用相关子查询依据一个表中的数据更新另一个表的数据。</p>
<p><strong>题目：在employees中增加一个department_name字段，数据为员工对应的部门名称</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1）</span><br><span class="line">ALTER TABLE employees</span><br><span class="line">ADD(department_name VARCHAR2(14));</span><br><span class="line"></span><br><span class="line"># 2）</span><br><span class="line">UPDATE employees e</span><br><span class="line">SET department_name =  (SELECT department_name </span><br><span class="line">	                       FROM   departments d</span><br><span class="line">	                       WHERE  e.department_id = d.department_id);</span><br></pre></td></tr></table></figure>



<h3 id="4-5-相关删除"><a href="#4-5-相关删除" class="headerlink" title="4.5 相关删除"></a>4.5 相关删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM table1 alias1</span><br><span class="line">WHERE column operator (SELECT expression</span><br><span class="line">                       FROM   table2 alias2</span><br><span class="line">                       WHERE  alias1.column = alias2.column);</span><br></pre></td></tr></table></figure>

<p>使用相关子查询依据一个表中的数据删除另一个表的数据。</p>
<p><strong>题目：删除表employees中，其与emp_history表皆有的数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="keyword">in</span>  </span><br><span class="line">           (<span class="keyword">SELECT</span> employee_id</span><br><span class="line">            <span class="keyword">FROM</span>   emp_history </span><br><span class="line">            <span class="keyword">WHERE</span>  employee_id <span class="operator">=</span> e.employee_id);</span><br></pre></td></tr></table></figure>



<h2 id="5-思考：子查询的效率问题"><a href="#5-思考：子查询的效率问题" class="headerlink" title="5. 思考：子查询的效率问题"></a>5. 思考：子查询的效率问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 回到最初的问题：谁的工资比Abel高？</span><br><span class="line">#方式1：自连接</span><br><span class="line">SELECT e2.last_name,e2.salary</span><br><span class="line">FROM employees e1,employees e2</span><br><span class="line">WHERE e1.last_name = &#x27;Abel&#x27;</span><br><span class="line">AND e1.`salary` &lt; e2.`salary`</span><br><span class="line"></span><br><span class="line">#方式2：子查询</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">		SELECT salary</span><br><span class="line">		FROM employees</span><br><span class="line">		WHERE last_name = &#x27;Abel&#x27;</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line"># 结论：自连接效率比子查询效率高！</span><br><span class="line">-- DBMS对自连接有优化，而子查询会对未知表进行查询后判断，优化原则：能写多表连接就不要子查询，具体到下篇再说</span><br></pre></td></tr></table></figure>



<h2 id="6-课后练习"><a href="#6-课后练习" class="headerlink" title="6. 课后练习"></a>6. 课后练习</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 子查询：①从里往外（结构复杂：逐个分析），②从外往里（子查询简单）</span><br><span class="line"># 简单的相关子查询通常从外到里</span><br><span class="line"></span><br><span class="line">#1.查询和Zlotkey相同部门的员工姓名和工资</span><br><span class="line">SELECT department_id, last_name, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id IN (</span><br><span class="line">		SELECT department_id</span><br><span class="line">		FROM employees</span><br><span class="line">		WHERE last_name = &#x27;Zlotkey&#x27;</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2.查询工资比公司平均工资高的员工的员工号，姓名和工资。</span><br><span class="line">SELECT employee_id, last_name, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">	SELECT AVG(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.选择工资大于所有JOB_ID =&#x27;SA_MAN&#x27;的员工的工资的员工的last_name，job_id， salary</span><br><span class="line">SELECT last_name, job_id, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; ALL (</span><br><span class="line">	SELECT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id = &#x27;SA_MAN&#x27;</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">-- 子查询产生的派生表要有别名，不需要用引号括起来</span><br><span class="line">SELECT e1.last_name, e1.job_id, e1.salary</span><br><span class="line">FROM employees e1</span><br><span class="line">WHERE e1.salary &gt; (</span><br><span class="line">	SELECT MAX(SA_MAN_sal)</span><br><span class="line">	FROM (</span><br><span class="line">		SELECT salary &quot;SA_MAN_sal&quot;</span><br><span class="line">		FROM employees e2</span><br><span class="line">		WHERE job_id = &quot;SA_MAN&quot;</span><br><span class="line">	) t_SA_MAN_SAL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#4.查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名</span><br><span class="line">SELECT e1.employee_id, e1.last_name</span><br><span class="line">FROM employees e1</span><br><span class="line">WHERE e1.department_id IN</span><br><span class="line">(</span><br><span class="line">	SELECT DISTINCT e2.department_id </span><br><span class="line">	FROM employees e2</span><br><span class="line">	WHERE last_name LIKE &#x27;%u%&#x27;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5.查询在部门的location_id为1700的部门工作的员工的员工号</span><br><span class="line">SELECT employee_id</span><br><span class="line">FROM employees e</span><br><span class="line">WHERE EXISTS (</span><br><span class="line">	SELECT *</span><br><span class="line">	FROM departments d </span><br><span class="line">	WHERE e.department_id = d.`department_id`</span><br><span class="line">	AND location_id = 1700</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">-- 不相关查询写法</span><br><span class="line">SELECT e.employee_id</span><br><span class="line">FROM employees e</span><br><span class="line">WHERE e.department_id IN (</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM departments d </span><br><span class="line">	WHERE location_id = 1700</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#6.查询管理者是King的员工姓名和工资</span><br><span class="line">SELECT e1.last_name, e1.salary</span><br><span class="line">FROM employees e1</span><br><span class="line">WHERE e1.manager_id IN (</span><br><span class="line">	SELECT e2.employee_id</span><br><span class="line">	FROM employees e2</span><br><span class="line">	WHERE e2.last_name = &#x27;King&#x27;</span><br><span class="line">	)</span><br><span class="line">	</span><br><span class="line">-- EXISTS写法</span><br><span class="line">SELECT last_name, salary</span><br><span class="line">FROM employees e1</span><br><span class="line">WHERE EXISTS (</span><br><span class="line">	SELECT *</span><br><span class="line">	FROM employees e2</span><br><span class="line">	WHERE e1.`manager_id` = e2.`employee_id`</span><br><span class="line">	AND e2.`last_name` = &#x27;King&#x27;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#7.查询工资最低的员工信息:last_name，salary</span><br><span class="line"></span><br><span class="line">SELECT e1.`last_name`, e1.`salary`</span><br><span class="line">FROM employees e1</span><br><span class="line">WHERE salary &lt;= ALL(</span><br><span class="line">	SELECT salary</span><br><span class="line">	FROM employees e2</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#8.查询平均工资最低的部门信息(结构复杂，从里到外写)</span><br><span class="line">-- 1. 查找每个部门的平均工资</span><br><span class="line">SELECT AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">-- 2. 查找最低的平均工资</span><br><span class="line">SELECT MIN(avg_sal)</span><br><span class="line">FROM (</span><br><span class="line">	SELECT AVG(salary) avg_sal</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">) t_dept_avg_sal</span><br><span class="line"></span><br><span class="line">-- 3. 获取到对应的部门</span><br><span class="line">SELECT department_id </span><br><span class="line">FROM employees </span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary) = (</span><br><span class="line">	SELECT MIN(avg_sal)</span><br><span class="line">	FROM (</span><br><span class="line">		SELECT AVG(salary) avg_sal</span><br><span class="line">		FROM employees</span><br><span class="line">		GROUP BY department_id</span><br><span class="line">	) t_dept_avg_sal</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">-- 4. 通过部门id，输出所有部门的信息</span><br><span class="line">SELECT *</span><br><span class="line">FROM departments</span><br><span class="line">WHERE department_id IN(</span><br><span class="line">	SELECT department_id </span><br><span class="line">	FROM employees </span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	HAVING AVG(salary) = (</span><br><span class="line">		SELECT MIN(avg_sal)</span><br><span class="line">		FROM (</span><br><span class="line">			SELECT AVG(salary) avg_sal</span><br><span class="line">			FROM employees</span><br><span class="line">			GROUP BY department_id</span><br><span class="line">		) t_dept_avg_sal</span><br><span class="line">	)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">-- 我用不相关子查询的写法(方式2：少了一层)</span><br><span class="line">SELECT *</span><br><span class="line">FROM departments</span><br><span class="line">WHERE department_id IN (</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	HAVING AVG(salary) &lt;= ALL(</span><br><span class="line">		SELECT AVG(salary)</span><br><span class="line">		FROM employees</span><br><span class="line">		GROUP BY department_id</span><br><span class="line">	)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 方式3：LIMIT + 排序获取到最大值</span><br><span class="line">SELECT AVG(salary) avg_sal</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY avg_sal ASC</span><br><span class="line">LIMIT 0, 1</span><br><span class="line"></span><br><span class="line">-- 合并后</span><br><span class="line">SELECT *</span><br><span class="line">FROM departments</span><br><span class="line">WHERE department_id IN (</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	HAVING AVG(salary) = (</span><br><span class="line">		SELECT AVG(salary) avg_sal</span><br><span class="line">		FROM employees</span><br><span class="line">		GROUP BY department_id</span><br><span class="line">		ORDER BY avg_sal ASC</span><br><span class="line">		LIMIT 0, 1</span><br><span class="line">	)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 方式4：将部门的平均工资作为一个临时表，然后使用多表查询</span><br><span class="line">SELECT d.*</span><br><span class="line">FROM departments d, (</span><br><span class="line">	SELECT department_id, AVG(salary) avg_sal</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	ORDER BY avg_sal ASC</span><br><span class="line">	LIMIT 0, 1</span><br><span class="line">	) t_dept_avg_sal</span><br><span class="line">WHERE d.department_id = t_dept_avg_sal.department_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#9.查询平均工资最低的部门信息和该部门的平均工资(相关子查询)</span><br><span class="line">-- 我的写法</span><br><span class="line">SELECT e1.`department_id`, d.department_name, AVG(e1.`salary`) &quot;avg_sal&quot;</span><br><span class="line">FROM employees e1 LEFT JOIN departments d</span><br><span class="line">ON e1.`department_id` = d.department_id</span><br><span class="line">GROUP BY e1.department_id</span><br><span class="line">HAVING AVG(e1.`salary`) &lt;= ALL (</span><br><span class="line">	SELECT AVG(salary)</span><br><span class="line">	FROM employees e2</span><br><span class="line">	GROUP BY e2.department_id</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">-- 宋老师的写法：在select中使用子查询</span><br><span class="line">SELECT *, (SELECT AVG(salary) FROM employees WHERE department_id = d.department_id) avg_sal</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE department_id IN (</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	HAVING AVG(salary) &lt;= ALL(</span><br><span class="line">		SELECT AVG(salary)</span><br><span class="line">		FROM employees</span><br><span class="line">		GROUP BY department_id</span><br><span class="line">	)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#10.查询平均工资最高的 job 信息(也有4种写法)</span><br><span class="line">SELECT *</span><br><span class="line">FROM jobs</span><br><span class="line">WHERE job_id = (</span><br><span class="line">	SELECT job_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY job_id</span><br><span class="line">	HAVING AVG(salary) = (</span><br><span class="line">		SELECT MAX(avg_sal)</span><br><span class="line">		FROM(</span><br><span class="line">			SELECT AVG(salary) avg_sal</span><br><span class="line">			FROM employees</span><br><span class="line">			GROUP BY job_id</span><br><span class="line">			)t_job_avg_sal</span><br><span class="line">	)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 方式2 方式3 方式4省略，同第8题</span><br><span class="line"></span><br><span class="line">-- 我的写法</span><br><span class="line">SELECT job_id, AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id</span><br><span class="line">HAVING AVG(salary) &gt;= ALL (</span><br><span class="line">		SELECT AVG(salary)</span><br><span class="line">		FROM employees</span><br><span class="line">		GROUP BY job_id</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">#11.查询平均工资高于公司平均工资的部门有哪些?</span><br><span class="line">SELECT e1.`department_id`</span><br><span class="line">FROM employees e1</span><br><span class="line">WHERE department_id IS NOT NULL</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary) &gt; (</span><br><span class="line">	SELECT AVG(e2.`salary`)</span><br><span class="line">	FROM employees e2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#12.查询出公司中所有 manager 的详细信息</span><br><span class="line">SELECT mgr.last_name </span><br><span class="line">FROM employees mgr</span><br><span class="line">WHERE EXISTS (</span><br><span class="line">	SELECT *</span><br><span class="line">	FROM employees emp</span><br><span class="line">	WHERE emp.manager_id = mgr.employee_id</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">-- EXISTS和IN通常可以互相改写</span><br><span class="line">SELECT mgr.last_name </span><br><span class="line">FROM employees mgr</span><br><span class="line">WHERE mgr.employee_id IN (</span><br><span class="line">	SELECT emp.manager_id</span><br><span class="line">	FROM employees emp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">-- 自连接优化</span><br><span class="line">SELECT DISTINCT mgr.last_name</span><br><span class="line">FROM employees emp JOIN employees mgr</span><br><span class="line">ON emp.manager_id = mgr.employee_id</span><br><span class="line"></span><br><span class="line">#13.各个部门中 最高工资中最低的那个部门的 最低工资是多少?</span><br><span class="line">-- 这里也有四种写法</span><br><span class="line"></span><br><span class="line">SELECT MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = (</span><br><span class="line">	SELECT e1.`department_id`</span><br><span class="line">	FROM employees e1</span><br><span class="line">	GROUP BY e1.department_id</span><br><span class="line">	HAVING MAX(e1.salary) &lt;= ALL(</span><br><span class="line">		SELECT MAX(salary)</span><br><span class="line">		FROM employees e2</span><br><span class="line">		GROUP BY e2.department_id</span><br><span class="line">	)</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">SELECT MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = (</span><br><span class="line">	SELECT e1.`department_id`</span><br><span class="line">	FROM employees e1</span><br><span class="line">	GROUP BY e1.department_id</span><br><span class="line">	HAVING MAX(e1.salary) = (</span><br><span class="line">		SELECT MAX(salary) max_sal</span><br><span class="line">		FROM employees e2</span><br><span class="line">		GROUP BY e2.department_id</span><br><span class="line">		ORDER BY max_sal DESC</span><br><span class="line">		LIMIT 0, 1 </span><br><span class="line">	)</span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">SELECT MIN(e.`salary`)</span><br><span class="line">FROM employees e, (</span><br><span class="line">	SELECT e1.`department_id`</span><br><span class="line">	FROM employees e1</span><br><span class="line">	GROUP BY e1.department_id</span><br><span class="line">	HAVING MAX(e1.salary) = (</span><br><span class="line">		SELECT MAX(salary) max_sal</span><br><span class="line">		FROM employees e2</span><br><span class="line">		GROUP BY e2.department_id</span><br><span class="line">		ORDER BY max_sal ASC</span><br><span class="line">		LIMIT 0, 1 </span><br><span class="line">	)</span><br><span class="line">) t_dept_max_sal</span><br><span class="line">WHERE e.department_id = t_dept_max_sal.department_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#14.查询平均工资最高的部门的 manager 的详细信息:last_name,department_id，email，salary</span><br><span class="line">SELECT last_name, department_id, email, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id IN(</span><br><span class="line">	SELECT DISTINCT manager_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE department_id = (</span><br><span class="line">		SELECT department_id</span><br><span class="line">		FROM employees</span><br><span class="line">		GROUP BY department_id</span><br><span class="line">		HAVING AVG(salary) &gt;= ALL(</span><br><span class="line">			SELECT AVG(salary)</span><br><span class="line">			FROM employees</span><br><span class="line">			GROUP BY department_id</span><br><span class="line">		)</span><br><span class="line">		)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT last_name, department_id, email, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id IN(</span><br><span class="line">	SELECT DISTINCT manager_id</span><br><span class="line">	FROM employees e, (</span><br><span class="line">		SELECT department_id, AVG(salary) avg_sal</span><br><span class="line">		FROM employees</span><br><span class="line">		GROUP BY department_id</span><br><span class="line">		HAVING AVG(salary) &gt;= ALL(</span><br><span class="line">			SELECT AVG(salary)</span><br><span class="line">			FROM employees</span><br><span class="line">			GROUP BY department_id</span><br><span class="line">		)) t_dept_max_sal</span><br><span class="line">	WHERE e.`department_id` = t_dept_max_sal.department_id</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#15.查询部门的部门号，其中不包括job_id是&quot;ST_CLERK&quot;的部门号</span><br><span class="line">-- 注意要查询所有部门的，因此最外层需要在departments表找</span><br><span class="line">SELECT DISTINCT d.`department_id`</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE NOT EXISTS(</span><br><span class="line">	SELECT *</span><br><span class="line">	FROM employees e</span><br><span class="line">	WHERE e.`department_id` = d.`department_id`</span><br><span class="line">	AND e.`job_id` = &#x27;ST_CLERK&#x27;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT d.`department_id`</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE d.`department_id` NOT IN (</span><br><span class="line">	SELECT DISTINCT e.`department_id`</span><br><span class="line">	FROM employees e</span><br><span class="line">	WHERE e.`job_id` = &#x27;ST_CLERK&#x27;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#16.选择所有没有管理者的员工的last_name</span><br><span class="line"></span><br><span class="line">-- 老师写法</span><br><span class="line">SELECT last_name</span><br><span class="line">FROM employees e1</span><br><span class="line">WHERE NOT EXISTS(</span><br><span class="line">	SELECT *</span><br><span class="line">	FROM employees e2</span><br><span class="line">	WHERE e1.`manager_id` = e2.`employee_id`</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#17.查询员工号、姓名、雇用时间、工资，其中员工的管理者为&#x27;De Haan</span><br><span class="line">SELECT emp.employee_id, emp.last_name, emp.hire_date, emp.salary, emp.`manager_id`</span><br><span class="line">FROM employees emp</span><br><span class="line">WHERE EXISTS</span><br><span class="line">	(</span><br><span class="line">	SELECT *</span><br><span class="line">	FROM employees mgr</span><br><span class="line">	WHERE emp.`manager_id` = mgr.`employee_id`</span><br><span class="line">	AND mgr.last_name = &#x27;De Haan&#x27;</span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">-- 优化：自连接</span><br><span class="line">SELECT emp.employee_id, emp.last_name, emp.hire_date, emp.salary, emp.`manager_id`</span><br><span class="line">FROM employees emp JOIN employees mgr</span><br><span class="line">ON emp.`manager_id` = mgr.`employee_id` </span><br><span class="line">WHERE mgr.last_name = &#x27;De Haan&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#18.查询各部门中工资比本部门平均工资高的员工的员工号，姓名和工资(相关子查询)</span><br><span class="line">SELECT employee_id, last_name, salary</span><br><span class="line">FROM employees e1</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">	SELECT AVG(salary)</span><br><span class="line">	FROM employees e2</span><br><span class="line">	WHERE e2.`department_id` = e1.department_id</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#19.查询每个部门下的部门人数大于 5的部门名称(相关子查询)</span><br><span class="line">-- 如果已经相关了department_id，就没有必要再group by了</span><br><span class="line">-- 我本来写的版本</span><br><span class="line">SELECT d.department_name</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE EXISTS(</span><br><span class="line">	SELECT *</span><br><span class="line">	FROM employees e</span><br><span class="line">	WHERE e.`department_id` = d.department_id</span><br><span class="line">	# GROUP BY department_id</span><br><span class="line">	HAVING COUNT(*) &gt; 5</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">-- 老师写的版本</span><br><span class="line">SELECT d.department_name</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE 5 &lt; (</span><br><span class="line">	SELECT COUNT(*)</span><br><span class="line">	FROM employees e</span><br><span class="line">	WHERE e.`department_id` = d.department_id</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#20.查询每个国家下的部门个数大于 2的国家编号(相关子查询)</span><br><span class="line">-- 原来写的，写错了</span><br><span class="line">SELECT d.location_id</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE EXISTS(</span><br><span class="line">	SELECT 1</span><br><span class="line">	FROM employees e</span><br><span class="line">	WHERE e.`department_id` = d.department_id</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">	HAVING COUNT(*) &gt; 2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT l.country_id</span><br><span class="line">FROM locations l</span><br><span class="line">WHERE 2 &lt; (</span><br><span class="line">	SELECT  COUNT(*)</span><br><span class="line">	FROM departments d</span><br><span class="line">	WHERE d.`location_id` = l.location_id</span><br><span class="line">)</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yuezi2048.github.io">yuezi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yuezi2048.github.io/2024/08/15/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/09.%E5%AD%90%E6%9F%A5%E8%AF%A2/">https://yuezi2048.github.io/2024/08/15/2.Areas🌐/back-end-java/2.MySQL/基础篇/09.子查询/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://yuezi2048.github.io" target="_blank">yuezi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%AF%87/">基础篇</a></div><div class="post-share"><div class="social-share" data-image="/img/touxiang.jpg" data-sites="qq,wechat"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/08/14/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/00.%E5%9F%BA%E7%A1%80%E7%AF%87%E5%86%85%E5%AE%B9%E6%A1%86%E6%9E%B6/" title="00.基础篇内容框架"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">00.基础篇内容框架</div></div><div class="info-2"><div class="info-item-1">MySQL数据库基础篇分为5个篇章： 1. 数据库概述与MySQL安装篇  第01章：数据库概述 第02章：MySQL环境搭建  2. SQL之SELECT使用篇  第03章：基本的SELECT语句 第04章：运算符 第05章：排序与分页 第06章：多表查询 第07章：单行函数 第08章：聚合函数 第09章：子查询  3. SQL之DDL、DML、DCL使用篇  第10章：创建和管理表 第11章：数据处理之增删改 第12章：MySQL数据类型精讲 第13章：约束  4. 其它数据库对象篇（开发用到了再学）  第14章：视图 第15章：存储过程与函数 第16章：变量、流程控制与游标 第17章：触发器  5. MySQL8 新特性篇（开发用到了再学）  第18章：MySQL8其它新特性  ps：普通开发往往积累单点技术、比如 CRUD、锁类型、索引的数据结构… 而对于技术骨干、架构师则往往需要对底层原理吃透：  数据库事务 ACID...</div></div></div></a><a class="pagination-related" href="/2024/08/16/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/03.%E5%9F%BA%E6%9C%ACSELECT%E8%AF%AD%E5%8F%A5/" title="03.基本SELECT语句"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">03.基本SELECT语句</div></div><div class="info-2"><div class="info-item-1">三、基本SELECT语句1. SQL概述1.1 SQL背景 1946 年，世界上第一台电脑诞生，如今，借由这台电脑发展起来的互联网已经自成江湖。在这几十年里，无数的技术、产业在这片江湖里沉浮，有的方兴未艾，有的已经几幕兴衰。但在这片浩荡的波动里，有一门技术从未消失，甚至“老当益壮”，那就是 SQL。  45 年前，也就是 1974 年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语言，SQL 的半衰期可以说是非常长了。   不论是前端工程师，还是后端算法工程师，都一定会和数据打交道，都需要了解如何又快又准确地提取自己想要的数据。更别提数据分析师了，他们的工作就是和数据打交道，整理不同的报告，以便指导业务决策。  SQL（Structured Query...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/08/14/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/00.%E5%9F%BA%E7%A1%80%E7%AF%87%E5%86%85%E5%AE%B9%E6%A1%86%E6%9E%B6/" title="00.基础篇内容框架"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-14</div><div class="info-item-2">00.基础篇内容框架</div></div><div class="info-2"><div class="info-item-1">MySQL数据库基础篇分为5个篇章： 1. 数据库概述与MySQL安装篇  第01章：数据库概述 第02章：MySQL环境搭建  2. SQL之SELECT使用篇  第03章：基本的SELECT语句 第04章：运算符 第05章：排序与分页 第06章：多表查询 第07章：单行函数 第08章：聚合函数 第09章：子查询  3. SQL之DDL、DML、DCL使用篇  第10章：创建和管理表 第11章：数据处理之增删改 第12章：MySQL数据类型精讲 第13章：约束  4. 其它数据库对象篇（开发用到了再学）  第14章：视图 第15章：存储过程与函数 第16章：变量、流程控制与游标 第17章：触发器  5. MySQL8 新特性篇（开发用到了再学）  第18章：MySQL8其它新特性  ps：普通开发往往积累单点技术、比如 CRUD、锁类型、索引的数据结构… 而对于技术骨干、架构师则往往需要对底层原理吃透：  数据库事务 ACID...</div></div></div></a><a class="pagination-related" href="/2024/08/14/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/" title="01.数据库概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-14</div><div class="info-item-2">01.数据库概述</div></div><div class="info-2"><div class="info-item-1">一、数据库概述1. 为什么要数据库 数据的持久化：将数据保存到硬盘上，可供可掉电式的存储设备使用，大多使用关系数据库实现（也可以通过文件I&#x2F;O、XML实现）  	 2. DB 和 DBMS2.1 概述 数据库DB：存储数据的仓库，本质上是一个文件系统，保存一系列有组织的数据 数据库管理系统DBMS：管理和操纵数据库的大型软件，从而建立、使用和维护数据库。用户可以使用DBMS查询数据库的数据 结构化查询语言SQL：用于数据库交互的语言  其中，DBMS可以管理多个DB，开发中，通常针对每个应用创建一个数据库，并在一个数据库中创建多个表，从而保存实体用户的数据 	 2.2 常见DBMS常见的DBMS 参考数据库最新排名:https://db-engines.com/en/ranking 	 发展趋势：https://db-engines.com/en/ranking_trend 	 Oracle 1979 年，Oracle 2 诞生，它是第一个商用的 RDBMS（关系型数据库管理系统）。随着 Oracle 软件的名气越来越大，公司也改名叫 Oracle...</div></div></div></a><a class="pagination-related" href="/2025/05/25/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/02.MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="02.MySQL环境搭建"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-25</div><div class="info-item-2">02.MySQL环境搭建</div></div><div class="info-2"><div class="info-item-1">二、MySQL环境搭建1. 清除原有MySQL环境Step1：停止MySQL服务 	 Step2：软件卸载  亦可通过mysql-installer-community-8.0.26.0.msi卸载，此时安装目录也会被移除  	 Step3：残余文件清理 如果再次安装不成功，可以卸载后对残余文件进行清理后再安装。 （1）服务目录：mysql服务的安装目录 （2）数据目录：默认在C:\ProgramData\MySQL 注意：请在卸载前做好数据备份 在操作完以后，需要重启计算机，然后进行安装即可。如果仍然安装失败，需要继续操作如下步骤4。 Step4：清理注册表 在系统的搜索框中输入regedit HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL服务 目录删除HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\MySQL服务...</div></div></div></a><a class="pagination-related" href="/2024/08/16/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/03.%E5%9F%BA%E6%9C%ACSELECT%E8%AF%AD%E5%8F%A5/" title="03.基本SELECT语句"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-16</div><div class="info-item-2">03.基本SELECT语句</div></div><div class="info-2"><div class="info-item-1">三、基本SELECT语句1. SQL概述1.1 SQL背景 1946 年，世界上第一台电脑诞生，如今，借由这台电脑发展起来的互联网已经自成江湖。在这几十年里，无数的技术、产业在这片江湖里沉浮，有的方兴未艾，有的已经几幕兴衰。但在这片浩荡的波动里，有一门技术从未消失，甚至“老当益壮”，那就是 SQL。  45 年前，也就是 1974 年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语言，SQL 的半衰期可以说是非常长了。   不论是前端工程师，还是后端算法工程师，都一定会和数据打交道，都需要了解如何又快又准确地提取自己想要的数据。更别提数据分析师了，他们的工作就是和数据打交道，整理不同的报告，以便指导业务决策。  SQL（Structured Query...</div></div></div></a><a class="pagination-related" href="/2025/04/24/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/04.%E8%BF%90%E7%AE%97%E7%AC%A6/" title="04.运算符"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-24</div><div class="info-item-2">04.运算符</div></div><div class="info-2"><div class="info-item-1">四、运算符1. 算数运算符算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（*）、除（&#x2F;）和取模（%）运算。 1.1 加减法# 算数运算符：+ - * / div % mod SELECT 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 - 30, 100 + 35.5, 100 - 35.5FROM DUAL;+-----+---------+---------+----------+--------------+------------+------------+| 100 | 100 + 0 | 100 - 0 | 100 + 50 | 100 + 50 -30 | 100 + 35.5 | 100 - 35.5 |+-----+---------+---------+----------+--------------+------------+------------+| 100 |     100 |     100 |      150 |         ...</div></div></div></a><a class="pagination-related" href="/2025/05/28/2.Areas%F0%9F%8C%90/back-end-java/2.MySQL/%E5%9F%BA%E7%A1%80%E7%AF%87/05.%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E9%A1%B5/" title="05.排序和分页"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-28</div><div class="info-item-2">05.排序和分页</div></div><div class="info-2"><div class="info-item-1">五、排序和分页1. 排序1.1 单列排序 使用 ORDER BY 子句排序 ASC（ascend）: 升序 DESC（descend）:降序   ORDER BY 子句在SELECT语句的结尾。 关注SELECT查询的顺序，实际场景：别名不能在where从句中使用，而可以在order by中使用  # 1. 一级排序# 如果没有使用排序操作，默认情况下查询返回的数据按照添加数据的顺序SELECT * FROM employees;-- 1.1 基本使用# 练习：按照salary从高到低显示数据(ORDER BY 通过什么来排序)# 升序:ASC(ascend) 降序：DESC(descend)SELECT employee_id, last_name, salaryFROM employeesORDER BY salary DESC;# 从低到高(没有显式写，默认升序)SELECT employee_id, last_name, salaryFROM employeesORDER BY salary ASC;-- 2. 别名# 使用列的别名进行排序SELECT...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yuezi</div><div class="author-info-description">积微者速成</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">603</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuezi2048"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">积微者速成</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">九、子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E5%92%8C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-text">1. 需求分析和问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98"><span class="toc-text">1.1 实际问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">1.2 子查询的基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">1.3 子查询的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8D%95%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">2. 单行子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8D%95%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5"><span class="toc-text">2.1 单行子查询语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%A9%BA%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-text">2.2 子查询的空值问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%8D%95%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2%E9%9D%9E%E6%B3%95%E4%BD%BF%E7%94%A8"><span class="toc-text">2.3 单行子查询非法使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%9A%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">3. 多行子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%A4%9A%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">3.1 多行子查询的操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%A4%9A%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5"><span class="toc-text">3.2 多行子查询语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%A4%9A%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%A9%BA%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-text">3.3 多行子查询空值问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">4. 相关子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">4.1 执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5"><span class="toc-text">4.2 相关子查询语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-EXISTS%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">4.3 EXISTS关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%9B%B8%E5%85%B3%E6%9B%B4%E6%96%B0"><span class="toc-text">4.4 相关更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E7%9B%B8%E5%85%B3%E5%88%A0%E9%99%A4"><span class="toc-text">4.5 相关删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%80%9D%E8%80%83%EF%BC%9A%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98"><span class="toc-text">5. 思考：子查询的效率问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0"><span class="toc-text">6. 课后练习</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/Excalidraw/Drawing%202024-11-01%2015.37.37.excalidraw/" title="Drawing 2024-11-01 15.37.37.excalidraw">Drawing 2024-11-01 15.37.37.excalidraw</a><time datetime="2025-10-31T04:19:26.621Z" title="发表于 2025-10-31 12:19:26">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/01.project/condefather/yupao/back-end/7.%E4%BC%98%E5%8C%96%E4%B8%BB%E9%A1%B5%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/" title="7.优化主页性能-优化批量导入数据">7.优化主页性能-优化批量导入数据</a><time datetime="2025-10-31T04:19:26.102Z" title="发表于 2025-10-31 12:19:26">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/81.%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B8%E6%A0%87Cursor%E5%88%86%E9%A1%B5_%E5%AF%B9%E6%AF%94%E4%BC%A0%E7%BB%9FLIMIT_OFFSET%E5%88%86%E9%A1%B5%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88/" title="81.什么是游标Cursor分页_对比传统LIMIT_OFFSET分页的优势是什么">81.什么是游标Cursor分页_对比传统LIMIT_OFFSET分页的优势是什么</a><time datetime="2025-10-31T04:14:27.000Z" title="发表于 2025-10-31 12:14:27">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/80.%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E5%90%84%E8%87%AA%E4%BC%98%E7%BC%BA%E7%82%B9/" title="80.全量同步和增量同步各自优缺点">80.全量同步和增量同步各自优缺点</a><time datetime="2025-10-31T04:13:32.000Z" title="发表于 2025-10-31 12:13:32">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/2.Areas%F0%9F%8C%90/02.%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/MySQL/79.%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93_%E7%9B%B8%E6%AF%94%E5%8D%95%E6%9D%A1%E6%8F%92%E5%85%A5%E4%BC%98%E5%8A%BF/" title="79.什么是批量数据入库_相比单条插入优势">79.什么是批量数据入库_相比单条插入优势</a><time datetime="2025-10-31T04:03:26.000Z" title="发表于 2025-10-31 12:03:26">2025-10-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/default.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By yuezi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>