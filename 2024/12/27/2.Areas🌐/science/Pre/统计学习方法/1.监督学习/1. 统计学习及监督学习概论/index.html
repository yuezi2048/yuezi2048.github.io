<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>1. 统计学习及监督学习概论 | yuezi</title><meta name="author" content="yuezi"><meta name="copyright" content="yuezi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] 一、统计学习及监督学习概论1.1 统计学习 统计学习是计算机系统通过运用数据及统计方法  提高系统性能的机器学习 统计学习研究的对象是数据，提取数据特征，抽象模型，而后回归到数据的分析和预测 基本假设：同类数据具有统计规律性   统计学习的方法包括：监督学习、无监督学习、强化学习 假设数据是独立同分布的，并假设学习的模型属于某个函数的集合（假设空间） 应用某个评价准则，从假设空间中选取">
<meta property="og:type" content="article">
<meta property="og:title" content="1. 统计学习及监督学习概论">
<meta property="og:url" content="https://yuezi2048.github.io/2024/12/27/2.Areas%F0%9F%8C%90/science/Pre/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/1.%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/1.%20%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/index.html">
<meta property="og:site_name" content="yuezi">
<meta property="og:description" content="[TOC] 一、统计学习及监督学习概论1.1 统计学习 统计学习是计算机系统通过运用数据及统计方法  提高系统性能的机器学习 统计学习研究的对象是数据，提取数据特征，抽象模型，而后回归到数据的分析和预测 基本假设：同类数据具有统计规律性   统计学习的方法包括：监督学习、无监督学习、强化学习 假设数据是独立同分布的，并假设学习的模型属于某个函数的集合（假设空间） 应用某个评价准则，从假设空间中选取">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuezi2048.github.io/img/touxiang.jpg">
<meta property="article:published_time" content="2024-12-27T03:11:07.000Z">
<meta property="article:modified_time" content="2024-12-27T03:11:07.000Z">
<meta property="article:author" content="yuezi">
<meta property="article:tag" content="1.监督学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuezi2048.github.io/img/touxiang.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "1. 统计学习及监督学习概论",
  "url": "https://yuezi2048.github.io/2024/12/27/2.Areas%F0%9F%8C%90/science/Pre/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/1.%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/1.%20%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/",
  "image": "https://yuezi2048.github.io/img/touxiang.jpg",
  "datePublished": "2024-12-27T03:11:07.000Z",
  "dateModified": "2024-12-27T03:11:07.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "yuezi",
      "url": "https://yuezi2048.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuezi2048.github.io/2024/12/27/2.Areas%F0%9F%8C%90/science/Pre/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/1.%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/1.%20%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?bfb48b678d82bea9f9cc9d59227767e4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"FPH6F2TOJL","apiKey":"06d9ea26c803ba912b4d8e13404ed34d","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '1. 统计学习及监督学习概论',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/backgound.css"><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">785</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">91</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yuezi</span></a><a class="nav-page-title" href="/"><span class="site-name">1. 统计学习及监督学习概论</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">1. 统计学习及监督学习概论</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-27T03:11:07.000Z" title="发表于 2024-12-27 11:11:07">2024-12-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-27T03:11:07.000Z" title="更新于 2024-12-27 11:11:07">2024-12-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/">2.Areas🌐</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/science/">science</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/science/Pre/">Pre</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/science/Pre/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/">统计学习方法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-Areas%F0%9F%8C%90/science/Pre/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/1-%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/">1.监督学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[TOC]</p>
<h1 id="一、统计学习及监督学习概论"><a href="#一、统计学习及监督学习概论" class="headerlink" title="一、统计学习及监督学习概论"></a>一、统计学习及监督学习概论</h1><h2 id="1-1-统计学习"><a href="#1-1-统计学习" class="headerlink" title="1.1 统计学习"></a>1.1 统计学习</h2><ul>
<li><code>统计学习</code>是计算机系统通过运用数据及统计方法  提高系统性能的机器学习</li>
<li>统计学习研究的对象是数据，提取数据特征，抽象模型，而后回归到数据的分析和预测<ul>
<li>基本假设：同类数据具有统计规律性</li>
</ul>
</li>
<li>统计学习的方法包括：监督学习、无监督学习、强化学习<ul>
<li>假设数据是<code>独立同分布</code>的，并假设学习的模型属于某个函数的集合（<code>假设空间</code>）</li>
<li>应用某个<code>评价准则</code>，从假设空间中选取最优模型，使他对<code>测试数据</code>在给定的评价准则下由最优的预测，而最优模型的选取由<code>算法</code>实现</li>
<li>因此统计学习方法的三要素：<code>模型</code>、<code>策略</code>、<code>算法</code></li>
</ul>
</li>
<li>统计学习的步骤<ul>
<li>得到有限的<code>训练数据</code>集合</li>
<li>确定包含所有可能的模型假设空间（学习<code>模型的集合</code>）</li>
<li>确定模型选择的准则，即学习的<code>策略</code></li>
<li>通过学习<code>算法</code>选择最优模型</li>
<li>利用学习的最优模型对新数据进行<code>预测和分析</code></li>
</ul>
</li>
</ul>
<h2 id="1-2-统计学习的分类"><a href="#1-2-统计学习的分类" class="headerlink" title="1.2 统计学习的分类"></a>1.2 统计学习的分类</h2><h3 id="1-2-1-基本分类"><a href="#1-2-1-基本分类" class="headerlink" title="1.2.1 基本分类"></a>1.2.1 基本分类</h3><p>监督学习、无监督学习、强化学习</p>
<h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><ul>
<li>输入和输出所有取值的集合分别叫做<code>输入空间</code>和<code>输出空间</code>，通常输出空间远小于输入空间</li>
<li>每个具体的输入叫做<code>实例</code>，通常由<code>特征向量</code>表示，特征向量存在的空间称为<code>特征空间</code>，特征空间的每一维对应于一个特征<ul>
<li>有时输入空间与特征空间会有不同的空间（例如PCA降维 拿掉输入空间中没有贡献的特征）</li>
</ul>
</li>
<li>在监督学习中，<code>输入输出</code>看作是在输入空间和输出空间上随机变量的取值，输入输出变量使用大写字母X Y表示，取值则用小写字母x y表示，变量可以是标量、也可以是<code>向量</code>，这里列向量表示一个输入变量的取值的表示如下，<strong>头标x^(i)表示第i个特征，角标xi表示输入变量中的第i个变量</strong></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240923113135211.png" alt="image-20240923113135211">	</p>
<ul>
<li>监督学习从训练数据中学习模型，对测试数据进行预测，而数据集通常是输入（或特征向量）输出对组成，称为<code>样本</code>、<code>样本点</code></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240923113605582.png" alt="image-20240923113605582">	</p>
<ul>
<li>X和Y具有<code>联合概率分布</code>是监督学习关于数据的基本假设</li>
<li>我们需要找到一个通用表示输入到输出映射的最优模型，那么对于输入空间到输出空间映射的所有集合，我们称为<code>假设空间</code><ul>
<li>监督模型模型可以是<code>概率模型 </code>也可以<code>是非概率模型</code>，分别由<code>条件概率分布</code>P(Y | X) 和 <code>决策函数</code> Y &#x3D; f(X) 表示（比如输入男 女性别，输出身高，那么这是一个条件概率分布）</li>
</ul>
</li>
<li>给出一个具体的从学习到预测的执行样例</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240923113942932.png" alt="image-20240923113942932">	</p>
<h4 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h4><ul>
<li><code>无监督学习</code>是从无标注中学习预测模型的问题</li>
<li>输入空间与输出空间可以是有限空间的集合，也可以是<code>欧式空间</code><ul>
<li>每个输入是一个实例，由<code>特征向量</code>表示</li>
<li>而每个输出是对输入的分析结果，由输入的<code>类别</code>、<code>转换</code>（pca降维 svd奇异值分析）、<code>概率</code>（硬聚类 &#x2F; 软聚类）表示 –》(聚类、降维、概率估计)</li>
</ul>
</li>
<li>无监督学习分析时分别对应的模型包括：函数 z &#x3D; g(x)， 条件概率分布P(z | x)，条件概率分布 P(x | z)</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240923123750550.png" alt="image-20240923123750550">	</p>
<h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><ul>
<li><code>强化学习</code>是只能系统与环境连续互动中学习最优行为策略的问题</li>
<li>以<code>马尔可夫决策过程</code>为例，得到的是与环境互动之后的数据序列 –&gt; 强化学习的本质是<code>学习最优的序贯决策</code></li>
<li>给出具体的互动过程，每一步t的时候，会有一个<code>状态</code>(state) ，和下一个<code>奖励</code>(reward)，采取一个<code>动作</code>(action)，而智能系统根据系统的做动作决定下一步t + 1的状态与奖励（智能系统的目标不是短期奖励的最大化，而是<code>长期累计奖励的最大化</code>，通过不断的试错[<code>trial and error</code>] 来学习最优策略） </li>
<li>理解：假设alpha狗采取短期奖励最大化，那么可能会出现前面针对当前局面局部的完美，但因为最后一步棋 满盘皆输的情况</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240923124202735.png" alt="image-20240923124202735">	</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240923125252291.png" alt="image-20240923125252291">	</p>
<ul>
<li>马尔可夫决策具有<code>马尔科夫性</code>，下一个状态只依赖前一个状态和动作，通过<code>状态转移概率函数</code>表示，下一个奖励依赖于前一个状态和动作，通过奖励函数表示</li>
<li>策略Π定义了一系列动作的函数a&#x3D;f(s)，在该策略下，智能系统和环境的行为就已确定（包括确定性和随机性的行为 射箭的例子 同一套动作会有不同的得分）</li>
<li>给出模型评估准则的<code>价值函数</code>、<code>动作价值函数</code>的概念<ul>
<li>价值函数计算的是以状态s开始后，从下一步t+1 开始每一步奖励总和的期望（通过衰减系数[折扣率y]控制近期的影响）</li>
<li>动作价值函数计算的是以 状态s下执行a动作后，从下一步t+1开始每一步奖励总和的期望</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240923125533990.png" alt="image-20240923125533990">	</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240923125539872.png" alt="image-20240923125539872">	</p>
<ul>
<li>强化模型的方法：<code>有模型</code>的方法、无模型的方法（<code>基于策略</code>、<code>基于价值</code>）<ul>
<li>有模型的方法会直接学习马尔可夫的决策过程，包括转移概率函数和奖励函数，然后通过模型预测最佳策略Π*</li>
<li>无模型的方法<ul>
<li>基于策略：视图求解最优策略Π*，表示为函数a&#x3D;f*(x)或者概率分布P*(a|s) 一个具体策略开始，然后搜索迭代策略</li>
<li>基于价值，求解最优价值函数，特别是最优动作价值函数q*(s , a)，从一个具体价值函数开始，搜索更优的价值函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>给出一个案例来理解无模型的方法，需求：找到马里奥获得宝藏的最短路径动作</p>
<p><code>基于策略</code>的方法如下：</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240923131145088.png" alt="image-20240923131145088">	</p>
<p>初始化策略为： 不论马里奥处于哪个状态， 一律朝下走。 根据这一策略进行策略评估不难发现， 只有宝藏正上方的状态可以到达宝藏， 期望价值为到宝藏的<br>距离（-2， -1和0） ；</p>
<p>其余状态不能通过当前策略到达宝藏， 期望价值为负无穷。</p>
<p>然后根据当前的期望价值进行策略提升： 对于宝藏正上方的状态， 策略已经最优， 保持不变； 对于不在宝藏正上方的状态， 根据策略更新公式 最优策略为横向移动一步。</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240923131209847.png" alt="image-20240923131209847">	</p>
<p>通过上一轮的策略提升， 这一轮的策略变为： 对于宝藏正上方的状态， 向下移动； 对于不在宝藏正上方的状态， 横向移动一步。 </p>
<p>根据当前策略进行策略评估， 更新各状态期望价值： 宝藏正上方的状态价值期望不变， 仍等于到宝藏的距离； 不在宝藏正上方的状态期望价值更新为 ， 即横向移动一步的奖励与目标状态的期望价值之和。 然后根据更新后的期望价值进行策略提升： 不难发现， 对于所有状态， 当前策略已经最优， 维持不变， 中止策略提升过程。</p>
<p>最终， 马里奥只需从初始状态（1,1） 开始， 按照当前位置的最优策略进行行动， 即向右行动一步， 然后一直向下行动， 即可最快找到宝藏。  </p>
<p><code>基于价值</code>的方法如下：</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240923130344791.png" alt="image-20240923130344791">	</p>
<p>首先， 初始化所有状态的价值V(s)&#x3D;0。 然后， 在每一轮迭代中， 对每个状态s依次执行以下步骤（其中，走一步的奖励r &#x3D; -1）。</p>
<ul>
<li><p>逐一尝试{上、 下、 左、 右}四个动作a， 记录到达状态s′和奖励r。</p>
</li>
<li><p>计算每个动作的价值q(s,a) &#x3D; r + V(s′)。</p>
</li>
<li><p>从四个动作中选择最优的动作 。</p>
</li>
<li><p>更新s状态价值。</p>
</li>
</ul>
<p>在第一轮迭代中， 由于初始状态V(s)均为0， 因此对除宝藏所在位置外的状态s均有V(s)&#x3D;r+V(s′)&#x3D;-1+0&#x3D;-1， 即从当前位置出发走一步获得奖励r&#x3D;-1。</p>
<p>在第二轮迭代中， 对于和宝藏位置相邻的状态， 最优动作为一步到达V(s′)&#x3D;0的状态， 即宝藏所在的格子。 因此， V(s)更新为r+V(s′)&#x3D;-1+0&#x3D;-1； 其余只能一步到达V(s′)&#x3D;-1的状态， V(s)更新为r+V(s′)&#x3D;-1+(-1)&#x3D;-2。</p>
<p>第三轮和第四轮迭代如法炮制。 可以发现， 在第四轮迭代中， 所有V(s)更新前后都没有任何变化， 价值迭代已经找到了最优策略。</p>
<p>最终， 只需要从马里奥所在位置开始， 每一步选择最优动作， 即可最快地找到宝藏。</p>
<p>上面的迭代过程实际上运用了贝尔曼方程（Bellman Equation） ， 来对每个位置的价值进行更新  </p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240923131005384.png" alt="image-20240923131005384">	</p>
<p>贝尔曼方程中状态s的价值V(s)由两部分组成：</p>
<ul>
<li>采取动作a后带来的<strong>奖励r</strong>。</li>
<li>采取动作a后到达的<strong>新状态的价值V(s′)</strong>。</li>
</ul>
<p><strong>半监督学习和主动学习</strong></p>
<ul>
<li><code>半监督学习</code>将数据分成了少量标注数据和 大量无标注数据，通过未标注数据的信息来 辅助标注数据，进行监督学习，可以在一定程度降低学习成本</li>
<li><code>主动学习</code>是机器不断给出实例让教师标注，然后通过标注数据来学习预测模型</li>
<li>这两种方式更接近监督学习</li>
</ul>
<h3 id="1-2-2-按模型分类"><a href="#1-2-2-按模型分类" class="headerlink" title="1.2.2 按模型分类"></a>1.2.2 按模型分类</h3><h4 id="概率模型和非概率模型"><a href="#概率模型和非概率模型" class="headerlink" title="概率模型和非概率模型"></a>概率模型和非概率模型</h4><ul>
<li><p>决策树、朴素贝叶斯、隐马尔可夫模型、条件随机场、概率潜在语义分析、潜在狄利克雷分配、高斯混合模型是<code>概率模型</code>。</p>
</li>
<li><p>感知机、支持向量机、k近邻、AdaBoost、k均值、潜在语义分析,以及神经网络是<code>非概率模型</code>。</p>
</li>
<li><p>逻辑斯谛回归既可看作是概率模型，又可看作是非概率模型。</p>
</li>
</ul>
<p>其中，<code>条件概率分布</code>P(y|x)和<code>函数</code>y&#x3D;f(x)可以相互转换</p>
<ul>
<li><code>条件概率分布最大化</code>可得到<code>函数</code>（argmax）</li>
<li><code>函数归一化</code>后得到<code>条件概率分布</code></li>
<li>因此概率模型和非概率模型的区别不在于输入和输出的映射关系，而是<code>本身模型的内在结构</code>（概率模型通常表示为联合概率分布）<ul>
<li>理解：概率模型的代表是<code>概率图模型</code>，即将联合概率分布通过有向图&#x2F;无向图表示的概率模型，可以根据图的结构分解为因子乘积的形式，贝叶斯网络、马尔可夫随机场、条件随机场就是概率图模型，模型可以通过下述加法规则和乘法规则进行概率推导</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004201356250.png" alt="image-20241004201356250">	</p>
<h4 id="线性模型和非线性模型"><a href="#线性模型和非线性模型" class="headerlink" title="线性模型和非线性模型"></a>线性模型和非线性模型</h4><p>根据y&#x3D;f(x)是否为线性函数来划分<code>线性模型</code>和<code>非线性模型</code></p>
<ul>
<li>感知机、线性支持向量机、k近邻、k均值、潜在语义分析是线性模型。</li>
<li>核函数支持向量机、AdaBoost、神经网络是非线性模型。<ul>
<li>深度学习(deeplearning)实际是复杂神经网络的学习，也就是复杂的非线性模型的学习。</li>
</ul>
</li>
</ul>
<h4 id="参数化模型和非参数化模型"><a href="#参数化模型和非参数化模型" class="headerlink" title="参数化模型和非参数化模型"></a>参数化模型和非参数化模型</h4><ul>
<li><p><code>参数化模型</code>：假设<code>模型参数的维度</code>是固定的，即模型可由有限维的参数完全刻画</p>
<ul>
<li>本书介绍的感知机、朴素贝叶斯、逻辑斯谛回归、k 均值、高斯混合模型是参数化模型</li>
</ul>
</li>
<li><p><code>非参数化模型</code>：假设模型参数维度不固定或者随着训练数据量的增加而不断增大直至无穷大</p>
<ul>
<li>决策树、支持向量机、AdaBoost、k 近邻、潜在语义分析、概率潜在语义分析、潜在狄利克雷分配是非参数化模型。</li>
</ul>
</li>
<li><p>参数化模型适合简单的情况，非参数化复杂，而实际问题非参数化往往更有效</p>
</li>
</ul>
<h3 id="1-2-3-按算法分类（在线-批量学习）"><a href="#1-2-3-按算法分类（在线-批量学习）" class="headerlink" title="1.2.3 按算法分类（在线&#x2F;批量学习）"></a>1.2.3 按算法分类（在线&#x2F;批量学习）</h3><p>根据算法，分为<code>在线学习</code>和<code>批量学习</code></p>
<ul>
<li>在线学习：每次只接受一个样本，进行预测，之后学习模型不断重复该步骤（强化学习本身拥有在线学习的特点）</li>
<li>批量学习：一次性接受所有数据学习模型，进行预测</li>
<li>考虑在线的监督学习：每次只接收一个输入xi，然后通过模型给出预测f(xt)，得到输出反馈yt，然后通过损失函数I比较差异，更新迭代模型，不断操作<ul>
<li><code>随机梯度下降的感知机学习方法</code>就是在线学习算法</li>
</ul>
</li>
<li>实际当中可能更多的是两者学习的结合，即100个数据，分成10批，每批喂进去一部分数据，然后对于所有的部分结果求平均值，可能也会更稳定</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240923171631015.png" alt="image-20240923171631015">	</p>
<h3 id="1-2-4-按技巧分类"><a href="#1-2-4-按技巧分类" class="headerlink" title="1.2.4 按技巧分类"></a>1.2.4 按技巧分类</h3><h4 id="贝叶斯学习"><a href="#贝叶斯学习" class="headerlink" title="贝叶斯学习"></a>贝叶斯学习</h4><p>给出相关概念</p>
<ul>
<li><code>后验概率</code>：给定数据D条件下模型的条件概率 P(θ | D)</li>
<li><code>先验概率</code>：P(θ)</li>
<li><code>似然函数</code>：P(D | θ)</li>
</ul>
<p><code>贝叶斯学习</code>就是利用贝叶斯定理，通过模型的<code>先验概率P(θ)</code>和<code>似然函数P(D|θ)</code>，计算<code>后验概率分布 P(θ|D)</code>，进而进行模型的估计和预测，应用：朴素贝叶斯、潜在迪利克雷分配</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240923172921083.png" alt="image-20240923172921083">	</p>
<p>预测时，我们计算数据对后验分布的期望值，x是测试数据样本</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240923173106950.png" alt="image-20240923173106950">	</p>
<p><code>贝叶斯估计</code>和<code>极大似然估计</code></p>
<ul>
<li>联系：假设先验分布是<code>均匀分布</code>，取后验概率最大，那么可以从贝叶斯分布中得到极大似然估计</li>
<li>区别：一般情况下，贝叶斯引入了先验概率P(θ)，使得θ是有分布的，而在极大似然估计中，θ是均匀分布的</li>
<li>人话：极大似然估计认为每个θ的取值概率一样，贝叶斯估计认为每个取值可能由于某种因素θ的取值概率不一样</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240923173323522.png" alt="image-20240923173323522">	</p>
<h4 id="核方法"><a href="#核方法" class="headerlink" title="核方法"></a>核方法</h4><ul>
<li><p><code>核方法</code>：使用核函数表示和学习非线性方程的机器学习方法，可用于监督学习和无监督学习</p>
<ul>
<li>核函数支持向量机，以及核PCA、核k均值属于核方法</li>
</ul>
</li>
<li><p>核方法思想：线性模型可以基于相似度计算更加具体的进行向量<code>内积计算</code>，而核方法将其扩展到了非线性模型上</p>
</li>
<li><p>具体做法：显式定义<code>输入空间</code>（低维空间）到<code>特征空间</code>（高维空间），在特征空间中进行内积运算（支持向量机就是将输入空间的线性不可分转换成了特征空间线性可分的问题）</p>
</li>
<li><p>如图所示，核方法不在于如何定义映射，而是直接定义核函数K(x1, x2)（即通过从低维到高维的映射φ后，特征空间内的内积&lt;φ(x1), φ(x2)&gt;）</p>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240923173831929.png" alt="image-20240923173831929"><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20240923174018778.png" alt="image-20240923174018778" style="zoom:80%;" />	</p>
<h2 id="1-3-统计学习方法三要素"><a href="#1-3-统计学习方法三要素" class="headerlink" title="1.3 统计学习方法三要素"></a>1.3 统计学习方法三要素</h2><p><strong>统计学习方法 &#x3D; 模型 + 策略 + 算法</strong></p>
<h3 id="1-3-1-模型"><a href="#1-3-1-模型" class="headerlink" title="1.3.1 模型"></a>1.3.1 模型</h3><ul>
<li>监督学习中，模型就是所要学习的<code>条件概率分布</code> 或 <code>决策函数</code></li>
<li>模型的<code>假设空间</code>就是所有可能的条件概率分布或决策函数，一般为无穷个</li>
<li>如果假设空间用F表示，那么假设空间可以定义为某个决策函数的集合</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004202647532.png" alt="image-20241004202647532">	</p>
<ul>
<li>这里X和Y是输入空间和输出空间上的变量，假设空间F通常是由参数向量θ决定的函数族（R^n表示参数空间，即n维欧氏空间）</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004202917989.png" alt="image-20241004202917989">	</p>
<ul>
<li>如果X和Y是输入空间和输出空间上的随机变量，假设空间F通常是由参数向量θ决定的条件概率分布族</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004203105992.png" alt="image-20241004203105992">	</p>
<h3 id="1-3-2-策略"><a href="#1-3-2-策略" class="headerlink" title="1.3.2 策略"></a>1.3.2 策略</h3><ul>
<li>策略就是按照什么准则来学习或选择最优的模型，这是统计学习的目标</li>
<li>引入<code>损失函数</code>和<code>风险函数</code>的概念：<code>损失函数L(Y, f(X))</code>是衡量单次预测的好坏，<code>风险函数Rexp(f)</code>是平均意义下模型预测的好坏</li>
</ul>
<h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>常见的损失函数：</p>
<ul>
<li>0-1损失函数</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004203435594.png" alt="image-20241004203435594">	</p>
<ul>
<li>平方损失函数</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004203443842.png" alt="image-20241004203443842">	</p>
<ul>
<li>绝对损失函数</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004203449921.png" alt="image-20241004203449921">	</p>
<ul>
<li>对数（似然）损失函数</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004203456576.png" alt="image-20241004203456576">	</p>
<ul>
<li>损失函数越小越好，由于模型的输入输出遵循联合分布P(X, Y)，因此可以求得<code>损失函数的期望Rexp(f)</code></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004203801638.png" alt="image-20241004203801638">	</p>
<ul>
<li>但是联合分布是未知的，所以我们使用<code>经验风险Remp(f)</code>来代替<ul>
<li>根据大数定律，样本容量趋于无穷时，经验风险会趋于期望风险</li>
<li>但是实际情况很难搜集大量样本，因此需要对经验风险进行矫正，涉及到两个基本策略：<code>经验风险最小化 + 结构风险最小化</code>（加正则项防过拟合）</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004203930254.png" alt="image-20241004203930254">	</p>
<h4 id="经验风险最小化和结构风险最小化"><a href="#经验风险最小化和结构风险最小化" class="headerlink" title="经验风险最小化和结构风险最小化"></a>经验风险最小化和结构风险最小化</h4><ul>
<li><code>经验风险最小化(ERM)</code>：认为经验风险最小的模型就是最优模型<ul>
<li>样本足够大时：由很好的学习效果</li>
<li>实际应用：极大似然估计，当模型为条件概率分布，损失函数是对数损失函数时，经验风险最小化等价于极大似然估计</li>
<li>但是样本不够时，容易产生<code>过拟合</code>(over-fitting)的现象</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004204205864.png" alt="image-20241004204205864">	</p>
<ul>
<li><code>结构风险最小化(SRM)</code>：就是在ERM基础上加入了<code>正则化项</code>（罚项）<ul>
<li>J(f)就表示模型f越复杂，惩罚就越大，反之则越小，从而权衡经验风险与模型复杂度</li>
<li>实际应用：贝叶斯估计中，当模型是<code>最大后验概率估计(MAP)</code>，损失函数是对数损失函数，模型复杂度通过先验概率表示时，结构风险最小化等价于最大后验概率估计</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004204453388.png" alt="image-20241004204453388">	</p>
<ul>
<li>SRM就是认为结构风险最小的模型就是最优模型</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004204709837.png" alt="image-20241004204709837">	</p>
<p>至此，监督学习问题就变成<strong>经验风险&#x2F;结构风险最优化问题</strong></p>
<h3 id="1-3-3-算法"><a href="#1-3-3-算法" class="headerlink" title="1.3.3 算法"></a>1.3.3 算法</h3><ul>
<li>算法：学习模型的具体计算方法。统计学习根据学习策略，从假设空间中选到最优模型后，需要考虑用什么方法来求解最优模型</li>
<li>此时算法就是求解最优化问题的过程<ul>
<li>如果最优化问题有显式解，那么就比较简单</li>
<li>但是一般情况下，都没有显式解，需要通过数值计算的方法求解，需要找到一个全局最优解并且算法性能比较高效，这是一个重要问题</li>
</ul>
</li>
<li>后续实验的时候通过<a target="_blank" rel="noopener" href="https://keras.io/">Keras</a>可以帮助我们搭建神经网络，那么里面用到了一个最基础的算法就是<code>随机梯度下降</code></li>
</ul>
<h2 id="1-4-模型评估和模型选择"><a href="#1-4-模型评估和模型选择" class="headerlink" title="1.4 模型评估和模型选择"></a>1.4 模型评估和模型选择</h2><h3 id="1-4-1-训练误差和测试误差"><a href="#1-4-1-训练误差和测试误差" class="headerlink" title="1.4.1 训练误差和测试误差"></a>1.4.1 训练误差和测试误差</h3><ul>
<li>模型评估：基于损失函数的 <code>模型训练误差</code>和 <code>模型的测试误差</code></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004205657109.png" alt="image-20241004205657109">	</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004205716927.png" alt="image-20241004205716927">	</p>
<p>给出一个01损失函数的例子</p>
<img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004221758641.png" alt="image-20241004221758641" style="zoom:67%;" />	

<ul>
<li>测试误差反应出模型对于未知测试数据集的预测能力，这种能力称为<code>泛化能力</code></li>
</ul>
<h3 id="1-4-2-过拟合与模型选择"><a href="#1-4-2-过拟合与模型选择" class="headerlink" title="1.4.2 过拟合与模型选择"></a>1.4.2 过拟合与模型选择</h3><ul>
<li>我们在选择模型时要与真实模型参数个数相同，所选择的参数向量也要和真实参数向量相近</li>
<li>而如果过于追求训练数据的预测能力，模型的复杂度会比真模型高，造成<code>过拟合现象</code>，表现为对已知数据预测很好，而对未知数据预测很差</li>
<li>给出一个0-9多项式拟合一个数据集T &#x3D; {x1, y1), (x2, y2),…,(xn, yn)} 的例子</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004222204245.png" alt="image-20241004222204245">	</p>
<p>顺带一提：对于该多项式的问题的解决，需要重新确定多项式的次数，然后按照该复杂度，通过经验风险最小化的策略求解参数（多项式系数）</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004222500739.png" alt="image-20241004222500739">	</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004222526391.png" alt="image-20241004222526391">	</p>
<p><strong>训练误差和测试误差的关系</strong></p>
<ul>
<li>测试误差会随着模型的复杂度先减小后增大，如果过大，就会过拟合</li>
<li>如果过拟合，需要选择复杂度适当的模型，从而使得测试误差最小，常用的方法：<code>正则化、交叉验证</code></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004222340149.png" alt="image-20241004222340149">	</p>
<h2 id="1-5-正则化和交叉验证"><a href="#1-5-正则化和交叉验证" class="headerlink" title="1.5 正则化和交叉验证"></a>1.5 正则化和交叉验证</h2><h3 id="1-5-1-正则化"><a href="#1-5-1-正则化" class="headerlink" title="1.5.1 正则化"></a>1.5.1 正则化</h3><ul>
<li><code>正则化</code>是结构风险最小化策略的实现，在经验风险上加上正则化项（罚项），模型越复杂，正则化项越大<ul>
<li>经验风险 + 正则化项（λ是调整两者关系的系数），贝叶斯中，模型的先验概率就是正则化项</li>
<li>经验风险较小时，模型可能比较复杂（多个非0参数），那么第二个模型复杂度就会大</li>
<li>而正则化就是选择经验风险和模型复杂度同时较小的模型，符合<code>奥卡姆剃刀</code>原理（less is more）</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004222907573.png" alt="image-20241004222907573">	</p>
<ul>
<li>正则化项可以有不同的形式，如回归问题中，损失函数是平方损失，正则化项可以是<code>参数向量的L2范数</code>（当然也可以为L1范数）<ul>
<li>||w|| &#x3D; sqrt(w1^2 + w2^2 … + wn^2)</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004223115082.png" alt="image-20241004223115082">	</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004223215843.png" alt="image-20241004223215843">	</p>
<h3 id="1-5-2-交叉验证"><a href="#1-5-2-交叉验证" class="headerlink" title="1.5.2 交叉验证"></a>1.5.2 交叉验证</h3><ul>
<li>如果样本充足，可以随机将数据集分为3部分：训练集 + 验证集（调整超参数 进而选择合适模型） + 测试集（泛化能力）<ul>
<li>基准差不多是 70% + 10% + 20%，实际情况分配要调整，如果足够多，可以把更多的比例分给训练集</li>
</ul>
</li>
<li>但实际情况经常是不充足的，那么思路是：重复使用数据，用到<code>交叉验证</code>的方法<ul>
<li>将数据切分为训练集和测试集，在此基础上反复进行训练、测试、模型选择</li>
</ul>
</li>
</ul>
<p>交叉验证的实现</p>
<ul>
<li><code>简单交叉验证</code>：数据集随机分为两部分，训练集 + 测试集，约73开，对训练集各种调参，得到不同模型，然后逐个测试评价</li>
<li><code>*S折交叉验证</code>：应用最多。数据切分为S个互不相交、大小相同的子集，S-1个子集训练模型，剩下的训练模型，将可能的S种情况重复进行，选出S次中误差最小的<ul>
<li>留一交叉验证：是S折交叉验证的特殊情况，让S &#x3D; N，每份只有一个样本，往往在数据缺乏的时候用</li>
</ul>
</li>
</ul>
<h2 id="1-6-泛化能力"><a href="#1-6-泛化能力" class="headerlink" title="1.6 泛化能力"></a>1.6 泛化能力</h2><h3 id="1-6-1-泛化误差"><a href="#1-6-1-泛化误差" class="headerlink" title="1.6.1 泛化误差"></a>1.6.1 泛化误差</h3><p>首先给出<code>泛化误差</code>的定义。如果学到的模型是f^，那么用这个模型对未知数据预测的误差即为泛化误差(generalization error):</p>
<ul>
<li>泛化误差反映出泛化能力，实际上就是前面的期望风险，但往往求不出该风险。</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004224258758.png" alt="image-20241004224258758">	</p>
<h3 id="1-6-2-泛化误差上界"><a href="#1-6-2-泛化误差上界" class="headerlink" title="1.6.2 泛化误差上界"></a>1.6.2 泛化误差上界</h3><ul>
<li>我们往往比较两种学习方法的<code>泛化误差上界</code>来比较优劣</li>
<li>泛化误差上界的性质<ul>
<li>是关于<code>样本容量</code>的函数，当样本容量N增加时，泛化误差上界趋于0</li>
<li>是关于<code>假设空间容量</code>的函数，当空间容量d越大，模型越难学，泛化误差上界越大</li>
</ul>
</li>
<li>给出一个二类分类的实际例子（在假设空间是有限个函数的情况下），上界的证明在书P26-27，借助Hoeffding不等式推导得到。</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004224717705.png" alt="image-20241004224717705">	</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241004224834005.png" alt="image-20241004224834005">	</p>
<h2 id="1-7-生成模型和判别模型"><a href="#1-7-生成模型和判别模型" class="headerlink" title="1.7 生成模型和判别模型"></a>1.7 生成模型和判别模型</h2><ul>
<li><p>在监督学习中，模型分为决策函数或者条件概率分布</p>
</li>
<li><p><code>监督学习</code>的方法可分为<code>生成方法</code>和<code>判别方法</code>，对应的模型为<code>生成模型</code>和<code>判别模型</code></p>
</li>
<li><p>生成方法是同数据学习联合概率分布P(X, Y)，然后求出条件概率P(Y | X)作为预测的模型，即生成模型</p>
<ul>
<li>之所以叫生成模型，是因为模型给定了X-&gt;Y的生成关系，更强调数据本身</li>
<li>典型的生成模型是朴素贝叶斯、隐马尔可夫模型</li>
<li>生活例子：判别一只羊是山羊还是绵羊，那么就学习所有山羊和绵羊的特征，然后判断给定测试数据后是山羊还是绵羊的概率大</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241005091839870.png" alt="image-20241005091839870">    </p>
</li>
<li><p>判别方法是直接学习决策函数f(X)或者条件概率分布P(Y | X) 作为预测模型，即判别模型</p>
<ul>
<li>判别模型更关系的是根据输入X，应该预测什么模型，更强调数据边界</li>
<li>典型的判别模型是k近邻法、感知机、决策树、逻辑斯谛回归模型、最大熵模型、支持向量机、提升方法和条件随机场等</li>
<li>生活例子：判断语言是韩文还是日文，可以根据思密达判断，无需学习整个语言体系，只需要对比各个类别的差异直接对输入进行判别</li>
</ul>
</li>
<li><p>生成方法评价</p>
<ul>
<li>生成方法能还原出条件概率分布，但判别模型不能</li>
<li>生成方法收敛速度快（样本增加时，可以更快的收敛于真实模型）</li>
<li>存在隐变量时，仍然可以用生成方法学习（EM算法），而判别方法不能</li>
</ul>
</li>
<li><p>判别方法评价</p>
<ul>
<li>判别直接学习条件概率或决策函数，直接面向预测，并不关系x和y的关系，预测准确率往往更高</li>
<li>对数据进行各种程度的抽象，定义特征和使用特征可以简化学习问题</li>
</ul>
</li>
</ul>
<h2 id="1-8-监督学习应用"><a href="#1-8-监督学习应用" class="headerlink" title="1.8 监督学习应用"></a>1.8 监督学习应用</h2><h3 id="1-8-1-分类问题"><a href="#1-8-1-分类问题" class="headerlink" title="1.8.1 分类问题"></a>1.8.1 分类问题</h3><ul>
<li><p>监督学习中，输出变量Y为有限个离散值时，预测问题成为分类问题，X可以是连续也可以是离散的，这里主要讨论<code>二类分类</code>问题</p>
<ul>
<li>学习包含了学习和分类的两个过程</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241005092839574.png" alt="image-20241005092839574">    </p>
</li>
<li><p>一般评价分类器性能的是分类准确率（accuracy），正确分类样本数 &#x2F; 总样本数</p>
</li>
<li><p>针对二类分类问题，常用指标：<code>精确率</code>（precision）、<code>召回率</code>（recall 查全率）</p>
<ul>
<li>precision：预测为正类的哪些是预测对的<ul>
<li>应用：给小孩推荐电影，正类是正常电影，负类是小孩子不能看的电影，我宁可FP-&gt;0，也要保证正确的比率，做到精准推送</li>
</ul>
</li>
<li>recall：正类样本预测对的比例<ul>
<li>应用：预测癌症，正类是患癌，负类是没有患癌，我要确保真正患癌的要预测对，另可错杀一万（FP-&gt;∞），也不能放过一个( FN-&gt;0 )</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241005093216314.png" alt="image-20241005093216314">	</p>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241005093223964.png" alt="image-20241005093223964">	</p>
<ul>
<li>许多统计学习方法可以用于分类，包括k近邻法、感知机、朴素贝叶斯法、决策树、决策列表、逻辑斯谛回归模型、支持向量机、提升方法、贝叶斯网络、神经网络、Winnow等</li>
</ul>
<h3 id="1-8-2-标注问题"><a href="#1-8-2-标注问题" class="headerlink" title="1.8.2 标注问题"></a>1.8.2 标注问题</h3><ul>
<li><code>标注</code>(tagging)，可以看作是分类问题的推广，输入X是一个观测序列，输出Y是一个标记序列（状态序列）<ul>
<li>注意标记序列的组合会随着序列长度呈指数级增长</li>
</ul>
</li>
<li>评价指标同分类模型指标，标注准确率、精确率、召回率</li>
<li>标注的统计学习方法包括：隐马尔可夫模型、条件随机场</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241005094104499.png" alt="image-20241005094104499">	</p>
<ul>
<li>标注在信息提取、自然语言处理有广泛应用</li>
<li>给出词性标注的例子，英文单词是一个观测，英文句子是一个观测序列，打的标注：B是开始，E是结束，O是其他，信息抽取时，从开始到结束作为一个名词短语</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241005094427314.png" alt="image-20241005094427314">	</p>
<h3 id="1-8-3-回归问题"><a href="#1-8-3-回归问题" class="headerlink" title="1.8.3 回归问题"></a>1.8.3 回归问题</h3><ul>
<li><code>回归(regression)</code>用来预测输入变量x和输出变量y之间的关系，等价于函数拟合，同样包含学习和预测的两个过程</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://yuezi-1308313119.cos.ap-guangzhou.myqcloud.com/typora-user-images%2Fimage-20241005094857017.png" alt="image-20241005094857017">	</p>
<ul>
<li>回归问题根据输入变量的个数分为一元回归和多元回归，根据x和y之间的关系又分为线性回归和非线性回归</li>
<li>回归学习常用的损失函数是平方损失函数，常用最小二乘法求解</li>
<li>应用：商务领域，市场趋势分析、质量管理、股价预测，根据过去的数据学习模型，基于当前信息预测公司下一个时间点股票的价格</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yuezi2048.github.io">yuezi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yuezi2048.github.io/2024/12/27/2.Areas%F0%9F%8C%90/science/Pre/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/1.%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/1.%20%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/">https://yuezi2048.github.io/2024/12/27/2.Areas🌐/science/Pre/统计学习方法/1.监督学习/1. 统计学习及监督学习概论/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://yuezi2048.github.io" target="_blank">yuezi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/1-%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/">1.监督学习</a></div><div class="post-share"><div class="social-share" data-image="/img/touxiang.jpg" data-sites="qq,wechat"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/27/2.Areas%F0%9F%8C%90/science/Pre/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/1.%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/2.%20%E6%84%9F%E7%9F%A5%E6%9C%BA/" title="2. 感知机"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">2. 感知机</div></div><div class="info-2"><div class="info-item-1">[TOC] 二、感知机 感知机是二类分类的线性模型，输入为实例的特征向量，输出为实例的类别（取-1和+1） 感知机将实例划分为正负两类的分离超平面，属于判别模型 基于误分类的损失函数，通过梯度下降法对损失函数进行极小化得到感知机模型 感知机包括原始形式和对偶形式，是后续学习神经网络和支持向量机的基础  2.1 感知机模型 感知机模型函数表示如下  	   是一个线性分类模型，属于判别模型 假设空间是定义在特征空间中所有线性分类模型 模型的几何解释如下  	    2.2 感知机学习策略2.2.1 线性可分性 存在一个超平面，完全正确地将正实例点和负实例点划分到超平面的两侧，则称数据集T为线性可分数据集  	    2.2.2 学习策略 我们首先假设训练集线性可分，那么就是要找出这个完全正确划分的超平面，那么学习策略就是要定义经验损失函数并最小化 经验损失函数，并没有天然地选择误分类点的个数来进行判断，因为这不是连续可导，而是选择了所有误分类点到超平面S的总距离进行判断，一个点到平面的距离可以这样表示  	  对于误分类的数据来说，yi和w·xi +...</div></div></div></a><a class="pagination-related" href="/2024/12/31/2.Areas%F0%9F%8C%90/science/Pre/%E7%BB%BC%E8%BF%B0/A%20survey%20on%20causal%20infer.../" title="A survey on causal infer..."><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">A survey on causal infer...</div></div><div class="info-2"><div class="info-item-1">Treatment effect estimation 用于 policy evaluation 用药领域，如果我们想要评估一个药对寿命的影响那么要回答一个问题：如果强制复用该药物，患者在L年内存活的可能性是多少一个比较好的方式是大规模随机对照实验（large-scale randomized controlled trial）  但是有成本乃至道德上的问题  因此我们只能从非随机观测数据中估计结果：  药物与生存的相关性并不意味着有因果关系，比如年龄、性别、疾病等严重程度等因素可能影响结果  推荐系统中的因果关系，也被用于评估策略估计的一个提升模型最近几年，才倾向于应用因果推断来进行模型的训练 因果推理可以应用到CTR，点击后指标预测、以及RS各个阶段：数据搜集、用户的表示学习、无偏嵌入，以及目标优化和在线&#x2F;离线策略评估 具有的优势：  模型中的因果。推荐系统主要也是依赖于统计方法，着重关注变量之间的相关性，但是在应用中，应当更加关注因果关系而不是相关性 传统推荐系统学习到的虚假关联spurious...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/12/27/2.Areas%F0%9F%8C%90/science/Pre/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/1.%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/2.%20%E6%84%9F%E7%9F%A5%E6%9C%BA/" title="2. 感知机"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-27</div><div class="info-item-2">2. 感知机</div></div><div class="info-2"><div class="info-item-1">[TOC] 二、感知机 感知机是二类分类的线性模型，输入为实例的特征向量，输出为实例的类别（取-1和+1） 感知机将实例划分为正负两类的分离超平面，属于判别模型 基于误分类的损失函数，通过梯度下降法对损失函数进行极小化得到感知机模型 感知机包括原始形式和对偶形式，是后续学习神经网络和支持向量机的基础  2.1 感知机模型 感知机模型函数表示如下  	   是一个线性分类模型，属于判别模型 假设空间是定义在特征空间中所有线性分类模型 模型的几何解释如下  	    2.2 感知机学习策略2.2.1 线性可分性 存在一个超平面，完全正确地将正实例点和负实例点划分到超平面的两侧，则称数据集T为线性可分数据集  	    2.2.2 学习策略 我们首先假设训练集线性可分，那么就是要找出这个完全正确划分的超平面，那么学习策略就是要定义经验损失函数并最小化 经验损失函数，并没有天然地选择误分类点的个数来进行判断，因为这不是连续可导，而是选择了所有误分类点到超平面S的总距离进行判断，一个点到平面的距离可以这样表示  	  对于误分类的数据来说，yi和w·xi +...</div></div></div></a><a class="pagination-related" href="/2024/12/27/2.Areas%F0%9F%8C%90/science/Pre/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/1.%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/3.%20k%E8%BF%91%E9%82%BB%E6%B3%95/" title="3. k近邻法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-27</div><div class="info-item-2">3. k近邻法</div></div><div class="info-2"><div class="info-item-1">[TOC] 三、k近邻法 K-NN是一个基本的分类和回归方法，此处讨论基本的分类问题 输入为实例的特征向量，对应于特征空间的点，输出是实例的类别，可以取多个类 k近邻是假设给定训练数据集，其中的实例类别已定，分类时根据k个最近邻的训练实例类别通过多数表决的方式进行预测，并没有显式的学习过程 k值的选择、距离度量和分类决策规则是k近邻法的3个基本要素  3.1 k近邻算法 特殊的情况是k&#x3D;1时，此时为最近邻算法 k近邻算法没有显式的学习过程  	 3.2 k近邻模型与决策规则3.2.1 模型 k近邻模型主要有3个基本要素：距离度量、k值选择和分类决策规则，确定好上述后，给定一个输入实例，就可以唯一地确定它所属类 在特征空间当中，每一个训练实例点xi，距离该点比其他点更近的所有点组成的一个区域叫做单元(cell)，一个单元构成对于特征空间的一个划分 最近邻算法是实例xi的类yi作为其单元中所有点的类标记(class label)，从而每个单元实例点的类别可以确定，见下图所示    	 3.2.2...</div></div></div></a><a class="pagination-related" href="/2024/12/27/2.Areas%F0%9F%8C%90/science/Pre/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/1.%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/4.%20%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/" title="4. 朴素贝叶斯法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-27</div><div class="info-item-2">4. 朴素贝叶斯法</div></div><div class="info-2"><div class="info-item-1">[TOC] 四、朴素贝叶斯法 朴素贝叶斯是基于贝叶斯定理和特征条件独立假设的分类方法 对于给定是训练数据集，基于特征条件独立假设学习输入输出的联合概率分布 然后基于该模型对给定的输入x使用贝叶斯定理求出后验概率最大的 输出y  4.1 朴素贝叶斯法的学习与分类4.1.1 模型——基本方法 输入空间X是n维向量集合R^n，输出空间Y是类标记集合{c1, c2, …, ck} 朴素贝叶斯首先学习联合概率分布P(X, Y)，具体需要学习先验概率分布和条件概率分布，这是我们之前提到的生成模型的做法  	  其中，条件概率分布P(X &#x3D; x | Y &#x3D; ck)的参数数量是指数级的，直接估计是不行的  假设n维输入变量，每组x值有Sj组特征，Y可能的取值有k个，根据排列组合，参数的个数就是   因此为了简化问题，朴素贝叶斯作出条件独立性假设，他可以使得X的每组特征是独立的，所以可以直接连乘起来   	 后验概率P(Y = ck | X = x)就可以计算得到如下  其中分母是P(X &#x3D; x)的全概率展开形式，表示y&#x3D;c1, c2, ..,...</div></div></div></a><a class="pagination-related" href="/2024/12/27/2.Areas%F0%9F%8C%90/science/Pre/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/1.%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/5.%20%E5%86%B3%E7%AD%96%E6%A0%91/" title="5. 决策树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-27</div><div class="info-item-2">5. 决策树</div></div><div class="info-2"><div class="info-item-1">[TOC] 五、决策树 决策树（decision tree）是一个基本的分类和回归方法，这里主要讨论分类 决策树模型是树型结构，表示基于特征对实例进行分类的过程 被认为是if-then规则的集合（说明了可解释性） 也可以认为是定义在特征空间和类空间上的条件概率分布 有点就是可读性与分类速度快   学习时，在训练数据集上通过损失函数最小化建立决策树模型。预测时，对测试集利用决策树模型进行分类 学习包含三个步骤 特征选择 决策树的生成 决策树的修剪（防止过拟合）   决策树的算法包括：Quinlan在1986年提出的ID3方法，1993年提出的C4.5算法，Breiman等人1986年提出的CART算法  注：这里是后续学习XGBoost和GBDT等高阶决策树模型的基础，所以也需要了解基础模型。 5.1 决策树模型和学习5.1.1...</div></div></div></a><a class="pagination-related" href="/2024/12/27/2.Areas%F0%9F%8C%90/science/Pre/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/1.%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/6.%20%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%E5%9B%9E%E5%BD%92%E5%92%8C%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/" title="6. 逻辑斯蒂回归和最大熵模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-27</div><div class="info-item-2">6. 逻辑斯蒂回归和最大熵模型</div></div><div class="info-2"><div class="info-item-1">[TOC] 六、logistic回归和最大熵模型 logistic回归是经典分类方法，最大熵模型是概率模型学习中的重要准则，可推广到最大熵模型 maximum entropy model 之所以放在一起说，是因为logistic回归模型和最大熵模型都属于对数线性模型  6.1 logistic回归6.1.1 logistic分布	 我们可根据上述函数绘制出f(x)和F(x)的图形 	 分布函数F(x)属于logistic函数，图形是S形曲线，关于点(u, 1/2)对称s，即满足 	 从F(x)的导数f(x)图像上，我们也可以发现，两端增长速度慢，中心附近增长快 同时可以控制形状变量y，y越小，可以使得中心附近增长的速度越快 6.1.2 二项logistic回归模型二项logistic回归模型是一种分类模型，通过条件概率分布P(Y |...</div></div></div></a><a class="pagination-related" href="/2024/12/27/2.Areas%F0%9F%8C%90/science/Pre/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/1.%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/8.%20Boosting/" title="8. Boosting"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-27</div><div class="info-item-2">8. Boosting</div></div><div class="info-2"><div class="info-item-1">[TOC] 八、Boosting Boosting在分类问题中，通过改变训练样本的权重，学习多个分类器，将这些分类器进行线性组合，提高分类的性能 本章主要讨论的问题 Boosting思路和代表性AdaBoost算法 探讨为什么能提高学习精度，从前向分布加法模型解释AdaBoost算法 叙述Boosting具体实例——提升树    8.1 AdaBoost算法8.1.1 Boosting基本思路 思想：三个臭皮匠顶过一个诸葛亮的道理，对多个专家的判断进行综合进行判断（提高专家权重，减少普通人的权重） 在概率近似框架（PAC）框架中，一个概念可强学习的充要条件是这个概念可弱学习的，换句话说弱学习算法可以提升（boost）为强学习算法 强可学习：存在一个多项式学习算法能够学习，且正确率高 弱可学习：存在一个多项式学习算法能够学习，但正确率比随机猜测略好   对于分类问题而言，Boosting的思路就是从弱学习算法出发得到一系列弱分类器，再组合这些弱分类器（通常是改变概率分布...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yuezi</div><div class="author-info-description">积微者速成</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">785</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">91</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuezi2048"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://githubfast.com/yuezi2048" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_46345703" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=dD62GIPTf5-iS4UdSfJRy7NHwsrCh3-j" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:joyLing@stumail.nwu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">积微者速成</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA"><span class="toc-text">一、统计学习及监督学习概论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0"><span class="toc-text">1.1 统计学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">1.2 统计学习的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E5%9F%BA%E6%9C%AC%E5%88%86%E7%B1%BB"><span class="toc-text">1.2.1 基本分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0"><span class="toc-text">监督学习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0"><span class="toc-text">无监督学习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0"><span class="toc-text">强化学习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E6%8C%89%E6%A8%A1%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="toc-text">1.2.2 按模型分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E7%8E%87%E6%A8%A1%E5%9E%8B%E5%92%8C%E9%9D%9E%E6%A6%82%E7%8E%87%E6%A8%A1%E5%9E%8B"><span class="toc-text">概率模型和非概率模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B"><span class="toc-text">线性模型和非线性模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%8C%96%E6%A8%A1%E5%9E%8B%E5%92%8C%E9%9D%9E%E5%8F%82%E6%95%B0%E5%8C%96%E6%A8%A1%E5%9E%8B"><span class="toc-text">参数化模型和非参数化模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E6%8C%89%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB%EF%BC%88%E5%9C%A8%E7%BA%BF-%E6%89%B9%E9%87%8F%E5%AD%A6%E4%B9%A0%EF%BC%89"><span class="toc-text">1.2.3 按算法分类（在线&#x2F;批量学习）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-%E6%8C%89%E6%8A%80%E5%B7%A7%E5%88%86%E7%B1%BB"><span class="toc-text">1.2.4 按技巧分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AD%A6%E4%B9%A0"><span class="toc-text">贝叶斯学习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E6%96%B9%E6%B3%95"><span class="toc-text">核方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-text">1.3 统计学习方法三要素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E6%A8%A1%E5%9E%8B"><span class="toc-text">1.3.1 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E7%AD%96%E7%95%A5"><span class="toc-text">1.3.2 策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="toc-text">损失函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E9%AA%8C%E9%A3%8E%E9%99%A9%E6%9C%80%E5%B0%8F%E5%8C%96%E5%92%8C%E7%BB%93%E6%9E%84%E9%A3%8E%E9%99%A9%E6%9C%80%E5%B0%8F%E5%8C%96"><span class="toc-text">经验风险最小化和结构风险最小化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E7%AE%97%E6%B3%95"><span class="toc-text">1.3.3 算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E5%92%8C%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9"><span class="toc-text">1.4 模型评估和模型选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E8%AE%AD%E7%BB%83%E8%AF%AF%E5%B7%AE%E5%92%8C%E6%B5%8B%E8%AF%95%E8%AF%AF%E5%B7%AE"><span class="toc-text">1.4.1 训练误差和测试误差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E8%BF%87%E6%8B%9F%E5%90%88%E4%B8%8E%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9"><span class="toc-text">1.4.2 过拟合与模型选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E6%AD%A3%E5%88%99%E5%8C%96%E5%92%8C%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81"><span class="toc-text">1.5 正则化和交叉验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-%E6%AD%A3%E5%88%99%E5%8C%96"><span class="toc-text">1.5.1 正则化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81"><span class="toc-text">1.5.2 交叉验证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E6%B3%9B%E5%8C%96%E8%83%BD%E5%8A%9B"><span class="toc-text">1.6 泛化能力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-1-%E6%B3%9B%E5%8C%96%E8%AF%AF%E5%B7%AE"><span class="toc-text">1.6.1 泛化误差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-2-%E6%B3%9B%E5%8C%96%E8%AF%AF%E5%B7%AE%E4%B8%8A%E7%95%8C"><span class="toc-text">1.6.2 泛化误差上界</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B"><span class="toc-text">1.7 生成模型和判别模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E5%BA%94%E7%94%A8"><span class="toc-text">1.8 监督学习应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-1-%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-text">1.8.1 分类问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-2-%E6%A0%87%E6%B3%A8%E9%97%AE%E9%A2%98"><span class="toc-text">1.8.2 标注问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-3-%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98"><span class="toc-text">1.8.3 回归问题</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/22/Excalidraw/Drawing%202024-11-01%2015.37.37.excalidraw/" title="Drawing 2024-11-01 15.37.37.excalidraw">Drawing 2024-11-01 15.37.37.excalidraw</a><time datetime="2026-02-22T05:56:41.839Z" title="发表于 2026-02-22 13:56:41">2026-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/22/2.Areas%F0%9F%8C%90/01.project/condefather/yupao/back-end/7.%E4%BC%98%E5%8C%96%E4%B8%BB%E9%A1%B5%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/" title="7.优化主页性能-优化批量导入数据">7.优化主页性能-优化批量导入数据</a><time datetime="2026-02-22T05:56:41.257Z" title="发表于 2026-02-22 13:56:41">2026-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/31/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/5.%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8/" title="5.工具调用">5.工具调用</a><time datetime="2026-01-31T03:54:22.000Z" title="发表于 2026-01-31 11:54:22">2026-01-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/30/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/4.RAG%E8%BF%9B%E9%98%B6/" title="4.RAG进阶">4.RAG进阶</a><time datetime="2026-01-30T13:23:42.000Z" title="发表于 2026-01-30 21:23:42">2026-01-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/2.Areas%F0%9F%8C%90/%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/3.RAG/" title="3.RAG">3.RAG</a><time datetime="2026-01-27T09:06:56.000Z" title="发表于 2026-01-27 17:06:56">2026-01-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/default.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2026 By yuezi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>